          ============================================================
          |                                                          |
          |            Crystallography & NMR System (CNS)            |
          |                         CNSsolve                         |
          |                                                          |
          ============================================================
           Version: 1.3 at patch level U
           Status: Special UU release with Rg, paramagnetic
                   and Z-restraints (A. Bonvin, UU 2013)
          ============================================================
           Written by: A.T.Brunger, P.D.Adams, G.M.Clore, W.L.DeLano,
                       P.Gros, R.W.Grosse-Kunstleve,J.-S.Jiang,J.M.Krahn,
                       J.Kuszewski, M.Nilges, N.S.Pannu, R.J.Read,
                       L.M.Rice, G.F.Schroeder, T.Simonson, G.L.Warren.
           Copyright (c) 1997-2010 Yale University
          ============================================================
           Running on machine: wn-ha-24.gina.surfsara.nl (x86_64/Linux,64-bit)
           Program started by: enm009
           Program started at: 09:31:27 on 08-Nov-2022
          ============================================================

 FFT3C: Using FFTPACK4.1

 CNSsolve>! refine.inp 
 CNSsolve>!    The core docking script of HADDOCK performing rigid-body docking 
 CNSsolve>!    and semi-flexible refinement in torsion angle space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>@RUN:protocols/initialize.cns(iteration=$iteration;) 
 ASSFIL: file initialize.cns opened.
 CNSsolve>! initialize.cns 
 CNSsolve>!    Iteration initialization 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (iteration;) 
 &_2_ITERATION set to $_1_ITERATION 
 CNSsolve>evaluate (&iteration = "") 
 EVALUATE: symbol $_1_ITERATION set to "" (string)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>@NEWIT:iteration.cns(iteration=$iteration;) 
 ASSFIL: file iteration.cns opened.
 CNSsolve>module ( iteration ) 
 &_2_ITERATION set to $_1_ITERATION 
 CNSsolve>evaluate (&iteration=0) 
 EVALUATE: symbol $_1_ITERATION set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>@RUN:run.cns( 
 ASSFIL: file run.cns opened.
 CNSsolve>! run.cns 
 CNSsolve>!    The file containing all parameters for HADDOCK 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>module( 
 MODULE-DECLARATION>iteration; 
 MODULE-DECLARATION>filenames; 
 MODULE-DECLARATION>data; 
 MODULE-DECLARATION>iterations; 
 MODULE-DECLARATION>saprotocol; 
 MODULE-DECLARATION>refine; 
 MODULE-DECLARATION>toppar; 
 MODULE-DECLARATION>analysis; 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>iteration =$iteration; 
 &_2_ITERATION set to $_1_ITERATION 
 MODULE-INVOCATION>filenames =$filenames; 
 &_2_FILENAMES set to $_1_FILENAMES 
 MODULE-INVOCATION>Data      =$Data; 
 &_2_DATA set to $_1_DATA 
 MODULE-INVOCATION>iterations=$iterations; 
 &_2_ITERATIONS set to $_1_ITERATIONS 
 MODULE-INVOCATION>saprotocol=$saprotocol; 
 &_2_SAPROTOCOL set to $_1_SAPROTOCOL 
 MODULE-INVOCATION>refine    =$refine; 
 &_2_REFINE set to $_1_REFINE 
 MODULE-INVOCATION>toppar    =$toppar; 
 &_2_TOPPAR set to $_1_TOPPAR 
 MODULE-INVOCATION>analysis  =$analysis;) 
 &_2_ANALYSIS set to $_1_ANALYSIS 
 CNSsolve> 
 CNSsolve>{+ File: run.cns +} 
 CNSsolve>{+ Description: this file contains all necessary information to run HADDOCK. +} 
 CNSsolve> 
 CNSsolve>{+ Authors: Ezgi Karaca, Joao Rodrigues, Mikael Trellet, Alexandre Bonvin<br> 
 CNSsolve>Adapted from HADOOCK version 2.4 <br><br> 
 CNSsolve>Initially adapted from ARIA of Nilges and Linge +} 
 CNSsolve> 
 CNSsolve>{+ Please cite the following references when using this protocol: +} 
 CNSsolve>{+ reference: Cyril Dominguez, Rolf Boelens and Alexandre M.J.J. Bonvin (2003).  HADDOCK: a protein-protein docking approach 
 CNSsolve>based on biochemical and/or biophysical information. <i>J. Am. Chem. Soc.</i> <b>125</b>, 1731-1737. 
 CNSsolve><p> 
 CNSsolve><b>When using <i>residual dipolar couplings</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><LI>A.D.J. van Dijk, D. Fushman and A.M.J.J. Bonvin (2005). Various strategies of using residual dipolar 
 CNSsolve>couplings in NMR-driven protein docking: Application to Lys48-linked di-ubiquitin and validation against 
 CNSsolve>15N-relaxation data. <EM>Proteins: Struc. Funct. & Bioinformatics</EM>, <STRONG>60</STRONG>, 367-381.</li> 
 CNSsolve><p> 
 CNSsolve><b>When using <i>diffusion anisotropy data</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><li>A.D.J. van Dijk, R. Kaptein, R. Boelens and A.M.J.J. Bonvin (2006). Combining NMR relaxation with 
 CNSsolve>chemical shift perturbation data to drive protein-protein docking. <EM>J. Biomol. NMR</EM>, 
 CNSsolve><STRONG>34</STRONG>, 237-244.</li> 
 CNSsolve><p> 
 CNSsolve><b>When using <i>solvated docking</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><li>A.D.J. van Dijk and A.M.J.J. Bonvin (2006). Solvated docking: introducing water into the modelling 
 CNSsolve>of biomolecular complexes. <EM>Bioinformatics</EM>,  <STRONG>22</STRONG> 2340-2347. 
 CNSsolve><p> 
 CNSsolve><b>When performing <i>flexible protein-DNA docking</i> using HADDOCK cite in addition:</b><p> 
 CNSsolve><li>M. van Dijk, A.D.J. van Dijk, V. Hsu, R. Boelens and  A.M.J.J. Bonvin (2006). 
 CNSsolve>Information-driven Protein-DNA Docking using HADDOCK: it is a matter of flexibility. 
 CNSsolve><EM>Nucl. Acids Res.</EM>, <STRONG>34</STRONG> 3317-3325.</li> 
 CNSsolve><p> 
 CNSsolve><b>When performing the Nmolecule integrative modelling protocol please cite:</b><p> 
 CNSsolve><li>Ezgi Karaca, Joao P.G.L.M. Rodrigues, Andrea Graziadei, Alexandre M.J.J. Bonvin, Teresa Carlomagno (2017). 
 CNSsolve>An Integrative Framework for Structure Determination of Molecular Machines. 
 CNSsolve><EM>Nature Methods</EM>, Advanced Online Publication.</li> 
 CNSsolve>+} 
 CNSsolve> 
 CNSsolve>{- Guidelines for using this file: 
 CNSsolve>   - all strings must be quoted by double-quotes 
 CNSsolve>   - logical variables (true/false) are not quoted 
 CNSsolve>   - do not remove any evaluate statements from the file 
 CNSsolve>   - pathnames should not exceed 80 characters -} 
 CNSsolve>{- begin block parameter definition -} define( 
 DEFINE> 
 DEFINE> 
 DEFINE>{======== number of molecules for docking ==================} 
 DEFINE>{* number of components *} 
 DEFINE> 
 DEFINE>{===>} ncomponents=2; 
 DEFINE> 
 DEFINE>{======================= filenames =========================} 
 DEFINE>{*  the name of your current project *} 
 DEFINE>{*  this will be used as name for the generated structures *} 
 DEFINE>{===>} fileroot="complex"; 
 DEFINE> 
 DEFINE>{* RUN directory *} 
 DEFINE>{*  the absolute path of your current run, e.g. /home/haddock/run1*} 
 DEFINE>{===>} run_dir="/home/enmr/csb_webserver/data/runs/haddock24/userrun00189263/run1"; 
 DEFINE> 
 DEFINE>{* PDB file of molecule 1 *} 
 DEFINE>{===>} prot_coor_mol1="protein1.pdb"; 
 DEFINE>{* PSF file of molecule 1 *} 
 DEFINE>{===>} prot_psf_mol1="protein1.psf"; 
 DEFINE>{* segid of molecule 1 *} 
 DEFINE>{===>} prot_segid_mol1="A"; 
 DEFINE>{* fileroot of molecule 1 *} 
 DEFINE>{===>} prot_root_mol1="protein1"; 
 DEFINE>{* Fix Molecule at Origin during it0 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} fix_origin_mol1=false; 
 DEFINE>{* Is molecule 1 DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_mol1=false; 
 DEFINE>{* Is molecule 1 a cyclic peptide? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cyclicpept_mol1=false; 
 DEFINE>{* Is molecule 1 a shape? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} shape_mol1=false; 
 DEFINE>{* Coarse grained molecule? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cg_mol1=false; 
 DEFINE>{* PDB file of molecule 2 *} 
 DEFINE>{===>} prot_coor_mol2="protein2.pdb"; 
 DEFINE>{* PSF file of molecule 2 *} 
 DEFINE>{===>} prot_psf_mol2="protein2.psf"; 
 DEFINE>{* segid of molecule 2 *} 
 DEFINE>{===>} prot_segid_mol2="B"; 
 DEFINE>{* fileroot of molecule 2 *} 
 DEFINE>{===>} prot_root_mol2="protein2"; 
 DEFINE>{* Fix Molecule at Origin during it0 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} fix_origin_mol2=false; 
 DEFINE>{* Is molecule 2 DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_mol2=false; 
 DEFINE>{* Is molecule 2 a cyclic peptide? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cyclicpept_mol2=false; 
 DEFINE>{* Is molecule 2 a shape? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} shape_mol2=false; 
 DEFINE>{* Coarse grained molecule? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cg_mol2=false; 
 DEFINE> 
 DEFINE>{* Remove non-polar hydrogens? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} delenph=true; 
 DEFINE> 
 DEFINE>{* HADDOCK directory *} 
 DEFINE>{*  the absolute path of the HADDOCK program files *} 
 DEFINE>{===>} haddock_dir=/home/enmr/software/haddock2.4; 
 DEFINE> 
 DEFINE>{* Logfile directory *} 
 DEFINE>{* specify a directory for the large CNS log files *} 
 DEFINE>{===>} temptrash_dir=/home/enmr/csb_webserver/data/runs/haddock24/userrun00189263/run1; 
 DEFINE> 
 DEFINE>{==================== histidine patches =====================} 
 DEFINE> 
 DEFINE> 
 DEFINE>{==================== histidine patches =====================} 
 DEFINE>{* Automatically define histidine protonation state based on energetics *} 
 DEFINE>{===>} autohis=false; 
 DEFINE> 
 DEFINE>{* Patch to change doubly protonated HIS to singly protonated histidine (HD1) *} 
 DEFINE>{* just give the residue number of the histidines for the HISD patch, set them to zero if you don't want them *} 
 DEFINE> 
 DEFINE>{* Number of HISD for molecule 1 *} 
 DEFINE>numhisd_1=3; 
 DEFINE>{===>} hisd_1_1=514; 
 DEFINE> 
 DEFINE>{===>} hisd_1_2=615; 
 DEFINE> 
 DEFINE>{===>} hisd_1_3=697; 
 DEFINE> 
 DEFINE>{* Number of HISD for molecule 4 *} 
 DEFINE>numhisd_2=0; 
 DEFINE> 
 DEFINE>{* Patch to change doubly protonated HIS to singly protonated histidine (HE2) *} 
 DEFINE>{* just give the residue number of the histidines for the HISE patch, set them to zero if you don't want them *} 
 DEFINE> 
 DEFINE>{* Number of HISE for molecule 1 *} 
 DEFINE>numhise_1=7; 
 DEFINE>{===>} hise_1_1=449; 
 DEFINE> 
 DEFINE>{===>} hise_1_2=474; 
 DEFINE> 
 DEFINE>{===>} hise_1_3=483; 
 DEFINE> 
 DEFINE>{===>} hise_1_4=498; 
 DEFINE> 
 DEFINE>{===>} hise_1_5=604; 
 DEFINE> 
 DEFINE>{===>} hise_1_6=654; 
 DEFINE> 
 DEFINE>{===>} hise_1_7=695; 
 DEFINE> 
 DEFINE>{* Number of HISE for molecule 8 *} 
 DEFINE>numhise_2=0; 
 DEFINE> 
 DEFINE>{========= Definition of semi-flexible interface ============} 
 DEFINE>{* Define the interface of each molecule.*} 
 DEFINE>{* Side-chains and backbone of these residues will be allowed to move during semi-flexible refinement*} 
 DEFINE>{* Distance cutoff in A for the automatic definition of flexible segments based on intermolecular residues contacts *} 
 DEFINE>{===>} flcut_nb=5.0; 
 DEFINE>{* number of semi-flexible segments for molecule  1 (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_1=-1; 
 DEFINE>{* number of semi-flexible segments for molecule  2 (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_2=-1; 
 DEFINE> 
 DEFINE>{=========== Definition of fully flexible segments ==========} 
 DEFINE>{* Define the fully flexible segment of each molecule.*} 
 DEFINE>{* These segments will be allowed to move at all stages of it1 *} 
 DEFINE> 
 DEFINE> 
 DEFINE>{* Number of fully flexible segments for molecule  1            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_1=0; 
 DEFINE>{* Number of fully flexible segments for molecule  2            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_2=0; 
 DEFINE> 
 DEFINE>{==================== membrane positioning restraints  ==================} 
 DEFINE>{* Do you want to use membrane positioning restraints ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} zres_on=false; 
 DEFINE> 
 DEFINE>{* Number of membrane positioning restrained segments *} 
 DEFINE>{===>} numzres=0; 
 DEFINE> 
 DEFINE>{====================== NCS restraints  =====================} 
 DEFINE>{* Do you want to use NCS restraints? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} ncs_on=false; 
 DEFINE> 
 DEFINE>{* Number of NCS pairs *} 
 DEFINE>{===>} numncs=0; 
 DEFINE> 
 DEFINE>{==================== Symmetry restraints  ==================} 
 DEFINE>{* Do you want to use symmetry restraints ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} sym_on=false; 
 DEFINE> 
 DEFINE>{* Force constant for symmetry restraints ? *} 
 DEFINE>{===>} ksym=10.0; 
 DEFINE>{* Number of C2 symmetry pairs *} 
 DEFINE>{===>} numc2sym=0; 
 DEFINE>{* Number of C3 symmetry triples*} 
 DEFINE>{===>} numc3sym=0; 
 DEFINE>{* Number of S3 symmetry triples*} 
 DEFINE>{===>} nums3sym=0; 
 DEFINE>{* Number of C4 symmetry quadruples *} 
 DEFINE>{===>} numc4sym=0; 
 DEFINE>{* Number of C5 symmetry *} 
 DEFINE>{===>} numc5sym=0; 
 DEFINE> 
 DEFINE>{* Number of c6 symmetry *} 
 DEFINE>{===>} numc6sym=0; 
 DEFINE> 
 DEFINE>{=========================== Distance restraints  ========================} 
 DEFINE>{* Turn on/off and energy constants for distance restraints *} 
 DEFINE>{+ table: rows=3 "distances" "AIR (ambig)" "hbonds" cols=6 "firstIteration" "lastIteration" "hot" "cool1" "cool2" "cool3"+} 
 DEFINE> 
 DEFINE>{===>} unamb_firstit=0; 
 DEFINE>{===>} unamb_lastit=2; 
 DEFINE>{===>} unamb_hot=10.0; 
 DEFINE>{===>} unamb_cool1=10.0; 
 DEFINE>{===>} unamb_cool2=50.0; 
 DEFINE>{===>} unamb_cool3=50.0; 
 DEFINE>{===>} amb_firstit=0; 
 DEFINE>{===>} amb_lastit=2; 
 DEFINE>{===>} amb_hot=10.0; 
 DEFINE>{===>} amb_cool1=10.0; 
 DEFINE>{===>} amb_cool2=50.0; 
 DEFINE>{===>} amb_cool3=50.0; 
 DEFINE>{===>} hbond_firstit=0; 
 DEFINE>{===>} hbond_lastit=2; 
 DEFINE>{===>} hbond_hot=10.0; 
 DEFINE>{===>} hbond_cool1=10.0; 
 DEFINE>{===>} hbond_cool2=50.0; 
 DEFINE>{===>} hbond_cool3=50.0; 
 DEFINE> 
 DEFINE>{* Do you want to randomly exclude a fraction of the ambiguous restraints (AIRs)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} noecv=true; 
 DEFINE> 
 DEFINE>{* Number of partitions for random exclusion (%excluded=100/number of partitions)? *} 
 DEFINE>{===>} ncvpart=2.0000; 
 DEFINE> 
 DEFINE>{* Do you want to use hydrogen bond restraints? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} hbonds_on=false; 
 DEFINE> 
 DEFINE>{* Do you want to define randomly ambiguous interaction restraints from accessible residues? *} 
 DEFINE>{* Only residues in the defined flexible segments will be considered *} 
 DEFINE>{* Note that this option is exclusive with any other distance restraints and only for it0    *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} ranair=false; 
 DEFINE> 
 DEFINE>{* Do you want to define center of mass restraints to enforce contact between the molecules? *} 
 DEFINE>{* Note that these are only active during it0 and it1 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cmrest=true; 
 DEFINE> 
 DEFINE>{* Define tight CM restraints? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cmtight=true; 
 DEFINE> 
 DEFINE>{* Force constant for center of mass restraints *} 
 DEFINE>{===>} kcont=1.0; 
 DEFINE> 
 DEFINE>{* Do you want to define surface contact restraints to enforce contact between the molecules? *} 
 DEFINE>{* Note that these are only active during it0 and it1 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} surfrest=true; 
 DEFINE> 
 DEFINE>{* Force constant for surface contact restraints *} 
 DEFINE>{===>} ksurf=1.0; 
 DEFINE> 
 DEFINE>{ Use automated distance restraints weighting } 
 DEFINE>{ choice: true false } 
 DEFINE>air_scaling=false; 
 DEFINE>{ Define the number of distance restraints for automated weighting } 
 DEFINE>tot_unamb=25; 
 DEFINE>{ Define the number of AIR restraints for automated weighting } 
 DEFINE>tot_amb=0; 
 DEFINE>{ potential shape } 
 DEFINE>mrswi_hot=0.5; 
 DEFINE>mrswi_cool1=0.5; 
 DEFINE>mrswi_cool2=0.5; 
 DEFINE>mrswi_cool3=0.5; 
 DEFINE>rswi_hot=0.5; 
 DEFINE>rswi_cool1=0.5; 
 DEFINE>rswi_cool2=0.5; 
 DEFINE>rswi_cool3=0.5; 
 DEFINE>masy_hot=-1.0; 
 DEFINE>masy_cool1=-1.0; 
 DEFINE>masy_cool2=-0.1; 
 DEFINE>masy_cool3=-0.1; 
 DEFINE>asy_hot=1.0; 
 DEFINE>asy_cool1=1.0; 
 DEFINE>asy_cool2=0.1; 
 DEFINE>asy_cool3=0.1; 
 DEFINE> 
 DEFINE>{=========================== radius of gyration restraint  ============} 
 DEFINE>{* Turn on/off and energy constants for Rg restraints *} 
 DEFINE>{* Do you want to define a radius of gyration restraint (e.g. from SAXS)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rgrest=false; 
 DEFINE> 
 DEFINE> 
 DEFINE>{======================DNA-RNA restraints ============================} 
 DEFINE>{* Use DNA/RNA restraints (dna-rna_restraints.def in data/sequence)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dnarest_on=false; 
 DEFINE> 
 DEFINE>{=========================== dihedrals restraints ====================} 
 DEFINE>{* energy constants *} 
 DEFINE>{+ table: rows=1 "dihedrals" cols=5 "use?" "hot" "cool1" "cool2" "cool3" +} 
 DEFINE> 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dihedrals_on=false; 
 DEFINE>{===>} dihedrals_hot=5.0; 
 DEFINE>{===>} dihedrals_cool1=5.0; 
 DEFINE>{===>} dihedrals_cool2=50.0; 
 DEFINE>{===>} dihedrals_cool3=200.0; 
 DEFINE> 
 DEFINE>{* Automatically define backbone dihedral angle restraints from structure? *} 
 DEFINE>{+ choice: none all alpha alphabeta +} 
 DEFINE>{===>} ssdihed=alphabeta; 
 DEFINE>{===>} error_dih=10; 
 DEFINE> 
 DEFINE>{=========================== residual dipolar couplings ======================} 
 DEFINE> 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=5 "class1" "class2" "class3" "class4" "class5" 
 DEFINE>          cols=25 "type" "firstIt" "lastIt" "Ksani<br>(hot)" "Ksani<br>(cool1)" "Ksani<br>(cool2)" "Ksani<br>(cool3)" "R" "D" 
 DEFINE> "Kvean<br>(ini_bor_hot)" "Kvean<br>(fin_bor_hot)" 
 DEFINE> "Kvean<br>(ini_bor_cool1)" "Kvean<br>(fin_bor_cool1)" 
 DEFINE> "Kvean<br>(ini_bor_cool2)" "Kvean<br>(fin_bor_cool2)" 
 DEFINE> "Kvean<br>(ini_bor_cool3)" "Kvean<br>(fin_bor_cool3)" 
 DEFINE> "Kvean<br>(ini_cen_hot)" "Kvean<br>(fin_cen_hot)" 
 DEFINE> "Kvean<br>(ini_cen_cool1)" "Kvean<br>(fin_cen_cool1)" 
 DEFINE> "Kvean<br>(ini_cen_cool2)" "Kvean<br>(fin_cen_cool2)" 
 DEFINE> "Kvean<br>(ini_cen_cool3)" "Kvean<br>(fin_cen_cool3)"+} 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} numrdc = 0; 
 DEFINE> 
 DEFINE> 
 DEFINE>{=========================== pseudo contact shifts ===========================} 
 DEFINE> 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=10 "class1" "class2" "class3" "class4" "class5" "class6" "class7" "class8" "class9" "class10" 
 DEFINE>          cols=9 "type" "firstIt" "lastIt" "Kpcs<br>(hot)" "Kpcs<br>(cool1)" "Kpcs<br>(cool2)" "Kpcs<br>(cool3)" "R" "D" +} 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} numpcs = 0; 
 DEFINE> 
 DEFINE> 
 DEFINE>{=========================== relaxation data ======================} 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=5 "class1" "class2" "class3" "class4" "class5" 
 DEFINE>          cols=12 "type" "firstIt" "lastIt" "Kdani(hot)" "Kdani(cool1)" "Kdani(cool2)" "Kdani(cool3)" "Correlation time" "D" "R" "H frequency" "N frequency" +} 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} numdani = 0; 
 DEFINE> 
 DEFINE> 
 DEFINE>{========================== Cryo-EM parameters ============================} 
 DEFINE> 
 DEFINE>{* Centroid definitions *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} centroid_rest=false; 
 DEFINE>{===>} centroid_kscale=50; 
 DEFINE> 
 DEFINE> 
 DEFINE>{* Density/XREF restraints *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} em_rest=false; 
 DEFINE>{===>} em_kscale=15000; 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} em_it0=false; 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} em_it1=false; 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} em_itw=false; 
 DEFINE> 
 DEFINE>{* Resolution of data in angstrom *} 
 DEFINE>{===>} em_resolution=None; 
 DEFINE> 
 DEFINE>{* Density parameters *} 
 DEFINE>{* Number of voxels in each dimension *} 
 DEFINE>{===>} nx=32; 
 DEFINE>{===>} ny=32; 
 DEFINE>{===>} nz=32; 
 DEFINE> 
 DEFINE>{* Length of each dimension in angstrom *} 
 DEFINE>{===>} xlength=80.0; 
 DEFINE>{===>} ylength=80.0; 
 DEFINE>{===>} zlength=80.0; 
 DEFINE> 
 DEFINE>{* Cryo-EM scoring weights *} 
 DEFINE>{===>} w_lcc_0=-400.0; 
 DEFINE>{===>} w_lcc_1=-10000.0; 
 DEFINE>{===>} w_lcc_2=-10000.0; 
 DEFINE> 
 DEFINE>{===================== topology and parameter files ======================} 
 DEFINE> 
 DEFINE>{* topology file for molecule  1 *} 
 DEFINE>{===>} prot_top_mol1="protein-allhdg5-4.top"; 
 DEFINE>{* linkage file for molecule  1 *} 
 DEFINE>{===>} prot_link_mol1="protein-allhdg5-4-noter.link"; 
 DEFINE>{* energy parameter file for molecule  1 *} 
 DEFINE>{===>} prot_par_mol1="protein-allhdg5-4.param"; 
 DEFINE>{* topology file for molecule  2 *} 
 DEFINE>{===>} prot_top_mol2="protein-allhdg5-4.top"; 
 DEFINE>{* linkage file for molecule  2 *} 
 DEFINE>{===>} prot_link_mol2="protein-allhdg5-4-noter.link"; 
 DEFINE>{* energy parameter file for molecule  2 *} 
 DEFINE>{===>} prot_par_mol2="protein-allhdg5-4.param"; 
 DEFINE> 
 DEFINE>{* type of non-bonded parameters *} 
 DEFINE>{* specify the type of non-bonded interaction *} 
 DEFINE>{+ choice: "PROLSQ" "PARMALLH6" "PARALLHDG" "OPLSX" +} 
 DEFINE>{===>} par_nonbonded="OPLSX"; 
 DEFINE> 
 DEFINE>{============coarse graining topology and parameter files ==================} 
 DEFINE> 
 DEFINE>{* topology file for molecule  1 *} 
 DEFINE>{===>} prot_cg_top_mol1="protein-CG-Martini-2-2.top"; 
 DEFINE>{* linkage file for molecule  1 *} 
 DEFINE>{===>} prot_cg_link_mol1="protein-CG-Martini-2-2.link"; 
 DEFINE>{* energy parameter file for molecule  1 *} 
 DEFINE>{===>} prot_cg_par_mol1="protein-CG-Martini-2-2.param"; 
 DEFINE>{* topology file for molecule  2 *} 
 DEFINE>{===>} prot_cg_top_mol2="protein-CG-Martini-2-2.top"; 
 DEFINE>{* linkage file for molecule  2 *} 
 DEFINE>{===>} prot_cg_link_mol2="protein-CG-Martini-2-2.link"; 
 DEFINE>{* energy parameter file for molecule  2 *} 
 DEFINE>{===>} prot_cg_par_mol2="protein-CG-Martini-2-2.param"; 
 DEFINE> 
 DEFINE>{===================== energy and interaction parameters ==================} 
 DEFINE> 
 DEFINE>{ Do you want to include dihedral angle energy terms? } 
 DEFINE>{ choice: true false } 
 DEFINE>dihedflag=true; 
 DEFINE> 
 DEFINE>{* Do you want to include the electrostatic energy term for docking? *} 
 DEFINE>{* Note that it will be automatically included in the solvent refinement *} 
 DEFINE> 
 DEFINE>{* Include electrostatic during rigid body docking (it0)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} elecflag_0=true; 
 DEFINE>{* Include electrostatic during semi-flexible SA (it1)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} elecflag_1=true; 
 DEFINE> 
 DEFINE>{* Give the epsilon constant for the electrostatic energy term in it0 *} 
 DEFINE>{* Note that for explicit solvent refinement cdie with epsilon=1 is used *} 
 DEFINE>{===>} epsilon_0=10.0; 
 DEFINE> 
 DEFINE>{* Give the epsilon constant for the electrostatic energy term in it1 *} 
 DEFINE>{* Note that for explicit solvent refinement cdie with epsilon=1 is used *} 
 DEFINE>{===>} epsilon_1=1.0; 
 DEFINE> 
 DEFINE>{* Use constant (cdie) or distance-dependent (rdie) dielectric in it0? *} 
 DEFINE>{+ choice: cdie rdie +} 
 DEFINE>{===>} dielec_0=rdie; 
 DEFINE> 
 DEFINE>{* Use constant (cdie) or distance-dependent (rdie) dielectric in it1? *} 
 DEFINE>{+ choice: cdie rdie +} 
 DEFINE>{===>} dielec_1=rdie; 
 DEFINE> 
 DEFINE>{* Scaling of intermolecular interactions for rigid body EM*} 
 DEFINE>{===>} inter_rigid=1.0; 
 DEFINE> 
 DEFINE>{* Scaling of intermolecular interactions for semi-flexible SA*} 
 DEFINE>{+ table: rows=3 "Rigid body dynamic " "SA with flexible side-chains (cool2)" "SA with flexible backbone and side-chains (cool3)" 
 DEFINE>          cols=2 "Init value" "Final value" +} 
 DEFINE>{===>} init_rigid=0.001; 
 DEFINE>{===>} fin_rigid=0.001; 
 DEFINE>{===>} init_cool2=0.001; 
 DEFINE>{===>} fin_cool2=1.0; 
 DEFINE>{===>} init_cool3=0.05; 
 DEFINE>{===>} fin_cool3=1.0; 
 DEFINE> 
 DEFINE>{* Interaction matrix for non-bonded interactions*} 
 DEFINE>{+ table: rows=6 "Mol 1" "Mol 2" "Mol 3" "Mol 4" "Mol 5" "Mol 6" "Mol 7" "Mol 8" "Mol 9" Mol 10" "Mol 11" Mol 12" "Mol 13" "Mol 14" "Mol 15" "Mol 16" "Mol 17" "Mol 18" "Mol 19" "Mol 20" 
 DEFINE>          cols=6 "Mol 1" "Mol 2" "Mol 3" "Mol 4" "Mol 5" "Mol 6" "Mol 7" "Mol 8" "Mol 9" Mol 10" "Mol 11" Mol 12" "Mol 13" "Mol 14" "Mol 15" "Mol 16" "Mol 17" "Mol 18" "Mol 19" "Mol 20" +} 
 DEFINE>{===>} int_1_1=1.0; 
 DEFINE>{===>} int_1_2=1.0; 
 DEFINE>{===>} int_1_3=1.0; 
 DEFINE>{===>} int_1_4=1.0; 
 DEFINE>{===>} int_1_5=1.0; 
 DEFINE>{===>} int_1_6=1.0; 
 DEFINE>{===>} int_1_7=1.0; 
 DEFINE>{===>} int_1_8=1.0; 
 DEFINE>{===>} int_1_9=1.0; 
 DEFINE>{===>} int_1_10=1.0; 
 DEFINE>{===>} int_1_11=1.0; 
 DEFINE>{===>} int_1_12=1.0; 
 DEFINE>{===>} int_1_13=1.0; 
 DEFINE>{===>} int_1_14=1.0; 
 DEFINE>{===>} int_1_15=1.0; 
 DEFINE>{===>} int_1_16=1.0; 
 DEFINE>{===>} int_1_17=1.0; 
 DEFINE>{===>} int_1_18=1.0; 
 DEFINE>{===>} int_1_19=1.0; 
 DEFINE>{===>} int_1_20=1.0; 
 DEFINE>{===>} int_2_1="N.A."; 
 DEFINE>{===>} int_2_2=1.0; 
 DEFINE>{===>} int_2_3=1.0; 
 DEFINE>{===>} int_2_4=1.0; 
 DEFINE>{===>} int_2_5=1.0; 
 DEFINE>{===>} int_2_6=1.0; 
 DEFINE>{===>} int_2_7=1.0; 
 DEFINE>{===>} int_2_8=1.0; 
 DEFINE>{===>} int_2_9=1.0; 
 DEFINE>{===>} int_2_10=1.0; 
 DEFINE>{===>} int_2_11=1.0; 
 DEFINE>{===>} int_2_12=1.0; 
 DEFINE>{===>} int_2_13=1.0; 
 DEFINE>{===>} int_2_14=1.0; 
 DEFINE>{===>} int_2_15=1.0; 
 DEFINE>{===>} int_2_16=1.0; 
 DEFINE>{===>} int_2_17=1.0; 
 DEFINE>{===>} int_2_18=1.0; 
 DEFINE>{===>} int_2_19=1.0; 
 DEFINE>{===>} int_2_20=1.0; 
 DEFINE>{===>} int_3_1="N.A."; 
 DEFINE>{===>} int_3_2="N.A."; 
 DEFINE>{===>} int_3_3=1.0; 
 DEFINE>{===>} int_3_4=1.0; 
 DEFINE>{===>} int_3_5=1.0; 
 DEFINE>{===>} int_3_6=1.0; 
 DEFINE>{===>} int_3_7=1.0; 
 DEFINE>{===>} int_3_8=1.0; 
 DEFINE>{===>} int_3_9=1.0; 
 DEFINE>{===>} int_3_10=1.0; 
 DEFINE>{===>} int_3_11=1.0; 
 DEFINE>{===>} int_3_12=1.0; 
 DEFINE>{===>} int_3_13=1.0; 
 DEFINE>{===>} int_3_14=1.0; 
 DEFINE>{===>} int_3_15=1.0; 
 DEFINE>{===>} int_3_16=1.0; 
 DEFINE>{===>} int_3_17=1.0; 
 DEFINE>{===>} int_3_18=1.0; 
 DEFINE>{===>} int_3_19=1.0; 
 DEFINE>{===>} int_3_20=1.0; 
 DEFINE>{===>} int_4_1="N.A."; 
 DEFINE>{===>} int_4_2="N.A."; 
 DEFINE>{===>} int_4_3="N.A."; 
 DEFINE>{===>} int_4_4=1.0; 
 DEFINE>{===>} int_4_5=1.0; 
 DEFINE>{===>} int_4_6=1.0; 
 DEFINE>{===>} int_4_7=1.0; 
 DEFINE>{===>} int_4_8=1.0; 
 DEFINE>{===>} int_4_9=1.0; 
 DEFINE>{===>} int_4_10=1.0; 
 DEFINE>{===>} int_4_11=1.0; 
 DEFINE>{===>} int_4_12=1.0; 
 DEFINE>{===>} int_4_13=1.0; 
 DEFINE>{===>} int_4_14=1.0; 
 DEFINE>{===>} int_4_15=1.0; 
 DEFINE>{===>} int_4_16=1.0; 
 DEFINE>{===>} int_4_17=1.0; 
 DEFINE>{===>} int_4_18=1.0; 
 DEFINE>{===>} int_4_19=1.0; 
 DEFINE>{===>} int_4_20=1.0; 
 DEFINE>{===>} int_5_1="N.A."; 
 DEFINE>{===>} int_5_2="N.A."; 
 DEFINE>{===>} int_5_3="N.A."; 
 DEFINE>{===>} int_5_4="N.A."; 
 DEFINE>{===>} int_5_5=1.0; 
 DEFINE>{===>} int_5_6=1.0; 
 DEFINE>{===>} int_5_7=1.0; 
 DEFINE>{===>} int_5_8=1.0; 
 DEFINE>{===>} int_5_9=1.0; 
 DEFINE>{===>} int_5_10=1.0; 
 DEFINE>{===>} int_5_11=1.0; 
 DEFINE>{===>} int_5_12=1.0; 
 DEFINE>{===>} int_5_13=1.0; 
 DEFINE>{===>} int_5_14=1.0; 
 DEFINE>{===>} int_5_15=1.0; 
 DEFINE>{===>} int_5_16=1.0; 
 DEFINE>{===>} int_5_17=1.0; 
 DEFINE>{===>} int_5_18=1.0; 
 DEFINE>{===>} int_5_19=1.0; 
 DEFINE>{===>} int_5_20=1.0; 
 DEFINE>{===>} int_6_1="N.A."; 
 DEFINE>{===>} int_6_2="N.A."; 
 DEFINE>{===>} int_6_3="N.A."; 
 DEFINE>{===>} int_6_4="N.A."; 
 DEFINE>{===>} int_6_5="N.A."; 
 DEFINE>{===>} int_6_6=1.0; 
 DEFINE>{===>} int_6_7=1.0; 
 DEFINE>{===>} int_6_8=1.0; 
 DEFINE>{===>} int_6_9=1.0; 
 DEFINE>{===>} int_6_10=1.0; 
 DEFINE>{===>} int_6_11=1.0; 
 DEFINE>{===>} int_6_12=1.0; 
 DEFINE>{===>} int_6_13=1.0; 
 DEFINE>{===>} int_6_14=1.0; 
 DEFINE>{===>} int_6_15=1.0; 
 DEFINE>{===>} int_6_16=1.0; 
 DEFINE>{===>} int_6_17=1.0; 
 DEFINE>{===>} int_6_18=1.0; 
 DEFINE>{===>} int_6_19=1.0; 
 DEFINE>{===>} int_6_20=1.0; 
 DEFINE>{===>} int_7_1="N.A."; 
 DEFINE>{===>} int_7_2="N.A."; 
 DEFINE>{===>} int_7_3="N.A."; 
 DEFINE>{===>} int_7_4="N.A."; 
 DEFINE>{===>} int_7_5="N.A."; 
 DEFINE>{===>} int_7_6="N.A."; 
 DEFINE>{===>} int_7_7=1.0; 
 DEFINE>{===>} int_7_8=1.0; 
 DEFINE>{===>} int_7_9=1.0; 
 DEFINE>{===>} int_7_10=1.0; 
 DEFINE>{===>} int_7_11=1.0; 
 DEFINE>{===>} int_7_12=1.0; 
 DEFINE>{===>} int_7_13=1.0; 
 DEFINE>{===>} int_7_14=1.0; 
 DEFINE>{===>} int_7_15=1.0; 
 DEFINE>{===>} int_7_16=1.0; 
 DEFINE>{===>} int_7_17=1.0; 
 DEFINE>{===>} int_7_18=1.0; 
 DEFINE>{===>} int_7_19=1.0; 
 DEFINE>{===>} int_7_20=1.0; 
 DEFINE>{===>} int_8_1="N.A."; 
 DEFINE>{===>} int_8_2="N.A."; 
 DEFINE>{===>} int_8_3="N.A."; 
 DEFINE>{===>} int_8_4="N.A."; 
 DEFINE>{===>} int_8_5="N.A."; 
 DEFINE>{===>} int_8_6="N.A."; 
 DEFINE>{===>} int_8_7="N.A."; 
 DEFINE>{===>} int_8_8=1.0; 
 DEFINE>{===>} int_8_9=1.0; 
 DEFINE>{===>} int_8_10=1.0; 
 DEFINE>{===>} int_8_11=1.0; 
 DEFINE>{===>} int_8_12=1.0; 
 DEFINE>{===>} int_8_13=1.0; 
 DEFINE>{===>} int_8_14=1.0; 
 DEFINE>{===>} int_8_15=1.0; 
 DEFINE>{===>} int_8_16=1.0; 
 DEFINE>{===>} int_8_17=1.0; 
 DEFINE>{===>} int_8_18=1.0; 
 DEFINE>{===>} int_8_19=1.0; 
 DEFINE>{===>} int_8_20=1.0; 
 DEFINE>{===>} int_9_1="N.A."; 
 DEFINE>{===>} int_9_2="N.A."; 
 DEFINE>{===>} int_9_3="N.A."; 
 DEFINE>{===>} int_9_4="N.A."; 
 DEFINE>{===>} int_9_5="N.A."; 
 DEFINE>{===>} int_9_6="N.A."; 
 DEFINE>{===>} int_9_7="N.A."; 
 DEFINE>{===>} int_9_8="N.A."; 
 DEFINE>{===>} int_9_9=1.0; 
 DEFINE>{===>} int_9_10=1.0; 
 DEFINE>{===>} int_9_11=1.0; 
 DEFINE>{===>} int_9_12=1.0; 
 DEFINE>{===>} int_9_13=1.0; 
 DEFINE>{===>} int_9_14=1.0; 
 DEFINE>{===>} int_9_15=1.0; 
 DEFINE>{===>} int_9_16=1.0; 
 DEFINE>{===>} int_9_17=1.0; 
 DEFINE>{===>} int_9_18=1.0; 
 DEFINE>{===>} int_9_19=1.0; 
 DEFINE>{===>} int_9_20=1.0; 
 DEFINE>{===>} int_10_1="N.A."; 
 DEFINE>{===>} int_10_2="N.A."; 
 DEFINE>{===>} int_10_3="N.A."; 
 DEFINE>{===>} int_10_4="N.A."; 
 DEFINE>{===>} int_10_5="N.A."; 
 DEFINE>{===>} int_10_6="N.A."; 
 DEFINE>{===>} int_10_7="N.A."; 
 DEFINE>{===>} int_10_8="N.A."; 
 DEFINE>{===>} int_10_9="N.A."; 
 DEFINE>{===>} int_10_10=1.0; 
 DEFINE>{===>} int_10_11=1.0; 
 DEFINE>{===>} int_10_12=1.0; 
 DEFINE>{===>} int_10_13=1.0; 
 DEFINE>{===>} int_10_14=1.0; 
 DEFINE>{===>} int_10_15=1.0; 
 DEFINE>{===>} int_10_16=1.0; 
 DEFINE>{===>} int_10_17=1.0; 
 DEFINE>{===>} int_10_18=1.0; 
 DEFINE>{===>} int_10_19=1.0; 
 DEFINE>{===>} int_10_20=1.0; 
 DEFINE>{===>} int_11_1="N.A."; 
 DEFINE>{===>} int_11_2="N.A."; 
 DEFINE>{===>} int_11_3="N.A."; 
 DEFINE>{===>} int_11_4="N.A."; 
 DEFINE>{===>} int_11_5="N.A."; 
 DEFINE>{===>} int_11_6="N.A."; 
 DEFINE>{===>} int_11_7="N.A."; 
 DEFINE>{===>} int_11_8="N.A."; 
 DEFINE>{===>} int_11_9="N.A."; 
 DEFINE>{===>} int_11_10="N.A."; 
 DEFINE>{===>} int_11_11=1.0; 
 DEFINE>{===>} int_11_12=1.0; 
 DEFINE>{===>} int_11_13=1.0; 
 DEFINE>{===>} int_11_14=1.0; 
 DEFINE>{===>} int_11_15=1.0; 
 DEFINE>{===>} int_11_16=1.0; 
 DEFINE>{===>} int_11_17=1.0; 
 DEFINE>{===>} int_11_18=1.0; 
 DEFINE>{===>} int_11_19=1.0; 
 DEFINE>{===>} int_11_20=1.0; 
 DEFINE>{===>} int_12_1="N.A."; 
 DEFINE>{===>} int_12_2="N.A."; 
 DEFINE>{===>} int_12_3="N.A."; 
 DEFINE>{===>} int_12_4="N.A."; 
 DEFINE>{===>} int_12_5="N.A."; 
 DEFINE>{===>} int_12_6="N.A."; 
 DEFINE>{===>} int_12_7="N.A."; 
 DEFINE>{===>} int_12_8="N.A."; 
 DEFINE>{===>} int_12_9="N.A."; 
 DEFINE>{===>} int_12_10="N.A."; 
 DEFINE>{===>} int_12_11="N.A."; 
 DEFINE>{===>} int_12_12=1.0; 
 DEFINE>{===>} int_12_13=1.0; 
 DEFINE>{===>} int_12_14=1.0; 
 DEFINE>{===>} int_12_15=1.0; 
 DEFINE>{===>} int_12_16=1.0; 
 DEFINE>{===>} int_12_17=1.0; 
 DEFINE>{===>} int_12_18=1.0; 
 DEFINE>{===>} int_12_19=1.0; 
 DEFINE>{===>} int_12_20=1.0; 
 DEFINE>{===>} int_13_1="N.A."; 
 DEFINE>{===>} int_13_2="N.A."; 
 DEFINE>{===>} int_13_3="N.A."; 
 DEFINE>{===>} int_13_4="N.A."; 
 DEFINE>{===>} int_13_5="N.A."; 
 DEFINE>{===>} int_13_6="N.A."; 
 DEFINE>{===>} int_13_7="N.A."; 
 DEFINE>{===>} int_13_8="N.A."; 
 DEFINE>{===>} int_13_9="N.A."; 
 DEFINE>{===>} int_13_10="N.A."; 
 DEFINE>{===>} int_13_11="N.A."; 
 DEFINE>{===>} int_13_12="N.A."; 
 DEFINE>{===>} int_13_13=1.0; 
 DEFINE>{===>} int_13_14=1.0; 
 DEFINE>{===>} int_13_15=1.0; 
 DEFINE>{===>} int_13_16=1.0; 
 DEFINE>{===>} int_13_17=1.0; 
 DEFINE>{===>} int_13_18=1.0; 
 DEFINE>{===>} int_13_19=1.0; 
 DEFINE>{===>} int_13_20=1.0; 
 DEFINE>{===>} int_14_1="N.A."; 
 DEFINE>{===>} int_14_2="N.A."; 
 DEFINE>{===>} int_14_3="N.A."; 
 DEFINE>{===>} int_14_4="N.A."; 
 DEFINE>{===>} int_14_5="N.A."; 
 DEFINE>{===>} int_14_6="N.A."; 
 DEFINE>{===>} int_14_7="N.A."; 
 DEFINE>{===>} int_14_8="N.A."; 
 DEFINE>{===>} int_14_9="N.A."; 
 DEFINE>{===>} int_14_10="N.A."; 
 DEFINE>{===>} int_14_11="N.A."; 
 DEFINE>{===>} int_14_12="N.A."; 
 DEFINE>{===>} int_14_13="N.A."; 
 DEFINE>{===>} int_14_14=1.0; 
 DEFINE>{===>} int_14_15=1.0; 
 DEFINE>{===>} int_14_16=1.0; 
 DEFINE>{===>} int_14_17=1.0; 
 DEFINE>{===>} int_14_18=1.0; 
 DEFINE>{===>} int_14_19=1.0; 
 DEFINE>{===>} int_14_20=1.0; 
 DEFINE>{===>} int_15_1="N.A."; 
 DEFINE>{===>} int_15_2="N.A."; 
 DEFINE>{===>} int_15_3="N.A."; 
 DEFINE>{===>} int_15_4="N.A."; 
 DEFINE>{===>} int_15_5="N.A."; 
 DEFINE>{===>} int_15_6="N.A."; 
 DEFINE>{===>} int_15_7="N.A."; 
 DEFINE>{===>} int_15_8="N.A."; 
 DEFINE>{===>} int_15_9="N.A."; 
 DEFINE>{===>} int_15_10="N.A."; 
 DEFINE>{===>} int_15_11="N.A."; 
 DEFINE>{===>} int_15_12="N.A."; 
 DEFINE>{===>} int_15_13="N.A."; 
 DEFINE>{===>} int_15_14="N.A."; 
 DEFINE>{===>} int_15_15=1.0; 
 DEFINE>{===>} int_15_16=1.0; 
 DEFINE>{===>} int_15_17=1.0; 
 DEFINE>{===>} int_15_18=1.0; 
 DEFINE>{===>} int_15_19=1.0; 
 DEFINE>{===>} int_15_20=1.0; 
 DEFINE>{===>} int_16_1="N.A."; 
 DEFINE>{===>} int_16_2="N.A."; 
 DEFINE>{===>} int_16_3="N.A."; 
 DEFINE>{===>} int_16_4="N.A."; 
 DEFINE>{===>} int_16_5="N.A."; 
 DEFINE>{===>} int_16_6="N.A."; 
 DEFINE>{===>} int_16_7="N.A."; 
 DEFINE>{===>} int_16_8="N.A."; 
 DEFINE>{===>} int_16_9="N.A."; 
 DEFINE>{===>} int_16_10="N.A."; 
 DEFINE>{===>} int_16_11="N.A."; 
 DEFINE>{===>} int_16_12="N.A."; 
 DEFINE>{===>} int_16_13="N.A."; 
 DEFINE>{===>} int_16_14="N.A."; 
 DEFINE>{===>} int_16_15="N.A."; 
 DEFINE>{===>} int_16_16=1.0; 
 DEFINE>{===>} int_16_17=1.0; 
 DEFINE>{===>} int_16_18=1.0; 
 DEFINE>{===>} int_16_19=1.0; 
 DEFINE>{===>} int_16_20=1.0; 
 DEFINE>{===>} int_17_1="N.A."; 
 DEFINE>{===>} int_17_2="N.A."; 
 DEFINE>{===>} int_17_3="N.A."; 
 DEFINE>{===>} int_17_4="N.A."; 
 DEFINE>{===>} int_17_5="N.A."; 
 DEFINE>{===>} int_17_6="N.A."; 
 DEFINE>{===>} int_17_7="N.A."; 
 DEFINE>{===>} int_17_8="N.A."; 
 DEFINE>{===>} int_17_9="N.A."; 
 DEFINE>{===>} int_17_10="N.A."; 
 DEFINE>{===>} int_17_11="N.A."; 
 DEFINE>{===>} int_17_12="N.A."; 
 DEFINE>{===>} int_17_13="N.A."; 
 DEFINE>{===>} int_17_14="N.A."; 
 DEFINE>{===>} int_17_15="N.A."; 
 DEFINE>{===>} int_17_16="N.A."; 
 DEFINE>{===>} int_17_17=1.0; 
 DEFINE>{===>} int_17_18=1.0; 
 DEFINE>{===>} int_17_19=1.0; 
 DEFINE>{===>} int_17_20=1.0; 
 DEFINE>{===>} int_18_1="N.A."; 
 DEFINE>{===>} int_18_2="N.A."; 
 DEFINE>{===>} int_18_3="N.A."; 
 DEFINE>{===>} int_18_4="N.A."; 
 DEFINE>{===>} int_18_5="N.A."; 
 DEFINE>{===>} int_18_6="N.A."; 
 DEFINE>{===>} int_18_7="N.A."; 
 DEFINE>{===>} int_18_8="N.A."; 
 DEFINE>{===>} int_18_9="N.A."; 
 DEFINE>{===>} int_18_10="N.A."; 
 DEFINE>{===>} int_18_11="N.A."; 
 DEFINE>{===>} int_18_12="N.A."; 
 DEFINE>{===>} int_18_13="N.A."; 
 DEFINE>{===>} int_18_14="N.A."; 
 DEFINE>{===>} int_18_15="N.A."; 
 DEFINE>{===>} int_18_16="N.A."; 
 DEFINE>{===>} int_18_17="N.A."; 
 DEFINE>{===>} int_18_18=1.0; 
 DEFINE>{===>} int_18_19=1.0; 
 DEFINE>{===>} int_18_20=1.0; 
 DEFINE>{===>} int_19_1="N.A."; 
 DEFINE>{===>} int_19_2="N.A."; 
 DEFINE>{===>} int_19_3="N.A."; 
 DEFINE>{===>} int_19_4="N.A."; 
 DEFINE>{===>} int_19_5="N.A."; 
 DEFINE>{===>} int_19_6="N.A."; 
 DEFINE>{===>} int_19_7="N.A."; 
 DEFINE>{===>} int_19_8="N.A."; 
 DEFINE>{===>} int_19_9="N.A."; 
 DEFINE>{===>} int_19_10="N.A."; 
 DEFINE>{===>} int_19_11="N.A."; 
 DEFINE>{===>} int_19_12="N.A."; 
 DEFINE>{===>} int_19_13="N.A."; 
 DEFINE>{===>} int_19_14="N.A."; 
 DEFINE>{===>} int_19_15="N.A."; 
 DEFINE>{===>} int_19_16="N.A."; 
 DEFINE>{===>} int_19_17="N.A."; 
 DEFINE>{===>} int_19_18="N.A."; 
 DEFINE>{===>} int_19_19=1.0; 
 DEFINE>{===>} int_19_20=1.0; 
 DEFINE>{===>} int_20_1="N.A."; 
 DEFINE>{===>} int_20_2="N.A."; 
 DEFINE>{===>} int_20_3="N.A."; 
 DEFINE>{===>} int_20_4="N.A."; 
 DEFINE>{===>} int_20_5="N.A."; 
 DEFINE>{===>} int_20_6="N.A."; 
 DEFINE>{===>} int_20_7="N.A."; 
 DEFINE>{===>} int_20_8="N.A."; 
 DEFINE>{===>} int_20_9="N.A."; 
 DEFINE>{===>} int_20_10="N.A."; 
 DEFINE>{===>} int_20_11="N.A."; 
 DEFINE>{===>} int_20_12="N.A."; 
 DEFINE>{===>} int_20_13="N.A."; 
 DEFINE>{===>} int_20_14="N.A."; 
 DEFINE>{===>} int_20_15="N.A."; 
 DEFINE>{===>} int_20_16="N.A."; 
 DEFINE>{===>} int_20_17="N.A."; 
 DEFINE>{===>} int_20_18="N.A."; 
 DEFINE>{===>} int_20_19="N.A."; 
 DEFINE>{===>} int_20_20=1.0; 
 DEFINE> 
 DEFINE>{===================== Number of structures to dock =======================} 
 DEFINE>{* Setting for the rigid-body (it0) and semi-flexible refinement (it1) *} 
 DEFINE> 
 DEFINE>{* number of structures for rigid body docking *} 
 DEFINE>{===>} structures_0=200; 
 DEFINE>       keepstruct_0=&structures_0; 
 DEFINE>{* number of structures for refinement *} 
 DEFINE>{===>} structures_1=200; 
 DEFINE>       keepstruct_1=&structures_1; 
 DEFINE>       keepstruct_2=&structures_1; 
 DEFINE>{* number of structures to be analysed*} 
 DEFINE>{===>} anastruc_1=200; 
 DEFINE>       anastruc_0=&anastruc_1; 
 DEFINE>       anastruc_2=&anastruc_1; 
 DEFINE> 
 DEFINE>{* - *} 
 DEFINE> 
 DEFINE>{* Sampling of symmetry related solutions                       *} 
 DEFINE> 
 DEFINE>{* Sample 180 degrees rotated solutions during rigid body EM?   *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rotate180_it0=false; 
 DEFINE> 
 DEFINE>{* Sample 180 degrees rotated solutions during semi-flexible SA?*} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rotate180_it1=false; 
 DEFINE> 
 DEFINE> 
 DEFINE>{=========================== DOCKING protocol =============================} 
 DEFINE>{* Cross-dock all combinations in the ensembles of starting structures? *} 
 DEFINE>{* Turn off this option if you only want to dock structure 1 of ensemble A *} 
 DEFINE>{*   to structure 1 of ensemble B, structure 2 to structure 2, etc. *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} crossdock=false; 
 DEFINE> 
 DEFINE>{* Randomize starting orientations? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} randorien=false; 
 DEFINE> 
 DEFINE>{* Expand starting orientations? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} expand=false; 
 DEFINE> 
 DEFINE>{* Expansion percentage *} 
 DEFINE>{===>} expansion=0.4; 
 DEFINE> 
 DEFINE>{* Random rotation angle *} 
 DEFINE>{===>} randangle=6; 
 DEFINE> 
 DEFINE>{* Rebuild missing atoms in the context of the complex? (refinement mode) *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rebuildcplx=false; 
 DEFINE> 
 DEFINE>{* Perform initial rigid body minimisation? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rigidmini=false; 
 DEFINE> 
 DEFINE>{* Allow translation in rigid body minimisation? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rigidtrans=false; 
 DEFINE> 
 DEFINE>{* Number of trials for rigid body minimisation? *} 
 DEFINE>{===>} ntrials=5; 
 DEFINE> 
 DEFINE>{* initial seed for random number generator *} 
 DEFINE>{* change to get different initial velocities *} 
 DEFINE>{===>} iniseed=917; 
 DEFINE> 
 DEFINE>{* temperature for rigid body high temperature TAD *} 
 DEFINE>{===>} tadhigh_t=2000; 
 DEFINE> 
 DEFINE>{* initial temperature for rigid body first TAD cooling step *} 
 DEFINE>{===>} tadinit1_t=2000; 
 DEFINE> 
 DEFINE>{* final temperature after first cooling step *} 
 DEFINE>{===>} tadfinal1_t=500; 
 DEFINE> 
 DEFINE>{* initial temperature for second TAD cooling step with flexible side-chain at the inferface *} 
 DEFINE>{===>} tadinit2_t=1000; 
 DEFINE> 
 DEFINE>{* finale temperature after second cooling step *} 
 DEFINE>{===>} tadfinal2_t=50; 
 DEFINE> 
 DEFINE>{* initial temperature for third TAD cooling step with fully flexible interface *} 
 DEFINE>{===>} tadinit3_t=1000; 
 DEFINE> 
 DEFINE>{* finale temperature after third cooling step *} 
 DEFINE>{===>} tadfinal3_t=50; 
 DEFINE> 
 DEFINE>{* time step *} 
 DEFINE>{===>} timestep=0.002; 
 DEFINE>{* factor for timestep in TAD *} 
 DEFINE>{===>} tadfactor=8; 
 DEFINE> 
 DEFINE>{* Number of EM steps for translational minimisation? *} 
 DEFINE>{===>} emstepstrans=1000; 
 DEFINE> 
 DEFINE>{* number of MD steps for rigid body high temperature TAD *} 
 DEFINE>{===>} initiosteps=0; 
 DEFINE> 
 DEFINE>{* number of MD steps during first rigid body cooling stage *} 
 DEFINE>{===>} cool1_steps=0; 
 DEFINE> 
 DEFINE>{* number of MD steps during second cooling stage with flexible side-chains at interface *} 
 DEFINE>{===>} cool2_steps=0; 
 DEFINE> 
 DEFINE>{* number of MD steps during third cooling stage with fully flexible interface *} 
 DEFINE>{===>} cool3_steps=0; 
 DEFINE> 
 DEFINE> 
 DEFINE>{======================= Solvated rigid body docking=======================} 
 DEFINE>{* perform solvated docking ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} waterdock=false; 
 DEFINE> 
 DEFINE>{* which method to use for solvating? *} 
 DEFINE>{* db: database-based (recommended), restraints: for restrained solvating to amino-acid most often forming 
 DEFINE>water mediated contacts and blank (""): for uniform waterlayer *} 
 DEFINE>{+ choice: "db" "restraints" "" +} 
 DEFINE>{===>} solvate_method="db"; 
 DEFINE> 
 DEFINE>{* which propensity database to use? *} 
 DEFINE>{* statistical: based on an analysis of water-mediated contacts in the PDB, kyte-doolittle: based on the Kyte-Doolittle hydrophobicity scalte *} 
 DEFINE>{+ choice: "statistical" "kytedoolittle" +} 
 DEFINE>{===>} db_method="kytedoolittle"; 
 DEFINE> 
 DEFINE>{* initial cutoff for restraints solvating method *} 
 DEFINE>{* all waters further away from a highly occuring water solvated residue will be removed in the generation 
 DEFINE>of the initial solvation shell *} 
 DEFINE>{===>} water_restraint_initial=5.0; 
 DEFINE> 
 DEFINE>{* cutoff for restraints solvating method *} 
 DEFINE>{* upper distance limit for defining distance restraints between water and amino-acids often found to be 
 DEFINE>involved in water-mediated contacts *} 
 DEFINE>{===>} water_restraint_cutoff=5.0; 
 DEFINE> 
 DEFINE>{* force constant for restrainted solvating method *} 
 DEFINE>{===>} water_restraint_scale=25.0; 
 DEFINE> 
 DEFINE>{* fraction of water to keep *} 
 DEFINE>{* this is the fraction of all interface water after the initial rigid body docking that will be kept 
 DEFINE>(note that more waters might be removed if the interaction energy is unfavorable  *} 
 DEFINE>{===>} water_tokeep=0.50; 
 DEFINE> 
 DEFINE>{* fraction of water around DNA to keep *} 
 DEFINE>{* this is the fraction of interface water involving DNA phoshpates after the initial rigid body docking that will be kept 
 DEFINE>(note that more waters might be removed if the interaction energy is unfavorable  *} 
 DEFINE>{===>} dnap_water_tokeep=0.75; 
 DEFINE> 
 DEFINE>{* random fraction to be added to the fraction of water to keep *} 
 DEFINE>{===>} water_randfrac=0.0; 
 DEFINE> 
 DEFINE>{* water-protein surface-cutoff *} 
 DEFINE>{* waters further away than this cutoff distance from any component of the complex will be removed *} 
 DEFINE>{===>} water_surfcutoff=8.0; 
 DEFINE> 
 DEFINE>{* do some water analysis *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} water_analysis=false; 
 DEFINE> 
 DEFINE>{* allows translation of water molecules during rigid-body docking, true or false: *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} transwater=true; 
 DEFINE> 
 DEFINE>{* number of different initial solvation shells to generate *} 
 DEFINE>{===>} waterensemble=1; 
 DEFINE> 
 DEFINE> 
 DEFINE>{==================== final explicit solvent refinement  ==================} 
 DEFINE>{* Do you want to refine your docking models in explicit solvent? *} 
 DEFINE>{+ choice: "yes" "no" +} 
 DEFINE>{===>} firstwater="yes"; 
 DEFINE> 
 DEFINE>{* Build explicit solvent shell? (Can be turned off the large molecules or when morphing CG to AA models) *} 
 DEFINE>{* Only EM will then be performed                                                                         *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} solvshell=true; 
 DEFINE> 
 DEFINE>{* Which solvent do you want to use? *} 
 DEFINE>{+ choice: "water" "dmso" +} 
 DEFINE>{===>} solvent="water"; 
 DEFINE> 
 DEFINE>{* number of structures for the explicit solvent refinement *} 
 DEFINE>{* the n best structures will be refined                    *} 
 DEFINE>{===>} waterrefine=200; 
 DEFINE>       structures_2=&waterrefine; 
 DEFINE> 
 DEFINE>{* number of steps for heating phase (100, 200, 300K)?      *} 
 DEFINE>{===>} waterheatsteps=100; 
 DEFINE> 
 DEFINE>{* number of steps for 300K sampling phase?                 *} 
 DEFINE>{===>} watersteps=1250; 
 DEFINE> 
 DEFINE>{* number of steps for cooling phase (300, 200, 100K)?      *} 
 DEFINE>{===>} watercoolsteps=500; 
 DEFINE> 
 DEFINE>{* write additional PDB files including solvent ?           *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} keepwater=false; 
 DEFINE> 
 DEFINE>{================================ Scoring =================================} 
 DEFINE>{* Settings for the scoring of the docking solutions *} 
 DEFINE> 
 DEFINE>{* Define the weights for the various terms for the sorting of structures (scoring) *} 
 DEFINE>{+ table: rows=14 "Evdw" "Eelec" "Eair" "Erg" "Esani" "Exrdc" "Expcs" "Edani" "Evean" "Ecdih" "Esym" "BSA" "dEint" "Edesolv" 
 DEFINE>          cols=3 "Rigid body EM" "semi-flexible SA" "Water refinement" +} 
 DEFINE>{===>} w_vdw_0=0.01; 
 DEFINE>{===>} w_vdw_1=1.0; 
 DEFINE>{===>} w_vdw_2=1.0; 
 DEFINE>{===>} w_elec_0=1.0; 
 DEFINE>{===>} w_elec_1=1.0; 
 DEFINE>{===>} w_elec_2=0.2; 
 DEFINE>{===>} w_dist_0=0.01; 
 DEFINE>{===>} w_dist_1=0.1; 
 DEFINE>{===>} w_dist_2=0.1; 
 DEFINE>{===>} w_rg_0=0.1; 
 DEFINE>{===>} w_rg_1=1.0; 
 DEFINE>{===>} w_rg_2=1.0; 
 DEFINE>{===>} w_sani_0=0.1; 
 DEFINE>{===>} w_sani_1=0.1; 
 DEFINE>{===>} w_sani_2=0.1; 
 DEFINE>{===>} w_xrdc_0=0.1; 
 DEFINE>{===>} w_xrdc_1=0.1; 
 DEFINE>{===>} w_xrdc_2=0.1; 
 DEFINE>{===>} w_xpcs_0=0.1; 
 DEFINE>{===>} w_xpcs_1=0.1; 
 DEFINE>{===>} w_xpcs_2=0.1; 
 DEFINE>{===>} w_dani_0=0.01; 
 DEFINE>{===>} w_dani_1=0.1; 
 DEFINE>{===>} w_dani_2=0.1; 
 DEFINE>{===>} w_vean_0=0.1; 
 DEFINE>{===>} w_vean_1=0.1; 
 DEFINE>{===>} w_vean_2=0.1; 
 DEFINE>{===>} w_cdih_0=0.0; 
 DEFINE>{===>} w_cdih_1=0.0; 
 DEFINE>{===>} w_cdih_2=0.0; 
 DEFINE>{===>} w_sym_0=0.1; 
 DEFINE>{===>} w_sym_1=0.1; 
 DEFINE>{===>} w_sym_2=0.1; 
 DEFINE>{===>} w_zres_0=0.1; 
 DEFINE>{===>} w_zres_1=0.1; 
 DEFINE>{===>} w_zres_2=0.1; 
 DEFINE>{===>} w_bsa_0=-0.01; 
 DEFINE>{===>} w_bsa_1=-0.01; 
 DEFINE>{===>} w_bsa_2=0.0; 
 DEFINE>{===>} w_deint_0=0.0; 
 DEFINE>{===>} w_deint_1=0.0; 
 DEFINE>{===>} w_deint_2=0.0; 
 DEFINE>{===>} w_desolv_0=1.0; 
 DEFINE>{===>} w_desolv_1=1.0; 
 DEFINE>{===>} w_desolv_2=1.0; 
 DEFINE> 
 DEFINE>{* It is possible to skip structures in the selection of structure in it0 *} 
 DEFINE>{* Give for this the number of structures to skip: *} 
 DEFINE>{===>} skip_struc=0; 
 DEFINE> 
 DEFINE>{======================= analysis and clustering ==========================} 
 DEFINE>{* Cutoff distance (proton-acceptor) to define an hydrogen bond? *} 
 DEFINE>{===>} dist_hb=2.5; 
 DEFINE> 
 DEFINE>{* Cutoff distance (carbon-carbon) to define an hydrophobic contact? *} 
 DEFINE>{===>} dist_nb=3.9; 
 DEFINE> 
 DEFINE>{* Clustering method (RMSD or Fraction of Common Contacts (FCC)) *} 
 DEFINE>{+ choice: "RMSD" "FCC" +} 
 DEFINE>{===>} clust_meth="RMSD"; 
 DEFINE> 
 DEFINE>{* RMSD cutoff for clustering? (Recommended values: RMSD 7.5, FCC 0.75) *} 
 DEFINE>{===>} clust_cutoff=5.00; 
 DEFINE> 
 DEFINE>{* Minimum cluster size? *} 
 DEFINE>{===>} clust_size=4; 
 DEFINE> 
 DEFINE>{* Chain-Agnostic Algorithm (used for FCC clustering in symmetrical complexes) *} 
 DEFINE>{+ choice: "true" "false" +} 
 DEFINE>{===>} fcc_ignc=false; 
 DEFINE> 
 DEFINE>{* Full or limited analysis of results? *} 
 DEFINE>{+ choice: "full" "cluster" "none" +} 
 DEFINE>{===>} runana=full; 
 DEFINE> 
 DEFINE> 
 DEFINE>{======================= final clean-up ===================================} 
 DEFINE>{* Clean up the run directory after completion (only files for struct #1 are kept) ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cleanup=true; 
 DEFINE> 
 DEFINE>{============================ parallel jobs ===============================} 
 DEFINE>{* How many nodes do you want to use in parallel? *} 
 DEFINE>{* leave unused fields blank, make sure that the queues are actually running *} 
 DEFINE>{+ table: rows=10 "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" 
 DEFINE> cols=3 "queue command" "cns executable" "number of jobs" +} 
 DEFINE> 
 DEFINE>{===>} queue_1="/home/diracegi/grid/diracsubmit-haddock2.4"; 
 DEFINE>{===>} cns_exe_1="/home/enmr/software/cns/cns_solve_1.31-UU/intel-x86_64bit-linux/bin/cns"; 
 DEFINE>{===>} cpunumber_1=50000; 
 DEFINE> 
 DEFINE> 
 DEFINE>{===========================================================================} 
 DEFINE>{        things below this line do not normally need to be changed          } 
 DEFINE>{===========================================================================} 
 DEFINE> 
 DEFINE>) {- end block parameter definition -} 
 CNSsolve> 
 CNSsolve>!for global parameters (local variables (suffix ) => global variables): 
 CNSsolve>evaluate (&saprotocol.crossdock=&crossdock) 
 EVALUATE: symbol $_1_SAPROTOCOL.CROSSDOCK set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.randorien=&randorien) 
 EVALUATE: symbol $_1_SAPROTOCOL.RANDORIEN set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rebuildcplx=&rebuildcplx) 
 EVALUATE: symbol $_1_SAPROTOCOL.REBUILDCPLX set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rigidmini=&rigidmini) 
 EVALUATE: symbol $_1_SAPROTOCOL.RIGIDMINI set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rigidtrans=&rigidtrans) 
 EVALUATE: symbol $_1_SAPROTOCOL.RIGIDTRANS set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.expand=&expand) 
 EVALUATE: symbol $_1_SAPROTOCOL.EXPAND set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.expansion=&expansion) 
 EVALUATE: symbol $_1_SAPROTOCOL.EXPANSION set to   0.400000     (real)
 CNSsolve>evaluate (&saprotocol.randangle=&randangle) 
 EVALUATE: symbol $_1_SAPROTOCOL.RANDANGLE set to    6.00000     (real)
 CNSsolve> 
 CNSsolve>if (&saprotocol.expand eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.randorien=false) 
 CNSsolve>  evaluate (&saprotocol.rigidmini=false) 
 CNSsolve>end if 
 CNSsolve>evaluate (&saprotocol.ntrials=&ntrials) 
 EVALUATE: symbol $_1_SAPROTOCOL.NTRIALS set to    5.00000     (real)
 CNSsolve>evaluate (&saprotocol.iniseed=&iniseed) 
 EVALUATE: symbol $_1_SAPROTOCOL.INISEED set to    917.000     (real)
 CNSsolve>evaluate (&saprotocol.tadhigh_t=&tadhigh_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.TADHIGH_T set to    2000.00     (real)
 CNSsolve>evaluate (&saprotocol.t1_init=&tadinit1_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T1_INIT set to    2000.00     (real)
 CNSsolve>evaluate (&saprotocol.t2_init=&tadinit2_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T2_INIT set to    1000.00     (real)
 CNSsolve>evaluate (&saprotocol.t3_init=&tadinit3_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T3_INIT set to    1000.00     (real)
 CNSsolve>evaluate (&saprotocol.t1_final=&tadfinal1_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T1_FINAL set to    500.000     (real)
 CNSsolve>evaluate (&saprotocol.t2_final=&tadfinal2_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T2_FINAL set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.t3_final=&tadfinal3_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T3_FINAL set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.inter_rigid=&inter_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_RIGID set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.inter_init_rigid=&init_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_RIGID set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_rigid=&fin_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_RIGID set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_init_cool2=&init_cool2) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_COOL2 set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_cool2=&fin_cool2) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.inter_init_cool3=&init_cool3) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_COOL3 set to   0.500000E-01 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_cool3=&fin_cool3) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.rotate180_it0=&rotate180_it0) 
 EVALUATE: symbol $_1_SAPROTOCOL.ROTATE180_IT0 set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rotate180_it1=&rotate180_it1) 
 EVALUATE: symbol $_1_SAPROTOCOL.ROTATE180_IT1 set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.tempstep=50) 
 EVALUATE: symbol $_1_SAPROTOCOL.TEMPSTEP set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.timestep=&timestep) 
 EVALUATE: symbol $_1_SAPROTOCOL.TIMESTEP set to   0.200000E-02 (real)
 CNSsolve>evaluate (&saprotocol.tadfactor=&tadfactor) 
 EVALUATE: symbol $_1_SAPROTOCOL.TADFACTOR set to    8.00000     (real)
 CNSsolve>evaluate (&saprotocol.emstepstrans=&emstepstrans) 
 EVALUATE: symbol $_1_SAPROTOCOL.EMSTEPSTRANS set to    1000.00     (real)
 CNSsolve>evaluate (&saprotocol.initiosteps=&initiosteps) 
 EVALUATE: symbol $_1_SAPROTOCOL.INITIOSTEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool1_steps=&cool1_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL1_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool2_steps=&cool2_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL2_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool3_steps=&cool3_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL3_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.fbeta=100) 
 EVALUATE: symbol $_1_SAPROTOCOL.FBETA set to    100.000     (real)
 CNSsolve>evaluate (&saprotocol.mass=100) 
 EVALUATE: symbol $_1_SAPROTOCOL.MASS set to    100.000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&filenames.fileroot=&fileroot) 
 EVALUATE: symbol $_1_FILENAMES.FILEROOT set to "complex" (string)
 CNSsolve>evaluate (&filenames.template=&fileroot + "_1.pdb") 
 EVALUATE: symbol $_1_FILENAMES.TEMPLATE set to "complex_1.pdb" (string)
 CNSsolve> 
 CNSsolve>evaluate (&iterations.ini_count    =1) 
 EVALUATE: symbol $_1_ITERATIONS.INI_COUNT set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.structures   =&structures_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.STRUCTURES set to    200.000     (real)
 CNSsolve>evaluate (&iterations.keepstruct   =&keepstruct_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.KEEPSTRUCT set to    200.000     (real)
 CNSsolve>evaluate (&iterations.w_vdw        =&w_vdw_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_VDW set to   0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_elec       =&w_elec_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_ELEC set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.w_dist       =&w_dist_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DIST set to   0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_rg         =&w_rg_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_RG set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_sani       =&w_sani_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_SANI set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_xrdc       =&w_xrdc_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_XRDC set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_xpcs       =&w_xpcs_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_XPCS set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_dani       =&w_dani_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DANI set to   0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_vean       =&w_vean_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_VEAN set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_cdih       =&w_cdih_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_CDIH set to    0.00000     (real)
 CNSsolve>evaluate (&iterations.w_sym        =&w_sym_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_SYM set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_zres       =&w_zres_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_ZRES set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_bsa        =&w_bsa_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_BSA set to  -0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_deint      =&w_deint_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DEINT set to    0.00000     (real)
 CNSsolve>evaluate (&iterations.w_desolv     =&w_desolv_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DESOLV set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.anastruc     =&anastruc_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.ANASTRUC set to    200.000     (real)
 CNSsolve>evaluate (&iterations.w_lcc        = &w_lcc_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_LCC set to   -400.000     (real)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate (&data.ncomponents=&ncomponents) 
 EVALUATE: symbol $_1_DATA.NCOMPONENTS set to    2.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate ($nmol=1) 
 EVALUATE: symbol $NMOL set to    1.00000     (real)
 CNSsolve>while ($nmol <= &data.ncomponents) loop mol 
 NEXTCD: condition evaluated as true
 CNSsolve> 
 CNSsolve>  !aa topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_top_$nmol=&prot_top_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_1 set to "protein-allhdg5-4.top" (string)
 CNSsolve>  evaluate (&toppar.prot_link_$nmol=&prot_link_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_1 set to "protein-allhdg5-4-noter.link" (string)
 CNSsolve>  evaluate (&toppar.prot_par_$nmol=&prot_par_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_1 set to "protein-allhdg5-4.param" (string)
 CNSsolve> 
 CNSsolve>  !coarse grained topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_cg_top_$nmol=&prot_cg_top_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_TOP_1 set to "protein-CG-Martini-2-2.top" (string)
 CNSsolve>  evaluate (&toppar.prot_cg_link_$nmol=&prot_cg_link_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_LINK_1 set to "protein-CG-Martini-2-2.link" (string)
 CNSsolve>  evaluate (&toppar.prot_cg_par_$nmol=&prot_cg_par_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_PAR_1 set to "protein-CG-Martini-2-2.param" (string)
 CNSsolve> 
 CNSsolve>  !molecule related (coordinate files, rootname, fix, type, coarse grained, segid) 
 CNSsolve>  evaluate (&toppar.prot_coor_$nmol=&prot_coor_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_1 set to "protein1.pdb" (string)
 CNSsolve>  evaluate (&toppar.prot_root_$nmol=&prot_root_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_1 set to "protein1" (string)
 CNSsolve>  evaluate (&toppar.fix_origin_$nmol=&fix_origin_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.FIX_ORIGIN_1 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.dna_$nmol=&dna_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.DNA_1 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.cyclicpept_$nmol=&cyclicpept_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.CYCLICPEPT_1 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.shape_$nmol=&shape_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.SHAPE_1 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.cg_$nmol=&cg_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.CG_1 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.prot_segid_$nmol=&prot_segid_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_1 set to "A" (string)
 CNSsolve> 
 CNSsolve>  !semi flexible segments 
 CNSsolve>  evaluate (&toppar.nseg_$nmol=&nseg_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_1 set to   -1.00000     (real)
 CNSsolve>  evaluate ($nseg = 1) 
 EVALUATE: symbol $NSEG set to    1.00000     (real)
 CNSsolve>  while ($nseg <= &toppar.nseg_$nmol) loop seg 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.start_seg_$nmol_$nseg=&start_seg_$nmol_$nseg) 
 CNSsolve>    evaluate (&toppar.end_seg_$nmol_$nseg=&end_seg_$nmol_$nseg) 
 CNSsolve>    evaluate ($nseg = $nseg + 1) 
 CNSsolve>  end loop seg 
 CNSsolve> 
 CNSsolve>  !fully flexible segments 
 CNSsolve>  evaluate (&toppar.nfle_$nmol=&nfle_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_1 set to    0.00000     (real)
 CNSsolve>  evaluate ($nfle = 1) 
 EVALUATE: symbol $NFLE set to    1.00000     (real)
 CNSsolve>  while ($nfle <= &toppar.nfle_$nmol) loop fle 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.start_fle_$nmol_$nfle=&start_fle_$nmol_$nfle) 
 CNSsolve>    evaluate (&toppar.end_fle_$nmol_$nfle=&end_fle_$nmol_$nfle) 
 CNSsolve>    evaluate ($nfle = $nfle + 1) 
 CNSsolve>  end loop fle 
 CNSsolve> 
 CNSsolve>  !histidine patches 
 CNSsolve>  evaluate (&toppar.autohis=&autohis) 
 EVALUATE: symbol $_1_TOPPAR.AUTOHIS set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.nhisd_$nmol=&numhisd_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NHISD_1 set to    3.00000     (real)
 CNSsolve>  evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_1 set to    514.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    2.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_2 set to    615.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    3.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_3 set to    697.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    4.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate (&toppar.nhise_$nmol=&numhise_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NHISE_1 set to    7.00000     (real)
 CNSsolve>  evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_1 set to    449.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    2.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_2 set to    474.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    3.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_3 set to    483.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    4.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_4 set to    498.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    5.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_5 set to    604.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    6.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_6 set to    654.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    7.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_7 set to    695.000     (real)
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    8.00000     (real)
 CNSsolve>  end loop hisd 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate ($nmol = $nmol + 1) 
 EVALUATE: symbol $NMOL set to    2.00000     (real)
 CNSsolve> 
 CNSsolve>end loop mol 
 CNSsolve>while ($nmol <= &data.ncomponents) loop mol 
 NEXTCD: condition evaluated as true
 CNSsolve> 
 CNSsolve>  !aa topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_top_$nmol=&prot_top_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_2 set to "protein-allhdg5-4.top" (string)
 CNSsolve>  evaluate (&toppar.prot_link_$nmol=&prot_link_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_2 set to "protein-allhdg5-4-noter.link" (string)
 CNSsolve>  evaluate (&toppar.prot_par_$nmol=&prot_par_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_2 set to "protein-allhdg5-4.param" (string)
 CNSsolve> 
 CNSsolve>  !coarse grained topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_cg_top_$nmol=&prot_cg_top_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_TOP_2 set to "protein-CG-Martini-2-2.top" (string)
 CNSsolve>  evaluate (&toppar.prot_cg_link_$nmol=&prot_cg_link_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_LINK_2 set to "protein-CG-Martini-2-2.link" (string)
 CNSsolve>  evaluate (&toppar.prot_cg_par_$nmol=&prot_cg_par_mol$nmol ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_CG_PAR_2 set to "protein-CG-Martini-2-2.param" (string)
 CNSsolve> 
 CNSsolve>  !molecule related (coordinate files, rootname, fix, type, coarse grained, segid) 
 CNSsolve>  evaluate (&toppar.prot_coor_$nmol=&prot_coor_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_2 set to "protein2.pdb" (string)
 CNSsolve>  evaluate (&toppar.prot_root_$nmol=&prot_root_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_2 set to "protein2" (string)
 CNSsolve>  evaluate (&toppar.fix_origin_$nmol=&fix_origin_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.FIX_ORIGIN_2 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.dna_$nmol=&dna_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.DNA_2 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.cyclicpept_$nmol=&cyclicpept_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.CYCLICPEPT_2 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.shape_$nmol=&shape_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.SHAPE_2 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.cg_$nmol=&cg_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.CG_2 set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.prot_segid_$nmol=&prot_segid_mol$nmol) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_2 set to "B" (string)
 CNSsolve> 
 CNSsolve>  !semi flexible segments 
 CNSsolve>  evaluate (&toppar.nseg_$nmol=&nseg_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_2 set to   -1.00000     (real)
 CNSsolve>  evaluate ($nseg = 1) 
 EVALUATE: symbol $NSEG set to    1.00000     (real)
 CNSsolve>  while ($nseg <= &toppar.nseg_$nmol) loop seg 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.start_seg_$nmol_$nseg=&start_seg_$nmol_$nseg) 
 CNSsolve>    evaluate (&toppar.end_seg_$nmol_$nseg=&end_seg_$nmol_$nseg) 
 CNSsolve>    evaluate ($nseg = $nseg + 1) 
 CNSsolve>  end loop seg 
 CNSsolve> 
 CNSsolve>  !fully flexible segments 
 CNSsolve>  evaluate (&toppar.nfle_$nmol=&nfle_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_2 set to    0.00000     (real)
 CNSsolve>  evaluate ($nfle = 1) 
 EVALUATE: symbol $NFLE set to    1.00000     (real)
 CNSsolve>  while ($nfle <= &toppar.nfle_$nmol) loop fle 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.start_fle_$nmol_$nfle=&start_fle_$nmol_$nfle) 
 CNSsolve>    evaluate (&toppar.end_fle_$nmol_$nfle=&end_fle_$nmol_$nfle) 
 CNSsolve>    evaluate ($nfle = $nfle + 1) 
 CNSsolve>  end loop fle 
 CNSsolve> 
 CNSsolve>  !histidine patches 
 CNSsolve>  evaluate (&toppar.autohis=&autohis) 
 EVALUATE: symbol $_1_TOPPAR.AUTOHIS set to FALSE (logical)
 CNSsolve>  evaluate (&toppar.nhisd_$nmol=&numhisd_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NHISD_2 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate (&toppar.nhise_$nmol=&numhise_$nmol) 
 EVALUATE: symbol $_1_TOPPAR.NHISE_2 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate ($nmol = $nmol + 1) 
 EVALUATE: symbol $NMOL set to    3.00000     (real)
 CNSsolve> 
 CNSsolve>end loop mol 
 CNSsolve>while ($nmol <= &data.ncomponents) loop mol 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>  !aa topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_top_$nmol=&prot_top_mol$nmol ) 
 CNSsolve>  evaluate (&toppar.prot_link_$nmol=&prot_link_mol$nmol ) 
 CNSsolve>  evaluate (&toppar.prot_par_$nmol=&prot_par_mol$nmol ) 
 CNSsolve> 
 CNSsolve>  !coarse grained topology, linkage and parameters files 
 CNSsolve>  evaluate (&toppar.prot_cg_top_$nmol=&prot_cg_top_mol$nmol ) 
 CNSsolve>  evaluate (&toppar.prot_cg_link_$nmol=&prot_cg_link_mol$nmol ) 
 CNSsolve>  evaluate (&toppar.prot_cg_par_$nmol=&prot_cg_par_mol$nmol ) 
 CNSsolve> 
 CNSsolve>  !molecule related (coordinate files, rootname, fix, type, coarse grained, segid) 
 CNSsolve>  evaluate (&toppar.prot_coor_$nmol=&prot_coor_mol$nmol) 
 CNSsolve>  evaluate (&toppar.prot_root_$nmol=&prot_root_mol$nmol) 
 CNSsolve>  evaluate (&toppar.fix_origin_$nmol=&fix_origin_mol$nmol) 
 CNSsolve>  evaluate (&toppar.dna_$nmol=&dna_mol$nmol) 
 CNSsolve>  evaluate (&toppar.cyclicpept_$nmol=&cyclicpept_mol$nmol) 
 CNSsolve>  evaluate (&toppar.shape_$nmol=&shape_mol$nmol) 
 CNSsolve>  evaluate (&toppar.cg_$nmol=&cg_mol$nmol) 
 CNSsolve>  evaluate (&toppar.prot_segid_$nmol=&prot_segid_mol$nmol) 
 CNSsolve> 
 CNSsolve>  !semi flexible segments 
 CNSsolve>  evaluate (&toppar.nseg_$nmol=&nseg_$nmol) 
 CNSsolve>  evaluate ($nseg = 1) 
 CNSsolve>  while ($nseg <= &toppar.nseg_$nmol) loop seg 
 CNSsolve>    evaluate (&toppar.start_seg_$nmol_$nseg=&start_seg_$nmol_$nseg) 
 CNSsolve>    evaluate (&toppar.end_seg_$nmol_$nseg=&end_seg_$nmol_$nseg) 
 CNSsolve>    evaluate ($nseg = $nseg + 1) 
 CNSsolve>  end loop seg 
 CNSsolve> 
 CNSsolve>  !fully flexible segments 
 CNSsolve>  evaluate (&toppar.nfle_$nmol=&nfle_$nmol) 
 CNSsolve>  evaluate ($nfle = 1) 
 CNSsolve>  while ($nfle <= &toppar.nfle_$nmol) loop fle 
 CNSsolve>    evaluate (&toppar.start_fle_$nmol_$nfle=&start_fle_$nmol_$nfle) 
 CNSsolve>    evaluate (&toppar.end_fle_$nmol_$nfle=&end_fle_$nmol_$nfle) 
 CNSsolve>    evaluate ($nfle = $nfle + 1) 
 CNSsolve>  end loop fle 
 CNSsolve> 
 CNSsolve>  !histidine patches 
 CNSsolve>  evaluate (&toppar.autohis=&autohis) 
 CNSsolve>  evaluate (&toppar.nhisd_$nmol=&numhisd_$nmol) 
 CNSsolve>  evaluate ($ncc=1) 
 CNSsolve>  while ($ncc <= &toppar.nhisd_$nmol) loop hisd 
 CNSsolve>    evaluate (&toppar.hisd_resid_$nmol_$ncc=&hisd_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate (&toppar.nhise_$nmol=&numhise_$nmol) 
 CNSsolve>  evaluate ($ncc=1) 
 CNSsolve>  while ($ncc <= &toppar.nhise_$nmol) loop hisd 
 CNSsolve>    evaluate (&toppar.hise_resid_$nmol_$ncc=&hise_$nmol_$ncc) 
 CNSsolve>    evaluate ($ncc = $ncc + 1) 
 CNSsolve>  end loop hisd 
 CNSsolve> 
 CNSsolve>  evaluate ($nmol = $nmol + 1) 
 CNSsolve> 
 CNSsolve>end loop mol 
 CNSsolve> 
 CNSsolve>! non-bonded parameter set to use 
 CNSsolve>evaluate (&toppar.par_nonbonded=&par_nonbonded) 
 EVALUATE: symbol $_1_TOPPAR.PAR_NONBONDED set to "OPLSX" (string)
 CNSsolve> 
 CNSsolve>! z-restraining 
 CNSsolve>evaluate (&Data.flags.zres =  &zres_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.ZRES set to FALSE (logical)
 CNSsolve>evaluate (&data.numzres=&numzres) 
 EVALUATE: symbol $_1_DATA.NUMZRES set to    0.00000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numzres) loop zres 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.zres_sta_$ncc=&zres_sta_$ncc) 
 CNSsolve>  evaluate (&toppar.zres_end_$ncc=&zres_end_$ncc) 
 CNSsolve>  evaluate (&toppar.zres_seg_$ncc=&zres_seg_$ncc) 
 CNSsolve>  evaluate (&toppar.zres_type_$ncc=&zres_type_$ncc) 
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 CNSsolve>end loop zres 
 CNSsolve> 
 CNSsolve>! NCS restraints 
 CNSsolve>evaluate (&data.kncs=&kncs) 
 Assuming literal string "&KNCS"
 EVALUATE: symbol $_1_DATA.KNCS set to "&KNCS" (string)
 CNSsolve>evaluate (&Data.flags.ncs  =  &ncs_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.NCS set to FALSE (logical)
 CNSsolve>evaluate (&data.numncs=&numncs) 
 EVALUATE: symbol $_1_DATA.NUMNCS set to    0.00000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numncs) loop ncs 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.ncs_sta1_$ncc=&ncs_sta1_$ncc) 
 CNSsolve>  evaluate (&toppar.ncs_end1_$ncc=&ncs_end1_$ncc) 
 CNSsolve>  evaluate (&toppar.ncs_seg1_$ncc=&ncs_seg1_$ncc) 
 CNSsolve>  evaluate (&toppar.ncs_sta2_$ncc=&ncs_sta2_$ncc) 
 CNSsolve>  evaluate (&toppar.ncs_end2_$ncc=&ncs_end2_$ncc) 
 CNSsolve>  evaluate (&toppar.ncs_seg2_$ncc=&ncs_seg2_$ncc) 
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 CNSsolve>end loop ncs 
 CNSsolve> 
 CNSsolve>! Symmetry restraints 
 CNSsolve>evaluate (&data.ksym=&ksym) 
 EVALUATE: symbol $_1_DATA.KSYM set to    10.0000     (real)
 CNSsolve>evaluate (&Data.flags.sym  =  &sym_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.SYM set to FALSE (logical)
 CNSsolve>evaluate (&data.numc2sym=&numc2sym) 
 EVALUATE: symbol $_1_DATA.NUMC2SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &numc2sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.c2sym_sta1_$nsym=&c2sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.c2sym_end1_$nsym=&c2sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.c2sym_seg1_$nsym=&c2sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.c2sym_sta2_$nsym=&c2sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.c2sym_end2_$nsym=&c2sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.c2sym_seg2_$nsym=&c2sym_seg2_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>evaluate (&data.numc3sym=&numc3sym) 
 EVALUATE: symbol $_1_DATA.NUMC3SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &numc3sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.c3sym_sta1_$nsym=&c3sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_end1_$nsym=&c3sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_seg1_$nsym=&c3sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_sta2_$nsym=&c3sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_end2_$nsym=&c3sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_seg2_$nsym=&c3sym_seg2_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_sta3_$nsym=&c3sym_sta3_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_end3_$nsym=&c3sym_end3_$nsym) 
 CNSsolve>  evaluate (&toppar.c3sym_seg3_$nsym=&c3sym_seg3_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>evaluate (&data.nums3sym=&nums3sym) 
 EVALUATE: symbol $_1_DATA.NUMS3SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &nums3sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.s3sym_sta1_$nsym=&s3sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_end1_$nsym=&s3sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_seg1_$nsym=&s3sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_sta2_$nsym=&s3sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_end2_$nsym=&s3sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_seg2_$nsym=&s3sym_seg2_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_sta3_$nsym=&s3sym_sta3_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_end3_$nsym=&s3sym_end3_$nsym) 
 CNSsolve>  evaluate (&toppar.s3sym_seg3_$nsym=&s3sym_seg3_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>evaluate (&data.numc4sym=&numc4sym) 
 EVALUATE: symbol $_1_DATA.NUMC4SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &numc4sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.c4sym_sta1_$nsym=&c4sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_end1_$nsym=&c4sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_seg1_$nsym=&c4sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_sta2_$nsym=&c4sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_end2_$nsym=&c4sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_seg2_$nsym=&c4sym_seg2_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_sta3_$nsym=&c4sym_sta3_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_end3_$nsym=&c4sym_end3_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_seg3_$nsym=&c4sym_seg3_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_sta4_$nsym=&c4sym_sta4_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_end4_$nsym=&c4sym_end4_$nsym) 
 CNSsolve>  evaluate (&toppar.c4sym_seg4_$nsym=&c4sym_seg4_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>evaluate (&data.numc5sym=&numc5sym) 
 EVALUATE: symbol $_1_DATA.NUMC5SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &numc5sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.c5sym_sta1_$nsym=&c5sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_end1_$nsym=&c5sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_seg1_$nsym=&c5sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_sta2_$nsym=&c5sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_end2_$nsym=&c5sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_seg2_$nsym=&c5sym_seg2_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_sta3_$nsym=&c5sym_sta3_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_end3_$nsym=&c5sym_end3_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_seg3_$nsym=&c5sym_seg3_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_sta4_$nsym=&c5sym_sta4_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_end4_$nsym=&c5sym_end4_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_seg4_$nsym=&c5sym_seg4_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_sta5_$nsym=&c5sym_sta5_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_end5_$nsym=&c5sym_end5_$nsym) 
 CNSsolve>  evaluate (&toppar.c5sym_seg5_$nsym=&c5sym_seg5_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>evaluate (&data.numc6sym=&numc6sym) 
 EVALUATE: symbol $_1_DATA.NUMC6SYM set to    0.00000     (real)
 CNSsolve>evaluate ($nsym=1) 
 EVALUATE: symbol $NSYM set to    1.00000     (real)
 CNSsolve>while ($nsym <= &numc6sym) loop sym 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.c6sym_sta1_$nsym=&c6sym_sta1_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end1_$nsym=&c6sym_end1_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg1_$nsym=&c6sym_seg1_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_sta2_$nsym=&c6sym_sta2_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end2_$nsym=&c6sym_end2_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg2_$nsym=&c6sym_seg2_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_sta3_$nsym=&c6sym_sta3_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end3_$nsym=&c6sym_end3_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg3_$nsym=&c6sym_seg3_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_sta4_$nsym=&c6sym_sta4_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end4_$nsym=&c6sym_end4_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg4_$nsym=&c6sym_seg4_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_sta5_$nsym=&c6sym_sta5_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end5_$nsym=&c6sym_end5_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg5_$nsym=&c6sym_seg5_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_sta6_$nsym=&c6sym_sta6_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_end6_$nsym=&c6sym_end6_$nsym) 
 CNSsolve>  evaluate (&toppar.c6sym_seg6_$nsym=&c6sym_seg6_$nsym) 
 CNSsolve>  evaluate ($nsym = $nsym + 1) 
 CNSsolve>end loop sym 
 CNSsolve> 
 CNSsolve>if ( &data.numc2sym eq 6) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc3sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc4sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc5sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc6sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!Dihedrals, DNA and distance restraints 
 CNSsolve>evaluate (&Data.dnarest = &dnarest_on) 
 EVALUATE: symbol $_1_DATA.DNAREST set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.cdih =  &dihedrals_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.CDIH set to FALSE (logical)
 CNSsolve>evaluate (&Data.cdih.on = &dihedrals_on) 
 EVALUATE: symbol $_1_DATA.CDIH.ON set to FALSE (logical)
 CNSsolve>evaluate (&Data.ssdihed = &ssdihed) 
 Assuming literal string "ALPHABETA"
 EVALUATE: symbol $_1_DATA.SSDIHED set to "ALPHABETA" (string)
 CNSsolve>evaluate (&Data.error_dih = &error_dih) 
 EVALUATE: symbol $_1_DATA.ERROR_DIH set to    10.0000     (real)
 CNSsolve>evaluate (&data.dihedrals.on=&dihedrals_on) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS.ON set to FALSE (logical)
 CNSsolve>evaluate (&data.dihedrals_hot=&dihedrals_hot) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_HOT set to    5.00000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool1=&dihedrals_cool1) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool2=&dihedrals_cool2) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool3=&dihedrals_cool3) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL3 set to    200.000     (real)
 CNSsolve>evaluate (&data.hbonds_on=&hbonds_on) 
 EVALUATE: symbol $_1_DATA.HBONDS_ON set to FALSE (logical)
 CNSsolve> 
 CNSsolve>! RDC restraints 
 CNSsolve>evaluate (&Data.flags.vean =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.VEAN set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.xrdc =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.XRDC set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.sani =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.SANI set to FALSE (logical)
 CNSsolve>evaluate (&data.numrdc=&numrdc) 
 EVALUATE: symbol $_1_DATA.NUMRDC set to    0.00000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &data.numrdc) loop rdc 
 NEXTCD: condition evaluated as false
 CNSsolve>  if (&rdc_choice_$ncc = "VANGLE") then 
 CNSsolve>    evaluate (&Data.flags.vean =  true) 
 CNSsolve>  end if 
 CNSsolve>  if (&rdc_choice_$ncc = "SANI") then 
 CNSsolve>    evaluate (&Data.flags.sani =  true) 
 CNSsolve>  end if 
 CNSsolve>  if (&rdc_choice_$ncc = "XRDC") then 
 CNSsolve>    evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate (&data.rdc_choice_$ncc=&rdc_choice_$ncc) 
 CNSsolve>  evaluate (&data.rdc_firstIt_$ncc=&rdc_firstIt_$ncc) 
 CNSsolve>  evaluate (&data.rdc_lastIt_$ncc=&rdc_lastIt_$ncc) 
 CNSsolve>  evaluate (&data.rdc_hot_$ncc=&rdc_hot_$ncc) 
 CNSsolve>  evaluate (&data.rdc_cool1_$ncc=&rdc_cool1_$ncc) 
 CNSsolve>  evaluate (&data.rdc_cool2_$ncc=&rdc_cool2_$ncc) 
 CNSsolve>  evaluate (&data.rdc_cool3_$ncc=&rdc_cool3_$ncc) 
 CNSsolve>  evaluate (&data.rdc_r_$ncc=&rdc_r_$ncc) 
 CNSsolve>  evaluate (&data.rdc_d_$ncc=&rdc_d_$ncc) 
 CNSsolve>  evaluate (&data.ini_bor_hot_$ncc=&ini_bor_hot_$ncc) 
 CNSsolve>  evaluate (&data.ini_bor_cool1_$ncc=&ini_bor_cool1_$ncc) 
 CNSsolve>  evaluate (&data.ini_bor_cool2_$ncc=&ini_bor_cool2_$ncc) 
 CNSsolve>  evaluate (&data.ini_bor_cool3_$ncc=&ini_bor_cool3_$ncc) 
 CNSsolve>  evaluate (&data.ini_cen_hot_$ncc=&ini_cen_hot_$ncc) 
 CNSsolve>  evaluate (&data.ini_cen_cool1_$ncc=&ini_cen_cool1_$ncc) 
 CNSsolve>  evaluate (&data.ini_cen_cool2_$ncc=&ini_cen_cool2_$ncc) 
 CNSsolve>  evaluate (&data.ini_cen_cool3_$ncc=&ini_cen_cool3_$ncc) 
 CNSsolve>  evaluate (&data.fin_bor_hot_$ncc=&fin_bor_hot_$ncc) 
 CNSsolve>  evaluate (&data.fin_bor_cool1_$ncc=&fin_bor_cool1_$ncc) 
 CNSsolve>  evaluate (&data.fin_bor_cool2_$ncc=&fin_bor_cool2_$ncc) 
 CNSsolve>  evaluate (&data.fin_bor_cool3_$ncc=&fin_bor_cool3_$ncc) 
 CNSsolve>  evaluate (&data.fin_cen_hot_$ncc=&fin_cen_hot_$ncc) 
 CNSsolve>  evaluate (&data.fin_cen_cool1_$ncc=&fin_cen_cool1_$ncc) 
 CNSsolve>  evaluate (&data.fin_cen_cool2_$ncc=&fin_cen_cool2_$ncc) 
 CNSsolve>  evaluate (&data.fin_cen_cool3_$ncc=&fin_cen_cool3_$ncc) 
 CNSsolve>  evaluate ($ncc=$ncc+1) 
 CNSsolve>end loop rdc 
 CNSsolve> 
 CNSsolve>! PCS restraints 
 CNSsolve>evaluate (&Data.flags.xpcs =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.XPCS set to FALSE (logical)
 CNSsolve>evaluate (&data.numpcs=&numpcs) 
 EVALUATE: symbol $_1_DATA.NUMPCS set to    0.00000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numpcs) loop pcs 
 NEXTCD: condition evaluated as false
 CNSsolve>  if (&pcs_choice_$ncc = "XPCS") then 
 CNSsolve>    evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate (&data.pcs_choice_$ncc=&pcs_choice_$ncc) 
 CNSsolve>  evaluate (&data.pcs_firstIt_$ncc=&pcs_firstIt_$ncc) 
 CNSsolve>  evaluate (&data.pcs_lastIt_$ncc=&pcs_lastIt_$ncc) 
 CNSsolve>  evaluate (&data.pcs_hot_$ncc=&pcs_hot_$ncc) 
 CNSsolve>  evaluate (&data.pcs_cool1_$ncc=&pcs_cool1_$ncc) 
 CNSsolve>  evaluate (&data.pcs_cool2_$ncc=&pcs_cool2_$ncc) 
 CNSsolve>  evaluate (&data.pcs_cool3_$ncc=&pcs_cool3_$ncc) 
 CNSsolve>  evaluate (&data.pcs_r_$ncc=&pcs_r_$ncc) 
 CNSsolve>  evaluate (&data.pcs_d_$ncc=&pcs_d_$ncc) 
 CNSsolve>  evaluate ($ncc=$ncc+1) 
 CNSsolve>end loop pcs 
 CNSsolve> 
 CNSsolve>! DANI restraints 
 CNSsolve>evaluate (&Data.flags.dani =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.DANI set to FALSE (logical)
 CNSsolve>evaluate (&data.numdani=&numdani) 
 EVALUATE: symbol $_1_DATA.NUMDANI set to    0.00000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numdani) loop dani 
 NEXTCD: condition evaluated as false
 CNSsolve>  if (&dan_choice_$ncc = "DANI") then 
 CNSsolve>    evaluate (&Data.flags.dani =  true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate (&data.dan_choice_$ncc=&dan_choice_$ncc) 
 CNSsolve>  evaluate (&data.dan_firstIt_$ncc=&dan_firstIt_$ncc) 
 CNSsolve>  evaluate (&data.dan_lastIt_$ncc=&dan_lastIt_$ncc) 
 CNSsolve>  evaluate (&data.dan_hot_$ncc=&dan_hot_$ncc) 
 CNSsolve>  evaluate (&data.dan_cool1_$ncc=&dan_cool1_$ncc) 
 CNSsolve>  evaluate (&data.dan_cool2_$ncc=&dan_cool2_$ncc) 
 CNSsolve>  evaluate (&data.dan_cool3_$ncc=&dan_cool3_$ncc) 
 CNSsolve>  evaluate (&data.dan_tc_$ncc=&dan_tc_$ncc) 
 CNSsolve>  evaluate (&data.dan_anis_$ncc=&dan_anis_$ncc) 
 CNSsolve>  evaluate (&data.dan_r_$ncc=&dan_r_$ncc) 
 CNSsolve>  evaluate (&data.dan_wh_$ncc=&dan_wh_$ncc) 
 CNSsolve>  evaluate (&data.dan_wn_$ncc=&dan_wn_$ncc) 
 CNSsolve>  evaluate ($ncc=$ncc+1) 
 CNSsolve>end loop dani 
 CNSsolve> 
 CNSsolve>! planarity restraints 
 CNSsolve>evaluate (&Data.flags.plan =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.PLAN set to FALSE (logical)
 CNSsolve> 
 CNSsolve>! distance restraints 
 CNSsolve>evaluate (&Data.flags.noe  =  true) 
 EVALUATE: symbol $_1_DATA.FLAGS.NOE set to TRUE (logical)
 CNSsolve>evaluate (&data.scaling=&air_scaling) 
 EVALUATE: symbol $_1_DATA.SCALING set to FALSE (logical)
 CNSsolve>evaluate (&data.totnoe_unamb=&tot_unamb) 
 EVALUATE: symbol $_1_DATA.TOTNOE_UNAMB set to    25.0000     (real)
 CNSsolve>evaluate (&data.unamb_firstit=&unamb_firstit) 
 EVALUATE: symbol $_1_DATA.UNAMB_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.unamb_lastit=&unamb_lastit) 
 EVALUATE: symbol $_1_DATA.UNAMB_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.unamb_hot=&unamb_hot) 
 EVALUATE: symbol $_1_DATA.UNAMB_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool1=&unamb_cool1) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool2=&unamb_cool2) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool3=&unamb_cool3) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL3 set to    50.0000     (real)
 CNSsolve>evaluate (&data.noecv=&noecv) 
 EVALUATE: symbol $_1_DATA.NOECV set to TRUE (logical)
 CNSsolve>evaluate (&data.ncvpart=&ncvpart) 
 EVALUATE: symbol $_1_DATA.NCVPART set to    2.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.totnoe_amb=&tot_amb) 
 EVALUATE: symbol $_1_DATA.TOTNOE_AMB set to    0.00000     (real)
 CNSsolve>evaluate (&data.amb_firstit=&amb_firstit) 
 EVALUATE: symbol $_1_DATA.AMB_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.amb_lastit=&amb_lastit) 
 EVALUATE: symbol $_1_DATA.AMB_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.amb_hot=&amb_hot) 
 EVALUATE: symbol $_1_DATA.AMB_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.amb_cool1=&amb_cool1) 
 EVALUATE: symbol $_1_DATA.AMB_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.amb_cool2=&amb_cool2) 
 EVALUATE: symbol $_1_DATA.AMB_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.amb_cool3=&amb_cool3) 
 EVALUATE: symbol $_1_DATA.AMB_COOL3 set to    50.0000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.hbond_firstit=&hbond_firstit) 
 EVALUATE: symbol $_1_DATA.HBOND_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.hbond_lastit=&hbond_lastit) 
 EVALUATE: symbol $_1_DATA.HBOND_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.hbond_hot=&hbond_hot) 
 EVALUATE: symbol $_1_DATA.HBOND_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool1=&hbond_cool1) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool2=&hbond_cool2) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool3=&hbond_cool3) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL3 set to    50.0000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.mrswi_hot=&mrswi_hot) 
 EVALUATE: symbol $_1_DATA.MRSWI_HOT set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool1=&mrswi_cool1) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL1 set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool2=&mrswi_cool2) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL2 set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool3=&mrswi_cool3) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL3 set to   0.500000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.rswi_hot=&rswi_hot) 
 EVALUATE: symbol $_1_DATA.RSWI_HOT set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool1=&rswi_cool1) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL1 set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool2=&rswi_cool2) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL2 set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool3=&rswi_cool3) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL3 set to   0.500000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.masy_hot=&masy_hot) 
 EVALUATE: symbol $_1_DATA.MASY_HOT set to   -1.00000     (real)
 CNSsolve>evaluate (&data.masy_cool1=&masy_cool1) 
 EVALUATE: symbol $_1_DATA.MASY_COOL1 set to   -1.00000     (real)
 CNSsolve>evaluate (&data.masy_cool2=&masy_cool2) 
 EVALUATE: symbol $_1_DATA.MASY_COOL2 set to  -0.100000     (real)
 CNSsolve>evaluate (&data.masy_cool3=&masy_cool3) 
 EVALUATE: symbol $_1_DATA.MASY_COOL3 set to  -0.100000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.asy_hot=&asy_hot) 
 EVALUATE: symbol $_1_DATA.ASY_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.asy_cool1=&asy_cool1) 
 EVALUATE: symbol $_1_DATA.ASY_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.asy_cool2=&asy_cool2) 
 EVALUATE: symbol $_1_DATA.ASY_COOL2 set to   0.100000     (real)
 CNSsolve>evaluate (&data.asy_cool3=&asy_cool3) 
 EVALUATE: symbol $_1_DATA.ASY_COOL3 set to   0.100000     (real)
 CNSsolve> 
 CNSsolve>evaluate (&data.ranair=&ranair) 
 EVALUATE: symbol $_1_DATA.RANAIR set to FALSE (logical)
 CNSsolve>if (&data.ranair eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&data.noecv = false) 
 CNSsolve>end if 
 CNSsolve>evaluate (&data.cmrest=&cmrest) 
 EVALUATE: symbol $_1_DATA.CMREST set to TRUE (logical)
 CNSsolve>evaluate (&data.cmtight=&cmtight) 
 EVALUATE: symbol $_1_DATA.CMTIGHT set to TRUE (logical)
 CNSsolve>evaluate (&data.kcont=&kcont) 
 EVALUATE: symbol $_1_DATA.KCONT set to    1.00000     (real)
 CNSsolve>evaluate (&data.surfrest=&surfrest) 
 EVALUATE: symbol $_1_DATA.SURFREST set to TRUE (logical)
 CNSsolve>evaluate (&data.ksurf=&ksurf) 
 EVALUATE: symbol $_1_DATA.KSURF set to    1.00000     (real)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! radius of gydration restraints 
 CNSsolve>evaluate (&data.flags.rg=&rgrest) 
 EVALUATE: symbol $_1_DATA.FLAGS.RG set to FALSE (logical)
 CNSsolve>evaluate (&data.rgtarg=&rgtarg) 
 Assuming literal string "&RGTARG"
 EVALUATE: symbol $_1_DATA.RGTARG set to "&RGTARG" (string)
 CNSsolve>evaluate (&data.krg_hot=&krg_hot) 
 Assuming literal string "&KRG_HOT"
 EVALUATE: symbol $_1_DATA.KRG_HOT set to "&KRG_HOT" (string)
 CNSsolve>evaluate (&data.krg_cool1=&krg_cool1) 
 Assuming literal string "&KRG_COOL1"
 EVALUATE: symbol $_1_DATA.KRG_COOL1 set to "&KRG_COOL1" (string)
 CNSsolve>evaluate (&data.krg_cool2=&krg_cool2) 
 Assuming literal string "&KRG_COOL2"
 EVALUATE: symbol $_1_DATA.KRG_COOL2 set to "&KRG_COOL2" (string)
 CNSsolve>evaluate (&data.krg_cool3=&krg_cool3) 
 Assuming literal string "&KRG_COOL3"
 EVALUATE: symbol $_1_DATA.KRG_COOL3 set to "&KRG_COOL3" (string)
 CNSsolve>evaluate (&data.rgsele=&rgsele) 
 Assuming literal string "&RGSELE"
 EVALUATE: symbol $_1_DATA.RGSELE set to "&RGSELE" (string)
 CNSsolve> 
 CNSsolve>evaluate (&data.kzres=&kzres) 
 Assuming literal string "&KZRES"
 EVALUATE: symbol $_1_DATA.KZRES set to "&KZRES" (string)
 CNSsolve>evaluate (&data.zresmax=&zresmax) 
 Assuming literal string "&ZRESMAX"
 EVALUATE: symbol $_1_DATA.ZRESMAX set to "&ZRESMAX" (string)
 CNSsolve>evaluate (&data.zresmin=&zresmin) 
 Assuming literal string "&ZRESMIN"
 EVALUATE: symbol $_1_DATA.ZRESMIN set to "&ZRESMIN" (string)
 CNSsolve> 
 CNSsolve>! keep or delete non-polar hydrogens 
 CNSsolve>evaluate (&toppar.delenph=&delenph) 
 EVALUATE: symbol $_1_TOPPAR.DELENPH set to TRUE (logical)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!Electrostatics: 
 CNSsolve>evaluate (&Data.flags.dihed = &dihedflag) 
 EVALUATE: symbol $_1_DATA.FLAGS.DIHED set to TRUE (logical)
 CNSsolve>evaluate (&Data.flags.elec0 = &elecflag_0) 
 EVALUATE: symbol $_1_DATA.FLAGS.ELEC0 set to TRUE (logical)
 CNSsolve>evaluate (&Data.flags.elec1 = &elecflag_1) 
 EVALUATE: symbol $_1_DATA.FLAGS.ELEC1 set to TRUE (logical)
 CNSsolve>evaluate (&Data.epsilon0 = &epsilon_0) 
 EVALUATE: symbol $_1_DATA.EPSILON0 set to    10.0000     (real)
 CNSsolve>evaluate (&Data.epsilon1 = &epsilon_1) 
 EVALUATE: symbol $_1_DATA.EPSILON1 set to    1.00000     (real)
 CNSsolve>evaluate (&Data.dielec0  = &dielec_0) 
 Assuming literal string "RDIE"
 EVALUATE: symbol $_1_DATA.DIELEC0 set to "RDIE" (string)
 CNSsolve>evaluate (&Data.dielec1  = &dielec_1) 
 Assuming literal string "RDIE"
 EVALUATE: symbol $_1_DATA.DIELEC1 set to "RDIE" (string)
 CNSsolve> 
 CNSsolve>!Check for CG and if present force cdie 
 CNSsolve>evaluate($cg = false) 
 EVALUATE: symbol $CG set to FALSE (logical)
 CNSsolve>evaluate($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cgmol 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  if ($Toppar.cg_$nchain1 eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate($cg = true) 
 CNSsolve>  end if 
 CNSsolve>end loop cgmol 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cgmol 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  if ($Toppar.cg_$nchain1 eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate($cg = true) 
 CNSsolve>  end if 
 CNSsolve>end loop cgmol 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cgmol 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.cg_$nchain1 eq true) then 
 CNSsolve>    evaluate($cg = true) 
 CNSsolve>  end if 
 CNSsolve>end loop cgmol 
 CNSsolve> 
 CNSsolve>if ($cg = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.dielec0  = cdie) 
 CNSsolve>  evaluate (&Data.dielec1  = cdie) 
 CNSsolve>  evaluate (&Data.epsilon1 = &Data.epsilon0) 
 CNSsolve>  display "FORCING CDIE FOR ELECTROSTATICS BECAUSE OF COARSE GRAINING" 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!Interaction matrix: 
 CNSsolve>evaluate ($nmol1=1) 
 EVALUATE: symbol $NMOL1 set to    1.00000     (real)
 CNSsolve>while ($nmol1 <= &data.ncomponents) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    2.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_1 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= &data.ncomponents) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_2 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    3.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= &data.ncomponents) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    2.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= &data.ncomponents) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    3.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_2 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= &data.ncomponents) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    3.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= &data.ncomponents) loop mol1 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 CNSsolve>  while ($nmol2 <= &data.ncomponents) loop mol2 
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 CNSsolve>end loop mol1 
 CNSsolve> 
 CNSsolve>!intermolecular contacts analysis 
 CNSsolve>evaluate (&data.hb_dist=&dist_hb) 
 EVALUATE: symbol $_1_DATA.HB_DIST set to    2.50000     (real)
 CNSsolve>evaluate (&data.nb_dist=&dist_nb) 
 EVALUATE: symbol $_1_DATA.NB_DIST set to    3.90000     (real)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!water refinement 
 CNSsolve>evaluate (&refine.firstwater=&firstwater) 
 EVALUATE: symbol $_1_REFINE.FIRSTWATER set to "yes" (string)
 CNSsolve>evaluate (&refine.solvshell=&solvshell) 
 EVALUATE: symbol $_1_REFINE.SOLVSHELL set to TRUE (logical)
 CNSsolve>evaluate (&refine.keepwater=&keepwater) 
 EVALUATE: symbol $_1_REFINE.KEEPWATER set to FALSE (logical)
 CNSsolve>evaluate (&refine.waterrefine=min(&structures_1,&waterrefine)) 
 EVALUATE: symbol $_1_REFINE.WATERREFINE set to    200.000     (real)
 CNSsolve>evaluate (&refine.solvent=&solvent) 
 EVALUATE: symbol $_1_REFINE.SOLVENT set to "water" (string)
 CNSsolve>evaluate (&refine.heatsteps=&waterheatsteps) 
 EVALUATE: symbol $_1_REFINE.HEATSTEPS set to    100.000     (real)
 CNSsolve>evaluate (&refine.steps=&watersteps) 
 EVALUATE: symbol $_1_REFINE.STEPS set to    1250.00     (real)
 CNSsolve>evaluate (&refine.coolsteps=&watercoolsteps) 
 EVALUATE: symbol $_1_REFINE.COOLSTEPS set to    500.000     (real)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!for the non-bonded parameters (the section was taken out of 
 CNSsolve>!parallhdg5.0.pro and parallhdg5.1.pro, so be careful!): 
 CNSsolve>if (&toppar.par_nonbonded eq "PROLSQ") then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.repel_radius = 1.0) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 20) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 4) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 1) 
 CNSsolve>elseif (&toppar.par_nonbonded eq "PARMALLH6") then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.repel_radius = 0.8) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 5.0) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 2) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 2) 
 CNSsolve>elseif (&toppar.par_nonbonded eq "OPLSX") then 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.repel_radius = 0.0) 
 EVALUATE: symbol $_1_TOPPAR.REPEL_RADIUS set to    0.00000     (real)
 CNSsolve>else        {...now the standard PARALLHDG parameters} 
 CNSsolve>    evaluate (&toppar.repel_radius = 0.78) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 5.0) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 2) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 2) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! Water in rigid body docking 
 CNSsolve>evaluate (&data.waterdock=&waterdock) 
 EVALUATE: symbol $_1_DATA.WATERDOCK set to FALSE (logical)
 CNSsolve>evaluate (&data.db_method=&db_method) 
 EVALUATE: symbol $_1_DATA.DB_METHOD set to "kytedoolittle" (string)
 CNSsolve>evaluate (&data.water_tokeep=&water_tokeep) 
 EVALUATE: symbol $_1_DATA.WATER_TOKEEP set to   0.500000     (real)
 CNSsolve>evaluate (&data.dnap_water_tokeep=&dnap_water_tokeep) 
 EVALUATE: symbol $_1_DATA.DNAP_WATER_TOKEEP set to   0.750000     (real)
 CNSsolve>evaluate (&data.water_randfrac=&water_randfrac) 
 EVALUATE: symbol $_1_DATA.WATER_RANDFRAC set to    0.00000     (real)
 CNSsolve>evaluate (&data.solvate_method=&solvate_method) 
 EVALUATE: symbol $_1_DATA.SOLVATE_METHOD set to "db" (string)
 CNSsolve>evaluate (&data.water_surfcutoff=&water_surfcutoff) 
 EVALUATE: symbol $_1_DATA.WATER_SURFCUTOFF set to    8.00000     (real)
 CNSsolve>evaluate (&data.water_analysis=&water_analysis) 
 EVALUATE: symbol $_1_DATA.WATER_ANALYSIS set to FALSE (logical)
 CNSsolve>evaluate (&data.transwater=&transwater) 
 EVALUATE: symbol $_1_DATA.TRANSWATER set to TRUE (logical)
 CNSsolve>evaluate (&data.water_restraint_initial=&water_restraint_initial) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_INITIAL set to    5.00000     (real)
 CNSsolve>evaluate (&data.water_restraint_cutoff=&water_restraint_cutoff) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_CUTOFF set to    5.00000     (real)
 CNSsolve>evaluate (&data.water_restraint_scale=&water_restraint_scale) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_SCALE set to    25.0000     (real)
 CNSsolve>evaluate (&data.waterensemble=&waterensemble) 
 EVALUATE: symbol $_1_DATA.WATERENSEMBLE set to    1.00000     (real)
 CNSsolve> 
 CNSsolve>! Centroid parameters 
 CNSsolve>eval(&data.flags.centroids = &centroid_rest) 
 EVALUATE: symbol $_1_DATA.FLAGS.CENTROIDS set to FALSE (logical)
 CNSsolve>eval(&data.centroids.kscale = &centroid_kscale) 
 EVALUATE: symbol $_1_DATA.CENTROIDS.KSCALE set to    50.0000     (real)
 CNSsolve>eval($nchain = 0) 
 EVALUATE: symbol $NCHAIN set to    0.00000     (real)
 CNSsolve>while ($nchain < &ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    1.00000     (real)
 CNSsolve>    eval(&data.centroids.xcom_$nchain = &xcom_$nchain) 
 Assuming literal string "&XCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.XCOM_1 set to "&XCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.ycom_$nchain = &ycom_$nchain) 
 Assuming literal string "&YCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.YCOM_1 set to "&YCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.zcom_$nchain = &zcom_$nchain) 
 Assuming literal string "&ZCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.ZCOM_1 set to "&ZCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.ambi_$nchain = &ambi_$nchain) 
 Assuming literal string "&AMBI_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.AMBI_1 set to "&AMBI_$NCHAIN" (string)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain < &ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    2.00000     (real)
 CNSsolve>    eval(&data.centroids.xcom_$nchain = &xcom_$nchain) 
 Assuming literal string "&XCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.XCOM_2 set to "&XCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.ycom_$nchain = &ycom_$nchain) 
 Assuming literal string "&YCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.YCOM_2 set to "&YCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.zcom_$nchain = &zcom_$nchain) 
 Assuming literal string "&ZCOM_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.ZCOM_2 set to "&ZCOM_$NCHAIN" (string)
 CNSsolve>    eval(&data.centroids.ambi_$nchain = &ambi_$nchain) 
 Assuming literal string "&AMBI_$NCHAIN"
 EVALUATE: symbol $_1_DATA.CENTROIDS.AMBI_2 set to "&AMBI_$NCHAIN" (string)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain < &ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($nchain = $nchain + 1) 
 CNSsolve>    eval(&data.centroids.xcom_$nchain = &xcom_$nchain) 
 CNSsolve>    eval(&data.centroids.ycom_$nchain = &ycom_$nchain) 
 CNSsolve>    eval(&data.centroids.zcom_$nchain = &zcom_$nchain) 
 CNSsolve>    eval(&data.centroids.ambi_$nchain = &ambi_$nchain) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>if (&saprotocol.expand eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  eval(&data.flags.centroids = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! Cryo-EM parameters 
 CNSsolve>eval(&data.flags.em = &em_rest) 
 EVALUATE: symbol $_1_DATA.FLAGS.EM set to FALSE (logical)
 CNSsolve>eval(&data.em.kscale = &em_kscale) 
 EVALUATE: symbol $_1_DATA.EM.KSCALE set to    15000.0     (real)
 CNSsolve>eval(&data.em.it0 = &em_it0) 
 EVALUATE: symbol $_1_DATA.EM.IT0 set to FALSE (logical)
 CNSsolve>eval(&data.em.it1 = &em_it1) 
 EVALUATE: symbol $_1_DATA.EM.IT1 set to FALSE (logical)
 CNSsolve>eval(&data.em.itw = &em_itw) 
 EVALUATE: symbol $_1_DATA.EM.ITW set to FALSE (logical)
 CNSsolve>eval(&data.em.resolution = &em_resolution) 
 Assuming literal string "NONE"
 EVALUATE: symbol $_1_DATA.EM.RESOLUTION set to "NONE" (string)
 CNSsolve>eval(&data.em.nx = &nx) 
 EVALUATE: symbol $_1_DATA.EM.NX set to    32.0000     (real)
 CNSsolve>eval(&data.em.ny = &ny) 
 EVALUATE: symbol $_1_DATA.EM.NY set to    32.0000     (real)
 CNSsolve>eval(&data.em.nz = &nz) 
 EVALUATE: symbol $_1_DATA.EM.NZ set to    32.0000     (real)
 CNSsolve>eval(&data.em.xlength = &xlength) 
 EVALUATE: symbol $_1_DATA.EM.XLENGTH set to    80.0000     (real)
 CNSsolve>eval(&data.em.ylength = &ylength) 
 EVALUATE: symbol $_1_DATA.EM.YLENGTH set to    80.0000     (real)
 CNSsolve>eval(&data.em.zlength = &zlength) 
 EVALUATE: symbol $_1_DATA.EM.ZLENGTH set to    80.0000     (real)
 CNSsolve> 
 CNSsolve>if (&data.flags.em eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  eval(&data.waterdock = false) 
 CNSsolve>  display "EM restraints and solvated docking are incompatible - turning solvated docking OFF" 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.waterdock eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&saprotocol.rotate180_it0 = false) 
 CNSsolve>  evaluate (&saprotocol.rotate180_it1 = false) 
 CNSsolve>  evaluate (&SaProtocol.initiosteps = 0) 
 CNSsolve>  evaluate (&SaProtocol.cool1_steps = 0) 
 CNSsolve>  evaluate (&refine.keepwater = true) 
 CNSsolve>  display SOLVATED DOCKING TURNED ON: initiosteps and cool1_steps set to 0, rotate180 set to false 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! Flexible region cutoff 
 CNSsolve>evaluate (&data.flcut_nb = &flcut_nb) 
 EVALUATE: symbol $_1_DATA.FLCUT_NB set to    5.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate ($log_level=quiet) 
 Assuming literal string "QUIET"
 EVALUATE: symbol $LOG_LEVEL set to "QUIET" (string)
 CNSsolve>!evaluate ($log_level=verbose) 
 CNSsolve> 
 CNSsolve>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set message=normal echo=on end 
 CNSsolve>else 
 CNSsolve>   set message=off echo=off end 
 CNSsolve>evaluate ($structurefile = "RUN:begin/" + $Filenames.fileroot + ".psf") 
 EVALUATE: symbol $STRUCTUREFILE set to "RUN:begin/complex.psf" (string)
 CNSsolve>structure @@$structurefile end 
 ASSFIL: file complex.psf opened.
 STRUcture>data_cns_mtf 
 REMARKS FILENAME="complex.psf"
 REMARKS coordinates built for atom:      MET  1    HN
 REMARKS coordinates built for atom:      PHE  2    HN
 REMARKS coordinates built for atom:      TYR  3    HN
 REMARKS coordinates built for atom:      TYR  3    HH
 REMARKS coordinates built for atom:      ILE  4    HN
 REMARKS coordinates built for atom:      GLU  5    HN
 REMARKS coordinates built for atom:      ASP  6    HN
 REMARKS coordinates built for atom:      ILE  7    HN
 REMARKS coordinates built for atom:      LEU  8    HN
 REMARKS coordinates built for atom:      ALA  9    HN
 REMARKS DATE:08-Nov-2022  09:29:37       created by user: enmr
 REMARKS VERSION:1.3U
 Status of internal molecular topology database:
 -> NATOM=       3253(MAXA=     1000000)  NBOND=       3320(MAXB=     1000000)
 -> NTHETA=      4764(MAXT=     2000000)  NGRP=         346(MAXGRP=   1000000)
 -> NPHI=        8126(MAXP=     2000000)  NIMPHI=      1660(MAXIMP=   1000000)
 -> NNB=          192(MAXNB=    1000000) 
 STRUcture> 
 STRUcture> end 
 CNSsolve> 
 CNSsolve>! create and set the dummy atoms if centroids are required in rigid body stage 
 CNSsolve>if ($Data.flags.centroids = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($iteration = 0) then 
 CNSsolve>        @RUN:protocols/centroids_create.cns(ncomponents=$Data.ncomponents; Toppar=$Toppar;) 
 ASSFIL: file centroids_create.cns opened.
 CNSsolve>module (ncomponents; Toppar;) 
 CNSsolve>    {Create and initialize Dummy residues for each segid 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    ncomponents : int 
 CNSsolve>        Number of components/segids 
 CNSsolve> 
 CNSsolve>    Toppar : data-structure 
 CNSsolve>        The Toppar data-structure 
 CNSsolve> 
 CNSsolve>    Side-effects 
 CNSsolve>    ------------ 
 CNSsolve>    A DUM residue is appended to each segid and placed at the origin 
 CNSsolve>    } 
 CNSsolve> 
 CNSsolve>    ! define topology of DUM residue 
 CNSsolve>    topology 
 CNSsolve>        mass DD 100.00 
 CNSsolve>        residue DUM group 
 CNSsolve>            atom DUM type=DD charge=0.000 end 
 CNSsolve>            atom MAP type=DD charge=0.000 end 
 CNSsolve>        end 
 CNSsolve>    end 
 CNSsolve>    ! define non-bonded parameters 
 CNSsolve>    parameter 
 CNSsolve>        nonbonded DD 0.001 0.001 0.001 0.001 end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! place dummy atom of dummy residue in the center of each chain 
 CNSsolve>    evaluate($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < &ncomponents) loop nloopdum 
 CNSsolve>        evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>        ! create the dummy residue 
 CNSsolve>        segment 
 CNSsolve>            name="TMP1" 
 CNSsolve>            chain 
 CNSsolve>                sequence "DUM" end 
 CNSsolve>            end 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! set the residue id of dummy to last residue + 1 
 CNSsolve>        show max(decode(resid)) (segid &Toppar.prot_segid_$nchain1) 
 CNSsolve>        evaluate($maxresid = $result) 
 CNSsolve> 
 CNSsolve>        ! change the segid of the dummy residue 
 CNSsolve>        do (segid = &Toppar.prot_segid_$nchain1) (segid TMP1) 
 CNSsolve> 
 CNSsolve>        ! set residue id and coordinate of the dummy residue 
 CNSsolve>        do (x = 0) (segid &Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>        do (y = 0) (segid &Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>        do (z = 0) (segid &Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>        do (resid = encode($maxresid + 1)) (segid &Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve> 
 CNSsolve>    end loop nloopdum 
 CNSsolve>        @RUN:protocols/centroids_initialize.cns 
 ASSFIL: file centroids_initialize.cns opened.
 CNSsolve>{Places DUM-residue on the center of each segid} 
 CNSsolve> 
 CNSsolve>eval($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    show ave(x) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.x = $RESULT) 
 CNSsolve>    show ave(y) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.y = $RESULT) 
 CNSsolve>    show ave(z) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.z = $RESULT) 
 CNSsolve> 
 CNSsolve>    do (x = $center.x) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>    do (y = $center.y) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>    do (z = $center.z) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>end loop nloop1 
 CNSsolve>    end if 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      if ($saprotocol.expand = true) then 
 CNSsolve>        @RUN:protocols/centroids_create.cns(ncomponents=$Data.ncomponents; Toppar=$Toppar;) 
 ASSFIL: file centroids_create.cns opened.
 CNSsolve>module (ncomponents; Toppar;) 
 CNSsolve>    {Create and initialize Dummy residues for each segid 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    ncomponents : int 
 CNSsolve>        Number of components/segids 
 CNSsolve> 
 CNSsolve>    Toppar : data-structure 
 CNSsolve>        The Toppar data-structure 
 CNSsolve> 
 CNSsolve>    Side-effects 
 CNSsolve>    ------------ 
 CNSsolve>    A DUM residue is appended to each segid and placed at the origin 
 CNSsolve>    } 
 CNSsolve> 
 CNSsolve>    ! define topology of DUM residue 
 CNSsolve>    topology 
 CNSsolve>        mass DD 100.00 
 CNSsolve>        residue DUM group 
 CNSsolve>            atom DUM type=DD charge=0.000 end 
 CNSsolve>            atom MAP type=DD charge=0.000 end 
 CNSsolve>        end 
 CNSsolve>    end 
 CNSsolve>    ! define non-bonded parameters 
 CNSsolve>    parameter 
 CNSsolve>        nonbonded DD 0.001 0.001 0.001 0.001 end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! place dummy atom of dummy residue in the center of each chain 
 CNSsolve>    evaluate($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < &ncomponents) loop nloopdum 
 CNSsolve>        evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>        ! create the dummy residue 
 CNSsolve>        segment 
 CNSsolve>            name="TMP1" 
 CNSsolve>            chain 
 CNSsolve>                sequence "DUM" end 
 CNSsolve>            end 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! set the residue id of dummy to last residue + 1 
 CNSsolve>        show max(decode(resid)) (segid &Toppar.prot_segid_$nchain1) 
 CNSsolve>        evaluate($maxresid = $result) 
 CNSsolve> 
 CNSsolve>        ! change the segid of the dummy residue 
 CNSsolve>        do (segid = &Toppar.prot_segid_$nchain1) (segid TMP1) 
 CNSsolve> 
 CNSsolve>        ! set residue id and coordinate of the dummy residue 
 CNSsolve>        do (x = 0) (segid &Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>        do (y = 0) (segid &Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>        do (z = 0) (segid &Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>        do (resid = encode($maxresid + 1)) (segid &Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve> 
 CNSsolve>    end loop nloopdum 
 CNSsolve>        @RUN:protocols/centroids_initialize.cns 
 ASSFIL: file centroids_initialize.cns opened.
 CNSsolve>{Places DUM-residue on the center of each segid} 
 CNSsolve> 
 CNSsolve>eval($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    show ave(x) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.x = $RESULT) 
 CNSsolve>    show ave(y) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.y = $RESULT) 
 CNSsolve>    show ave(z) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.z = $RESULT) 
 CNSsolve> 
 CNSsolve>    do (x = $center.x) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>    do (y = $center.y) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>    do (z = $center.z) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>end loop nloop1 
 CNSsolve>        delete sele=(name MAP) end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!for the rdc restraints: 
 CNSsolve>if ($Data.flags.sani = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  topology  @@RUN:toppar/top_axis.pro end 
 CNSsolve>  parameter @@RUN:toppar/par_axis.pro end 
 CNSsolve>  structure @@RUN:toppar/tensor.psf end 
 CNSsolve>end if 
 CNSsolve>eval ($xtensor = false) 
 EVALUATE: symbol $XTENSOR set to FALSE (logical)
 CNSsolve>if ($Data.flags.xrdc = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  eval ($xtensor = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.xpcs = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  eval ($xtensor = true) 
 CNSsolve>end if 
 CNSsolve>if ($xtensor = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  topology  @@RUN:toppar/top_axis.pro end 
 CNSsolve>  parameter @@RUN:toppar/par_axis.pro end 
 CNSsolve>  structure @@RUN:toppar/tensor_para.psf end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  topology  @@RUN:toppar/top_axis_dani.pro end 
 CNSsolve>  parameter @@RUN:toppar/par_axis.pro end 
 CNSsolve>  structure @@RUN:toppar/tensor_dani.psf end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!read the parameter files: 
 CNSsolve>if ($toppar.par_nonbonded = "") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($toppar.par_nonbonded = "OPLSX") 
 CNSsolve>end if 
 CNSsolve>evaluate ($par_nonbonded = $toppar.par_nonbonded) 
 EVALUATE: symbol $PAR_NONBONDED set to "OPLSX" (string)
 CNSsolve> 
 CNSsolve>eval($nchain1= 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>eval($coarse = false) 
 EVALUATE: symbol $COARSE set to FALSE (logical)
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($par_cg_$nchain1 = false) 
 EVALUATE: symbol $PAR_CG_1 set to FALSE (logical)
 CNSsolve>  evaluate ($parstatus_cg_$nchain1 = false) 
 EVALUATE: symbol $PARSTATUS_CG_1 set to FALSE (logical)
 CNSsolve>  if ($toppar.cg_$nchain1 = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($coarse = true) 
 CNSsolve>    evaluate ($par_cg_$nchain1 = true) 
 CNSsolve>    evaluate ($parstatus_cg_$nchain1 = true) 
 CNSsolve>    if ( $iteration < 2) then 
 CNSsolve>      evaluate ($par_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_cg_par_$nchain1) 
 CNSsolve>      evaluate ($par_cg_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_cg_par_$nchain1) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($par_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_par_$nchain1) 
 CNSsolve>      evaluate ($par_cg_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_cg_par_$nchain1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($par_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_par_$nchain1) 
 EVALUATE: symbol $PAR_NONBONDED_1 set to "RUN:toppar/protein-allhdg5-4.param" (string)
 CNSsolve>  end if 
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>end loop cloop1 
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($par_cg_$nchain1 = false) 
 EVALUATE: symbol $PAR_CG_2 set to FALSE (logical)
 CNSsolve>  evaluate ($parstatus_cg_$nchain1 = false) 
 EVALUATE: symbol $PARSTATUS_CG_2 set to FALSE (logical)
 CNSsolve>  if ($toppar.cg_$nchain1 = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($coarse = true) 
 CNSsolve>    evaluate ($par_cg_$nchain1 = true) 
 CNSsolve>    evaluate ($parstatus_cg_$nchain1 = true) 
 CNSsolve>    if ( $iteration < 2) then 
 CNSsolve>      evaluate ($par_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_cg_par_$nchain1) 
 CNSsolve>      evaluate ($par_cg_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_cg_par_$nchain1) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($par_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_par_$nchain1) 
 CNSsolve>      evaluate ($par_cg_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_cg_par_$nchain1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($par_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_par_$nchain1) 
 EVALUATE: symbol $PAR_NONBONDED_2 set to "RUN:toppar/protein-allhdg5-4.param" (string)
 CNSsolve>  end if 
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    3.00000     (real)
 CNSsolve>end loop cloop1 
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($par_cg_$nchain1 = false) 
 CNSsolve>  evaluate ($parstatus_cg_$nchain1 = false) 
 CNSsolve>  if ($toppar.cg_$nchain1 = true) then 
 CNSsolve>    eval($coarse = true) 
 CNSsolve>    evaluate ($par_cg_$nchain1 = true) 
 CNSsolve>    evaluate ($parstatus_cg_$nchain1 = true) 
 CNSsolve>    if ( $iteration < 2) then 
 CNSsolve>      evaluate ($par_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_cg_par_$nchain1) 
 CNSsolve>      evaluate ($par_cg_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_cg_par_$nchain1) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($par_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_par_$nchain1) 
 CNSsolve>      evaluate ($par_cg_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_cg_par_$nchain1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($par_nonbonded_$nchain1 = "RUN:toppar/" + $toppar.prot_par_$nchain1) 
 CNSsolve>  end if 
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 CNSsolve>end loop cloop1 
 CNSsolve> 
 CNSsolve>eval($nchain1= 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  eval($parstatus_$nchain1 = true) 
 EVALUATE: symbol $PARSTATUS_1 set to TRUE (logical)
 CNSsolve>end loop cloop1 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  eval($parstatus_$nchain1 = true) 
 EVALUATE: symbol $PARSTATUS_2 set to TRUE (logical)
 CNSsolve>end loop cloop1 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 CNSsolve>  eval($parstatus_$nchain1 = true) 
 CNSsolve>end loop cloop1 
 CNSsolve> 
 CNSsolve>eval($nchain1= 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cloop2 
 NEXTCD: condition evaluated as true
 CNSsolve>  eval($nchain2 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 CNSsolve>  while ($nchain2 <= $data.ncomponents) loop cloop3 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ($par_nonbonded_$nchain2 eq $par_nonbonded_$nchain1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      eval($parstatus_$nchain2 = false) 
 EVALUATE: symbol $PARSTATUS_2 set to FALSE (logical)
 CNSsolve>    end if 
 CNSsolve>    eval($nchain2 = $nchain2 + 1) 
 EVALUATE: symbol $NCHAIN2 set to    3.00000     (real)
 CNSsolve>  end loop cloop3 
 CNSsolve>  while ($nchain2 <= $data.ncomponents) loop cloop3 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($par_nonbonded_$nchain2 eq $par_nonbonded_$nchain1) then 
 CNSsolve>      eval($parstatus_$nchain2 = false) 
 CNSsolve>    end if 
 CNSsolve>    eval($nchain2 = $nchain2 + 1) 
 CNSsolve>  end loop cloop3 
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>end loop cloop2 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cloop2 
 NEXTCD: condition evaluated as false
 CNSsolve>  eval($nchain2 = $nchain1 + 1) 
 CNSsolve>  while ($nchain2 <= $data.ncomponents) loop cloop3 
 CNSsolve>    if ($par_nonbonded_$nchain2 eq $par_nonbonded_$nchain1) then 
 CNSsolve>      eval($parstatus_$nchain2 = false) 
 CNSsolve>    end if 
 CNSsolve>    eval($nchain2 = $nchain2 + 1) 
 CNSsolve>  end loop cloop3 
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 CNSsolve>end loop cloop2 
 CNSsolve> 
 CNSsolve>parameter @@$par_nonbonded_1 end 
 ASSFIL: file protein-allhdg5-4.param opened.
 PARRDR>remarks file toppar/protein-allhdg5-4.param 
 PARRDR>remark 
 PARRDR>remark   for file protein-allhdg-ucl.top  version UCL  date 14-MAR-00 
 PARRDR>remark   for file protein-allhdg-dih-ucl.top  version UCL  date 07-JUL-01 
 PARRDR>remark   Geometric energy function parameters for distance geometry and 
 PARRDR>remark   simulated annealing. 
 PARRDR>remark   Original author: Michael Nilges, EMBL Heidelberg 
 PARRDR>remark   Modifications: Mark A. Williams, UCL London 
 PARRDR>remark   Several modifications for HADDOCK: Alexandre Bonvin, Utrecht Uni 
 PARRDR>remark   Last modification 06-02-2021 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 PARRDR>set message=off echo=off end 
 PARRDR> 
 PARRDR> 
 PARRDR> end 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 CNSsolve>eval($nchain1= 2) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ($parstatus_$nchain1 = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    parameter @@$par_nonbonded_$nchain1 end 
 CNSsolve>  end if 
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    3.00000     (real)
 CNSsolve>end loop cloop1 
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($parstatus_$nchain1 = true) then 
 CNSsolve>    parameter @@$par_nonbonded_$nchain1 end 
 CNSsolve>  end if 
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 CNSsolve>end loop cloop1 
 CNSsolve> 
 CNSsolve>parameter 
 PARRDR>  nbonds 
 NBDSET>    nbxmod=5 atom cdie shift 
 NBDSET>    cutnb=9.5 ctofnb=8.5 ctonnb=6.5 eps=1.0 e14fac=0.4 inhibit 0.25 
 NBDSET>    wmin=0.5 tolerance  0.5 
 NBDSET>  end 
 PARRDR>end 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 CNSsolve> 
 CNSsolve>if ($coarse eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ( $iteration == 2) then 
 CNSsolve>    ! We need to read both the AA and CG parameters, but avoid duplication 
 CNSsolve>    eval($nchain1= 1) 
 CNSsolve>    while ($nchain1 <= $data.ncomponents) loop cloop1 
 CNSsolve>      if ($par_cg_$nchain1 eq true) then 
 CNSsolve>        eval($nchain2 = $nchain1 + 1) 
 CNSsolve>        while ($nchain2 <= $data.ncomponents) loop cloop2 
 CNSsolve>          if ($par_cg_$nchain2 eq true) then 
 CNSsolve>            if ($par_cg_nonbonded_$nchain2 eq $par_cg_nonbonded_$nchain1) then 
 CNSsolve>              eval($parstatus_cg_$nchain2 = false) 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve>          eval($nchain2 = $nchain2 + 1) 
 CNSsolve>        end loop cloop2 
 CNSsolve>      else 
 CNSsolve>        eval($parstatus_cg_$nchain1 = false) 
 CNSsolve>      end if 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    end loop cloop1 
 CNSsolve> 
 CNSsolve>    eval($nchain1= 1) 
 CNSsolve>    while ($nchain1 <= $data.ncomponents) loop cloop1 
 CNSsolve>      if ($parstatus_cg_$nchain1 = true) then 
 CNSsolve>        parameter @@$par_cg_nonbonded_$nchain1 end 
 CNSsolve>      end if 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    end loop cloop1 
 CNSsolve> 
 CNSsolve>  else 
 CNSsolve>    ! Only CG paramters have been read - only need to set the nonbonded flags 
 CNSsolve>    parameter 
 CNSsolve>      nbonds 
 CNSsolve>        nbxmod=5 atom cdie shift 
 CNSsolve>        cutnb=15.0 ctofnb=14.0 ctonnb=12.0 eps=1.0 e14fac=0.4 inhibit 0.25 
 CNSsolve>        wmin=0.5 tolerance  0.5 
 CNSsolve>      end 
 CNSsolve>    end 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! this is required for protein-DNA complexes 
 CNSsolve>! bur not needed if a DNA param file has already been defined 
 CNSsolve>if ( &BLANK%nucl_parameter_infile = false ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  eval($dnaparam = "RUN:toppar/" + &nucl_parameter_infile) 
 EVALUATE: symbol $DNAPARAM set to "RUN:toppar/dna-rna-allatom-hj-opls-1.3.param" (string)
 CNSsolve>  eval($read_dna_param = true) 
 EVALUATE: symbol $READ_DNA_PARAM set to TRUE (logical)
 CNSsolve>  eval($nchain1 = 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  while ($nchain1 <= $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ($par_nonbonded_$nchain1 = $dnaparam) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      eval($read_dna_param = false) 
 CNSsolve>    end if 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  end loop cloop1 
 CNSsolve>  while ($nchain1 <= $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ($par_nonbonded_$nchain1 = $dnaparam) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      eval($read_dna_param = false) 
 CNSsolve>    end if 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    3.00000     (real)
 CNSsolve>  end loop cloop1 
 CNSsolve>  while ($nchain1 <= $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($par_nonbonded_$nchain1 = $dnaparam) then 
 CNSsolve>      eval($read_dna_param = false) 
 CNSsolve>    end if 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>  end loop cloop1 
 CNSsolve>  if ($read_dna_param = true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    param @@$dnaparam end 
 ASSFIL: file dna-rna-allatom-hj-opls-1.3.param opened.
 PARRDR>remarks file toppar/dna-rna-allatom.top 
 PARRDR>remarks  dna-rna-allatom-hj-opls-1.3.param 
 PARRDR>remarks  all-hydrogen dna/rna parameters using the OPLS force field 
 PARRDR> 
 PARRDR>!RNA PARAMETER FILE 'FRAMEWORK' FROM PARALLHDG.DNA AND ATOM NAMES 
 PARRDR>! AND HEAVY ATOM PARAMETERS FROM DNA-RNA.PARAM 
 PARRDR>!INCLUDES ALL NONEXCHANGEABLE HYDROGEN TERMS FOR BOND, ANGLE, AND 
 PARRDR>!IMPROPERS WITH ENERGY CONSTANT VARIABLES: $kchbond, $kchangle, AND $kchimpr. 
 PARRDR>!BOND, ANGLE, AND IMPROPERS WERE ESTIMATED FROM VALUES FROM THE STANDARD 
 PARRDR>!NUCLEOTIDES OF INSIGHTII 95.0 (BIOSYM/MOLECULAR SIMULATIONS). 
 PARRDR>!CREATED 2/24/96 -- JASON P. RIFE AND PETER B. MOORE 
 PARRDR>!ADDED OPLSX SECTION 6/2/07 -- HENRY JONKER 
 PARRDR>!ADAPTED/CLEANED FOR HADDOCK -- ALEXANDRE BONVIN 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 PARRDR>set message=off echo=off end 
 PARRDR> 
 PARRDR> end 
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! and the same for the CG version 
 CNSsolve>if ($coarse eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ( &BLANK%nucl_cgparameter_infile = false ) then 
 CNSsolve>    eval($dnacgparam = "RUN:toppar/" + &nucl_cgparameter_infile) 
 CNSsolve>    eval($read_dna_cgparam = true) 
 CNSsolve>    eval($nchain1 = 1) 
 CNSsolve>    while ($nchain1 <= $data.ncomponents) loop cloop1 
 CNSsolve>      if ($par_cg_nonbonded_$nchain1 = $dnacgparam) then 
 CNSsolve>        eval($read_dna_cgparam = false) 
 CNSsolve>      end if 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    end loop cloop1 
 CNSsolve>    if ($read_dna_cgparam = true) then 
 CNSsolve>      param @@$dnacgparam end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>parameter @@RUN:toppar/carbohydrate.param end 
 ASSFIL: file carbohydrate.param opened.
 PARRDR>remarks file toppar/carbohydrate.param 
 PARRDR>REMARKS Parameter file for pyranose sugars 
 PARRDR>REMARKS Alexandre Bonvin - adapted to use unique atom types for sugar-specific atoms 
 PARRDR>REMARKS Joao Rodrigues 11-June-2020 
 PARRDR>REMARKS Parameters updated to Feng, PLoS One, 2017 
 PARRDR>REMARKS PMC 5726640 
 PARRDR> 
 PARRDR>REMARKS Bill Weis 10-July-1988 
 PARRDR>REMARKS Additions for atom type combinations not covered in PARAM19X.PRO. 
 PARRDR>REMARKS Needed additions are for ether oxygen and aliphatic carbon in all-atom 
 PARRDR>REMARKS representation used for sugars (type CC).  Ditto for type HA. 
 PARRDR>REMARKS Values from J. Brady glucose parameters unless noted. 
 PARRDR>REMARKS These should be sufficient for refinement. 
 PARRDR> 
 PARRDR>REMARKS Additions 6-March-1992 Bill Weis 
 PARRDR>REMARKS New atom types CCA, CCE,  OASfor the C1 & O1 positions to account 
 PARRDR>REMARKS for different BOND and ANGLe values due to the anomeric effect. 
 PARRDR>REMARKS More accurate equilibrium values for BOND ANGLe around this oxygen 
 PARRDR>REMARKS in glycosidic linkages.  CCE for equatorial O1, CCA for 
 PARRDR>REMAKRS axial O1.   For free sugar, keep OH1 as O1 atomtype; changed to OA 
 PARRDR>REMARKS for linkages. 
 PARRDR>REMARKS References: G.A. Jeffrey (1990) Acta Cryst B46, 89-103; 
 PARRDR>REMARKS K. Hirotsu & A.Shimada, (1974) Bull. Chem. Soc. Japan, 47, 1872-1879. 
 PARRDR> 
 PARRDR>REMARKS  This set has been modified to be roughly consistent with 
 PARRDR>REMARKS  the csd-derived protein parameters of Engh and Huber. 
 PARRDR>REMARKS  New atom type CC6 for exocyclic 6 carbon 
 PARRDR>REMARKS  Bill Weis 5/11/92 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 PARRDR>set message=off echo=off end 
 PARRDR> 
 PARRDR> 
 PARRDR> end 
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 CNSsolve>parameter @@RUN:toppar/ion.param end 
 ASSFIL: file ion.param opened.
 PARRDR>remarks file toppar/ion.param 
 PARRDR>remarks nonbonded parameters for common ions 
 PARRDR>remarks new parameters derived from literature for single atom species 
 PARRDR>remarks PDA 02/09/99 
 PARRDR> 
 PARRDR>set echo=off end 
 PARRDR> end 
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 CNSsolve>parameter @@RUN:toppar/ligand.param end 
 ASSFIL: file ligand.param opened.
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 CNSsolve>parameter @@RUN:toppar/fragment_probes.param end 
 ASSFIL: file fragment_probes.param opened.
 PARRDR>Remarks Parameters for Fragment-based Ligand Binding Site Mapping 
 PARRDR>Remarks created by acpype (Rev: 7268) on Mon Apr 13 10:01:53 2015 
 PARRDR> 
 PARRDR>set echo=false end 
 PARRDR> end 
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 CNSsolve>parameter @@RUN:toppar/hemes-allhdg.param end 
 ASSFIL: file hemes-allhdg.param opened.
 PARRDR>remark  file parallhdg.hemes 
 PARRDR> 
 PARRDR>set message off echo off end 
 PARRDR> end 
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve>parameter @@RUN:toppar/water-allhdg5-4.param end 
 ASSFIL: file water-allhdg5-4.param opened.
 PARRDR>remarks file toppar/water-allhdg5-4.param 
 PARRDR>remarks 
 PARRDR>remarks   PARAM19.SOL (solvent parameters) 
 PARRDR>remarks   =========== 
 PARRDR>remarks   available: TIPS3P and DMSO model 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 PARRDR>set message=off echo=off end 
 PARRDR> end 
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve>parameter @@RUN:toppar/shape.param end 
 ASSFIL: file shape.param opened.
 PARRDR>NONBonded  SHA    0.01  0.01     0.01  0.01 
 PARRDR> 
 PARRDR>BOND SHA  SHA  0.0	2.0 
 PARRDR> 
 PARRDR> end 
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve> 
 CNSsolve>igroup 
 IGROup>  interaction  (not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 SELRPN:   3253 atoms have been selected out of   3253
 SELRPN>               (not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1 end 
 SELRPN:   3253 atoms have been selected out of   3253
 IGROup>  interaction  (resn ANI or resn DAN or resn XAN or resn DUM or resn DUM) 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN>               (resn ANI or resn DAN or resn XAN or resn DUM or resn DUM) weight * 1 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 IGROup>  interaction  (resn SHA) (not resn SHA) weight * 0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:   3253 atoms have been selected out of   3253
 IGROup> 
 IGROup>end 
 CNSsolve> 
 CNSsolve>inline @RUN:protocols/charge-beads-interactions.cns 
 ASSFIL: file charge-beads-interactions.cns opened.
 CNSsolve>! charge-beads-interactions.cns 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * and from the CNS distriution of Brunger and Adams                   * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>for $id1 in id ( (resn SER or resn THR or resn ASN or resn GLN) and name BB ) loop c1beads 
 SELRPN:      0 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>   show (segid) (id $id1) 
 CNSsolve>   evaluate ($cgsegid=$result) 
 CNSsolve>   show (resid) (id $id1) 
 CNSsolve>   evaluate ($cgresid=$result) 
 CNSsolve> 
 CNSsolve>   igroup 
 CNSsolve>     ! turn off all vdw interactions between charged beads and all beads 
 CNSsolve>     interaction (segid $cgsegid and resid $cgresid and name SCD1) (all) weight vdw 0.0 end 
 CNSsolve>     interaction (segid $cgsegid and resid $cgresid and name SCD2) (all) weight vdw 0.0 end 
 CNSsolve> 
 CNSsolve>     ! turn off all vdw and elec interactions between the charged beads within one residue 
 CNSsolve>     interaction (segid $cgsegid and resid $cgresid and name SCD1) 
 CNSsolve>                 (segid $cgsegid and resid $cgresid and name SCD2) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>   end 
 CNSsolve> 
 CNSsolve>end loop c1beads 
 CNSsolve> 
 CNSsolve>for $id1 in id ( (resn LYS or resn ARG or resn ASP or resn GLU) and name BB ) loop c2beads 
 SELRPN:      0 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>   show (segid) (id $id1) 
 CNSsolve>   evaluate ($cgsegid=$result) 
 CNSsolve>   show (resid) (id $id1) 
 CNSsolve>   evaluate ($cgresid=$result) 
 CNSsolve> 
 CNSsolve>   igroup 
 CNSsolve>     ! turn off all vdw interactions between charged beads and all beads 
 CNSsolve>     interaction (segid $cgsegid and resid $cgresid and name SCD1) (all) weight vdw 0.0 end 
 CNSsolve>   end 
 CNSsolve> 
 CNSsolve>end loop c2beads 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>flag include bond angle impr vdw end 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dihed eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  flag include dihed end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>do (fbeta=$Saprotocol.fbeta) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>do (mass=$Saprotocol.mass) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>do (mass=1000) (resn ani) 
 SELRPN:      0 atoms have been selected out of   3253
 CNSsolve>do (mass=1000) (resn xan) 
 SELRPN:      0 atoms have been selected out of   3253
 CNSsolve>do (mass=1000) (resn dan) 
 SELRPN:      0 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>evaluate ($end_count = $iterations.ini_count + $iterations.structures - 1) 
 EVALUATE: symbol $END_COUNT set to    200.000     (real)
 CNSsolve> 
 CNSsolve>if ($Data.noecv eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ($iteration = 0) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate ($npart = 1 + mod($count,$Data.ncvpart)) 
 EVALUATE: symbol $NPART set to    2.00000     (real)
 CNSsolve>    evaluate ($fileseed="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".seed") 
 EVALUATE: symbol $FILESEED set to "NEWIT:complex_1.seed" (string)
 CNSsolve>    evaluate ($seed = max($iteration,1)*$count*$Saprotocol.iniseed) 
 EVALUATE: symbol $SEED set to    917.000     (real)
 CNSsolve>  else 
 CNSsolve>    evaluate ($fileseed= $file - ".pdb" + ".seed") 
 CNSsolve>    @@$fileseed (seed=$seed;npart=$npart ) 
 CNSsolve>    evaluate ($fileseed="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".seed") 
 CNSsolve>    evaluate ($num = $count + $iterations.structures) 
 CNSsolve>    evaluate ($file_r_seed="NEWIT:" + $Filenames.fileroot + "_" + encode($num) + ".seed") 
 CNSsolve>    if ($saprotocol.rotate180_it1 eq true) then 
 CNSsolve>      set display=$file_r_seed end 
 CNSsolve>      display module(seed;npart) 
 CNSsolve>      display define ( 
 CNSsolve>      display currentseed = $seed; 
 CNSsolve>      display currentpart = $npart; 
 CNSsolve>      display ) 
 CNSsolve>      display evaluate (&seed=&currentseed) 
 CNSsolve>      display evaluate (&npart=&currentpart) 
 CNSsolve>      close $file_r_seed end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  set display=$fileseed end 
 ASSFIL: file complex_1.seed opened.
 CNSsolve>  display module(seed;npart) 
 CNSsolve>  display define ( 
 CNSsolve>  display currentseed = $seed; 
 CNSsolve>  display currentpart = $npart; 
 CNSsolve>  display ) 
 CNSsolve>  display evaluate (&seed=&currentseed) 
 CNSsolve>  display evaluate (&npart=&currentpart) 
 CNSsolve>  close $fileseed end 
 VCLOSE: Display file reset to OUTPUT.
 CNSsolve>else 
 CNSsolve>  evaluate ($seed = max($iteration,1)*$count*$Saprotocol.iniseed) 
 CNSsolve>end if 
 CNSsolve>set seed $seed end 
 CNSsolve> 
 CNSsolve>coor init end 
 COOR: selected main coordinates initialized
 CNSsolve>coor @@$file 
 ASSFIL: file complex_1.pdb opened.
 COOR>REMARK FILENAME="complex_1.pdb" 
 COOR>REMARK coordinates built for atom:      MET  1    HN 
 COOR>REMARK coordinates built for atom:      PHE  2    HN 
 COOR>REMARK coordinates built for atom:      TYR  3    HN 
 COOR>REMARK coordinates built for atom:      TYR  3    HH 
 COOR>REMARK coordinates built for atom:      ILE  4    HN 
 COOR>REMARK coordinates built for atom:      GLU  5    HN 
 COOR>REMARK coordinates built for atom:      ASP  6    HN 
 COOR>REMARK coordinates built for atom:      ILE  7    HN 
 COOR>REMARK coordinates built for atom:      LEU  8    HN 
 COOR>REMARK coordinates built for atom:      ALA  9    HN 
 COOR>REMARK DATE:08-Nov-2022  09:29:37       created by user: enmr 
 COOR>REMARK VERSION:1.3U 
 COOR>ATOM      1  N   ASP A 434      -3.167   6.841  73.086  1.00 15.00      A    N 
 COOR>ATOM      2  HN  ASP A 434      -2.420   6.418  73.558  1.00 15.00      A    H 
 CNSsolve> 
 CNSsolve>! reinitialize the DUM residue 
 CNSsolve>if ($Data.flags.centroids = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($iteration = 0) then 
 CNSsolve>        @RUN:protocols/centroids_initialize.cns 
 ASSFIL: file centroids_initialize.cns opened.
 CNSsolve>{Places DUM-residue on the center of each segid} 
 CNSsolve> 
 CNSsolve>eval($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    show ave(x) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.x = $RESULT) 
 CNSsolve>    show ave(y) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.y = $RESULT) 
 CNSsolve>    show ave(z) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.z = $RESULT) 
 CNSsolve> 
 CNSsolve>    do (x = $center.x) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>    do (y = $center.y) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>    do (z = $center.z) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>end loop nloop1 
 CNSsolve>    end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! check for the presence of ions and add covalent bond 
 CNSsolve>if ($iteration = 1) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  @RUN:protocols/covalions.cns 
 ASSFIL: file covalions.cns opened.
 CNSsolve>! covalions.cns 
 CNSsolve>!    Add a covalent bond between an ion and its closest coordinating atom 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>  evaluate ($pcount = 0) 
 CNSsolve>  for $id1 in id ( name "LI+1" or name "F-1"  or name "NA+1" or name "MG+2" or name "AL+3" 
 FOR-clause=                or name "CL-1" or name "K+1"  or name "CA+2" or name "V+2"  or name "V+3" 
 FOR-clause=                or name "CR+2" or name "CR+3" or name "MN+2" or name "MN+3" or name "FE+2" 
 FOR-clause=                or name "FE+3" or name "NI+2" or name "CO+2" or name "CO+3" or name "CU+1" 
 FOR-clause=                or name "CU+2" or name "ZN+2" or name "BR-1" or name "SR+2" or name "MO+3" 
 FOR-clause=                or name "AG+1" or name "CD+2" or name "I-1"  or name "CS+2" or name "HO+3" 
 FOR-clause=                or name "YB+2" or name "YB+3" or name "OS+4" or name "IR+3" or name "PT+2" 
 FOR-clause=                or name "AU+1" or name "AU+2" or name "HG+1" or name "HG+2" or name "PB+2" 
 FOR-clause=                or name "U+3"  or name "U+4"  or name "ZN+1" or name "ZN"  ) loop ions 
 CNSsolve> 
 CNSsolve>     show (segid) (id $id1) 
 CNSsolve>     evaluate ($segid1=$result) 
 CNSsolve>     show (resid) (id $id1) 
 CNSsolve>     evaluate ($resid1=$result) 
 CNSsolve>     show (resname) (id $id1) 
 CNSsolve>     evaluate ($resname1=$result) 
 CNSsolve>     show (name) (id $id1) 
 CNSsolve>     evaluate ($name1=$result) 
 CNSsolve>     show (chem) (id $id1) 
 CNSsolve>     evaluate ($chem1=$result) 
 CNSsolve> 
 CNSsolve>     evaluate ($mindis = 7.5) 
 CNSsolve>     evaluate ($minid  = 0) 
 CNSsolve>     for $id2 in id ( (name O* or name S* or name N*) and (id $id1) around $mindis and 
 FOR-clause=                      (resn ACE or resn ALA or resn ALY or resn ARG or resn ASN or resn ASH or resn ASP or 
 FOR-clause=                       resn CSP or resn CTN or resn CYC or resn CYF or resn CYM or resn CYS or resn DDZ or 
 FOR-clause=                       resn GLN or resn GLH or resn GLU or resn GLY or resn HIS or resn HY3 or resn HYP or 
 FOR-clause=                       resn ILE or resn LEU or resn LYS or resn M3L or resn MLY or resn MLZ or resn MET or 
 FOR-clause=                       resn MSE or resn NEP or resn NME or resn PHE or resn PNS or resn PRO or resn PTR or 
 FOR-clause=                       resn QSR or resn SEP or resn SER or resn THR or resn TOP or resn TRP or resn TYP or 
 FOR-clause=                       resn TYR or resn TYS or resn VAL or resn A   or resn C   or resn G   or resn T   or 
 FOR-clause=                       resn DA  or resn DC  or resn DG  or resn DT or resn DJ   )) loop search 
 CNSsolve> 
 CNSsolve>         pick bond (id $id1) (id $id2) geometry 
 CNSsolve> 
 CNSsolve>         if ( $result < $mindis) then 
 CNSsolve>           evaluate ($mindis = $result) 
 CNSsolve>           evaluate ($minid = $id2) 
 CNSsolve>         end if 
 CNSsolve> 
 CNSsolve>     end loop search 
 CNSsolve> 
 CNSsolve>     if ($minid> 0) then 
 CNSsolve>         show (segid) (id $minid) 
 CNSsolve>         evaluate ($segid2=$result) 
 CNSsolve>         show (resid) (id $minid) 
 CNSsolve>         evaluate ($resid2=$result) 
 CNSsolve>         show (resname) (id $minid) 
 CNSsolve>         evaluate ($resname2=$result) 
 CNSsolve>         show (name) (id $minid) 
 CNSsolve>         evaluate ($name2=$result) 
 CNSsolve>         show (chem) (id $minid) 
 CNSsolve>         evaluate ($chem2=$result) 
 CNSsolve> 
 CNSsolve>         evaluate ($pat1 = "1"+$name1) 
 CNSsolve>         evaluate ($pat2 = "2"+$name2) 
 CNSsolve>         evaluate ($pcount = $pcount + 1) 
 CNSsolve>         evaluate ($pname = "cb" + encode($pcount)) 
 CNSsolve>         topology 
 CNSsolve>           presidue $pname   ! Patch to add a covalent bond between two atoms 
 CNSsolve>             add bond $pat1 $pat2 
 CNSsolve>           end 
 CNSsolve>         end 
 CNSsolve>         patch $pname refe=1=(resid $resid1 and segid $segid1) refe=2=(resid $resid2 and segid $segid2) end 
 CNSsolve>         display COVALION: ADDED ONE COVALENT BOND BETWEEN $name1 $resid1 AND $name2 $resname2 $resid2 
 CNSsolve>     end if 
 CNSsolve> 
 CNSsolve>     param bond $chem1 $chem2 0.0 $mindis end 
 CNSsolve> 
 CNSsolve>   end loop ions 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>{* Find CoM of protein *} 
 CNSsolve>show ave (x) (name CA or name BB or name C1') 
 SELRPN:    346 atoms have been selected out of   3253
 SHOW: average of selected elements =     -18.057416
 CNSsolve>evaluate ($xcent=$result) 
 EVALUATE: symbol $XCENT set to   -18.0574     (real)
 CNSsolve>show ave (y) (name CA or name BB or name C1') 
 SELRPN:    346 atoms have been selected out of   3253
 SHOW: average of selected elements =       1.321462
 CNSsolve>evaluate ($ycent=$result) 
 EVALUATE: symbol $YCENT set to    1.32146     (real)
 CNSsolve>show ave (z) (name CA or name BB or name C1') 
 SELRPN:    346 atoms have been selected out of   3253
 SHOW: average of selected elements =      44.662052
 CNSsolve>evaluate ($zcent=$result) 
 EVALUATE: symbol $ZCENT set to    44.6621     (real)
 CNSsolve> 
 CNSsolve>coor select (not known and resn ani) end 
 SELRPN:      0 atoms have been selected out of   3253
 COOR: using atom subset.
 CNSsolve>if ($select gt 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  coor @@RUN:toppar/tensor.pdb 
 CNSsolve> 
 CNSsolve>  {* Find CoM of protein and move tensor 100 A away *} 
 CNSsolve>  show ave (x) (name CA or name BB or name C1') 
 CNSsolve>  evaluate ($xcent=$result) 
 CNSsolve>  show ave (y) (name CA or name BB or name C1') 
 CNSsolve>  evaluate ($ycent=$result) 
 CNSsolve>  show ave (z) (name CA or name BB or name C1') 
 CNSsolve>  evaluate ($zcent=$result) 
 CNSsolve>  do (x=x+$xcent+100) (resn ANI) 
 CNSsolve>  do (y=y+$ycent+100) (resn ANI) 
 CNSsolve>  do (z=z+$zcent+100) (resn ANI) 
 CNSsolve>  evaluate ($rantens = true) 
 CNSsolve>else 
 CNSsolve>  evaluate ($rantens = false) 
 EVALUATE: symbol $RANTENS set to FALSE (logical)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>coor select (not known and resn xan) end 
 SELRPN:      0 atoms have been selected out of   3253
 COOR: using atom subset.
 CNSsolve>if ($select gt 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  coor @@RUN:toppar/tensor_para.pdb 
 CNSsolve>  evaluate ($rantens_para = true) 
 CNSsolve>else 
 CNSsolve>  evaluate ($rantens_para = false) 
 EVALUATE: symbol $RANTENS_PARA set to FALSE (logical)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>coor select (not known and resn dan) end 
 SELRPN:      0 atoms have been selected out of   3253
 COOR: using atom subset.
 CNSsolve>if ($select gt 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  coor @@RUN:toppar/tensor_dani.pdb 
 CNSsolve> 
 CNSsolve>  {* Find CoM of protein and move tensor 100 A away *} 
 CNSsolve>  show ave (x) (name CA or name BB or name C1') 
 CNSsolve>  evaluate ($xcent=$result) 
 CNSsolve>  show ave (y) (name CA or name BB or name C1') 
 CNSsolve>  evaluate ($ycent=$result) 
 CNSsolve>  show ave (z) (name CA or name BB or name C1') 
 CNSsolve>  evaluate ($zcent=$result) 
 CNSsolve>  do (x=x+$xcent+100) (resn DAN) 
 CNSsolve>  do (y=y+$ycent+100) (resn DAN) 
 CNSsolve>  do (z=z+$zcent+100) (resn DAN) 
 CNSsolve>  evaluate ($rantens_dani = true) 
 CNSsolve>else 
 CNSsolve>  evaluate ($rantens_dani = false) 
 EVALUATE: symbol $RANTENS_DANI set to FALSE (logical)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!catch possible bound water and set high T steps to 0 
 CNSsolve>coor select ((resn WAT or resn HOH or resn TIP*)) end 
 SELRPN:      0 atoms have been selected out of   3253
 COOR: using atom subset.
 CNSsolve>if ($select gt 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($SaProtocol.initiosteps = 0) 
 CNSsolve>  evaluate ($SaProtocol.cool1_steps = 0) 
 CNSsolve>  evaluate ($refine.keepwater = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>do (refx=x) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>do (refy=y) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>do (refz=z) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>!set the energy flags: 
 CNSsolve>inline @RUN:protocols/setflags.cns 
 ASSFIL: file setflags.cns opened.
 CNSsolve>! setflags.cns 
 CNSsolve>!    Defines energy flags 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>if ($Data.cdih.on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   evaluate ($Data.flags.cdih =  true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($nrdc=1) 
 EVALUATE: symbol $NRDC set to    1.00000     (real)
 CNSsolve>while ($nrdc <= $Data.numrdc) loop rdc 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($Data.rdc_choice_$nrdc eq "SANI") then 
 CNSsolve>    evaluate ($Data.flags.sani = true) 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.rdc_choice_$nrdc eq "VANGLE") then 
 CNSsolve>    evaluate ($Data.flags.vean = true) 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.rdc_choice_$nrdc eq "XRDC") then 
 CNSsolve>    evaluate ($Data.flags.xrdc = true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($nrdc=$nrdc+1) 
 CNSsolve>end loop rdc 
 CNSsolve> 
 CNSsolve>evaluate ($ndani=1) 
 EVALUATE: symbol $NDANI set to    1.00000     (real)
 CNSsolve>while ($ndani <= $Data.numdani) loop dani 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($Data.dan_choice_$ndani eq "DANI") then 
 CNSsolve>     evaluate ($Data.flags.DANI = true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($ndani=$ndani+1) 
 CNSsolve>end loop dani 
 CNSsolve> 
 CNSsolve>evaluate ($npcs=1) 
 EVALUATE: symbol $NPCS set to    1.00000     (real)
 CNSsolve>while ($npcs <= $Data.numpcs) loop pcs 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($Data.pcs_choice_$npcs eq "XPCS") then 
 CNSsolve>     evaluate ($Data.flags.XPCS = true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($npcs=$npcs+1) 
 CNSsolve>end loop pcs 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.harm = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.harm = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.noe  =  TRUE) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   flags include noe end 
 CNSsolve>elseif ($Data.flags.centroids = true) then 
 CNSsolve>    flags include noe end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.cdih =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include cdih end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.vean =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include vean end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.sani =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include sani end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.xrdc =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include xrdc end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.xpcs =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include xpcs end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include dani end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.plan =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include plan end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.ncs  =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include ncs end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.rg = TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($data.rgtarg > 0) then 
 CNSsolve>    flags include coll end 
 CNSsolve>  else 
 CNSsolve>    evaluate ($Data.flags.rg = false) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!read all the experimental Data: 
 CNSsolve>evaluate ($lcc = 0) 
 EVALUATE: symbol $LCC set to    0.00000     (real)
 CNSsolve>set seed $seed end 
 CNSsolve>set message=normal echo=on end 
 CNSsolve>if ($data.waterdock eq false) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    inline @RUN:protocols/read_data.cns 
 ASSFIL: file read_data.cns opened.
 CNSsolve>! read_data.cns 
 CNSsolve>!    Read the various restraints data 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>!module(Iteration; Data; count;) 
 CNSsolve> 
 CNSsolve>!NOEs, hbonds 
 CNSsolve>noe 
 NOE>  reset 
 NOE>  nrestraints = 12000000     ! allocate space for NOEs 
 NOE: allocating space for ******* restraints.
 NOE>  ceiling 1000 
 NOE>end 
 CNSsolve> 
 CNSsolve>if ($Data.amb_lastit ge $Iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ($Data.amb_firstit le $Iteration)   then 
 NEXTCD: condition evaluated as true
 CNSsolve>     evaluate ($filenam0 = "NEWIT:ambig.tbl_" + encode($count)) 
 EVALUATE: symbol $FILENAM0 set to "NEWIT:ambig.tbl_1" (string)
 CNSsolve>     fileexist $filenam0 end 
 MISCOM: file does not exist
 CNSsolve>     if ($result eq false) then 
 NEXTCD: condition evaluated as true
 CNSsolve>       evaluate ($filenam0 = "NEWIT:ambig.tbl") 
 EVALUATE: symbol $FILENAM0 set to "NEWIT:ambig.tbl" (string)
 CNSsolve>     end if 
 CNSsolve>     noe class ambi @@$filenam0 end 
 ASSFIL: file ambig.tbl opened.
 CNSsolve>     if ($Data.noecv eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>       noe part $Data.ncvpart end 
 Data are not partitioned or partitioning removed.
 CNSsolve>     end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.unamb_lastit ge $Iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ($Data.unamb_firstit le $Iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>     noe class dist @@NEWIT:unambig.tbl end 
 ASSFIL: file unambig.tbl opened.
 NOE>assign (resid 2 and name ca)  (resid 661 and name ca)   9.9 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 2 and name ca)  (resid 636 and name ca)   8.4 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 2 and name ca)  (resid 618 and name ca)   8.0 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 2 and name ca)  (resid 594 and name ca)   8.3 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 3 and name ca)  (resid 620 and name ca)  10.9 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 3 and name ca)  (resid 578 and name ca)   9.1 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 3 and name ca)  (resid 534 and name ca)   9.4 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 4 and name ca)  (resid 578 and name ca)  10.0 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 4 and name ca)  (resid 532 and name ca)   7.2 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 4 and name ca)  (resid 488 and name ca)   7.8 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 5 and name ca)  (resid 488 and name ca)  11.0 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 5 and name ca)  (resid 743 and name ca)  12.0 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 6 and name ca)  (resid 661 and name ca)  13.3 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 6 and name ca)  (resid 700 and name ca)  12.6 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 7 and name ca)  (resid 718 and name ca)   8.5 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 7 and name ca)  (resid 702 and name ca)   9.3 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 7 and name ca)  (resid 700 and name ca)   9.3 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 8 and name ca)  (resid 743 and name ca)   9.4 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 8 and name ca)  (resid 759 and name ca)   7.4 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 8 and name ca)  (resid 741 and name ca)   8.0 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 9 and name ca)  (resid 700 and name ca)  13.4 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 9 and name ca)  (resid 741 and name ca)  11.2 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 9 and name ca)  (resid 743 and name ca)  13.2 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE>assign (resid 9 and name ca)  (resid 487 and name ca)  14.9 0.1 0.1 
 SELRPN:      1 atoms have been selected out of   3253
 SELRPN:      1 atoms have been selected out of   3253
 NOE> end 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.hbond_lastit ge $Iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ($Data.hbond_firstit le $Iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if ($Data.hbonds_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      noe @@RUN:data/hbonds/hbonds.tbl end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>noe 
 NOE>  averaging  * sum 
 NOE>  potential  * soft 
 NOE>  scale      * 1.0 
 NOE>  sqconstant * 1.0 
 NOE>  sqexponent * 2 
 NOE>  soexponent * 1 
 NOE>  rswitch    * 1.0 
 NOE>  sqoffset   * 0.0 
 NOE>  asymptote  * 2.0 
 NOE>  msoexponent * 1 
 NOE>  masymptote  * -0.1 
 NOE>  mrswitch    * 1.0 
 NOE>  avexpo hbond 20 
 NOE>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve>!dihedral restraints: 
 CNSsolve>restraints dihedral 
 DIHEDRAL>   reset 
 DIHEDRAL>   nassign 10000 
 RSTDIH: allocating space for   10000 assignments.
 DIHEDRAL>end 
 CNSsolve>if ($Data.cdih.on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  restraints dihedral 
 CNSsolve>    @@RUN:data/dihedrals/dihedrals.tbl 
 CNSsolve>  end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>restraints dihedral ? end 
 Total number of dihedral angle restraints=     0
  overall scale =    1.0000
 Number of dihedral angle restraints=    0
 RMS deviation=   0.000
 CNSsolve> 
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve>!residual dipolar couplings: 
 CNSsolve> 
 CNSsolve>evaluate ($Data.flags.sani = false) 
 EVALUATE: symbol $DATA.FLAGS.SANI set to FALSE (logical)
 CNSsolve>evaluate ($Data.flags.xrdc = false) 
 EVALUATE: symbol $DATA.FLAGS.XRDC set to FALSE (logical)
 CNSsolve>evaluate ($Data.flags.xpcs = false) 
 EVALUATE: symbol $DATA.FLAGS.XPCS set to FALSE (logical)
 CNSsolve>evaluate ($Data.flags.dani = false) 
 EVALUATE: symbol $DATA.FLAGS.DANI set to FALSE (logical)
 CNSsolve>evaluate ($Data.flags.vean = false) 
 EVALUATE: symbol $DATA.FLAGS.VEAN set to FALSE (logical)
 CNSsolve>evaluate ($inisani=0) 
 EVALUATE: symbol $INISANI set to    0.00000     (real)
 CNSsolve>evaluate ($inixrdc=0) 
 EVALUATE: symbol $INIXRDC set to    0.00000     (real)
 CNSsolve>evaluate ($inixpcs=0) 
 EVALUATE: symbol $INIXPCS set to    0.00000     (real)
 CNSsolve>evaluate ($inidani=0) 
 EVALUATE: symbol $INIDANI set to    0.00000     (real)
 CNSsolve>evaluate ($inivean = 0) 
 EVALUATE: symbol $INIVEAN set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>sani reset nres=5000 end 
SANI: Allocating space for    5000
number of constraints 
 CNSsolve>vean reset nres=10000 end 
 CNSsolve>xrdc reset nres=5000 end 
XDIPO_RDC: Allocating space for    5000number of restraints.
 CNSsolve>evaluate ($nrdc=1) 
 EVALUATE: symbol $NRDC set to    1.00000     (real)
 CNSsolve>while ($nrdc <= $Data.numrdc) loop rdc 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($cln="rd"+encode($nrdc)) 
 CNSsolve>  if ($Data.rdc_lastit_$nrdc ge $Iteration) then 
 CNSsolve>    if ($Data.rdc_firstit_$nrdc le $Iteration) then 
 CNSsolve>      if ($Data.rdc_choice_$nrdc eq "SANI") then 
 CNSsolve>        evaluate ($Data.flags.sani = true) 
 CNSsolve>	evaluate ($restfile="RUN:data/rdcs/rdc"+encode($nrdc)+".tbl") 
 CNSsolve>        evaluate ($inisani=1) 
 CNSsolve>        sani 
 CNSsolve>          class $cln 
 CNSsolve>          force 0.0 
 CNSsolve>          potential square 
 CNSsolve>          @@$restfile 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>      if ($Data.rdc_choice_$nrdc eq "XRDC") then 
 CNSsolve>        evaluate ($Data.flags.xrdc = true) 
 CNSsolve>	evaluate ($restfile="RUN:data/rdcs/rdc"+encode($nrdc)+".tbl") 
 CNSsolve>        evaluate ($inixrdc=1) 
 CNSsolve>        xrdc 
 CNSsolve>          class $cln 
 CNSsolve>          force 0.0 
 CNSsolve>          @@$restfile 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>      if ($Data.rdc_choice_$nrdc eq "VANGLE") then 
 CNSsolve>        evaluate ($Data.flags.vean = true) 
 CNSsolve>	evaluate ($restfile="RUN:data/rdcs/rdc"+encode($nrdc)+".tbl") 
 CNSsolve>        evaluate ($inivean = 1) 
 CNSsolve>        if ($Data.rdc_firstIt_$nrdc le $Iteration) then 
 CNSsolve>          vean 
 CNSsolve>            class $cln 
 CNSsolve>            force 0.0 0.0 
 CNSsolve>            @@$restfile 
 CNSsolve>          end 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($nrdc = $nrdc + 1) 
 CNSsolve>end loop rdc 
 CNSsolve> 
 CNSsolve>evaluate ($tensread = false) 
 EVALUATE: symbol $TENSREAD set to FALSE (logical)
 CNSsolve>if ($Data.flags.xrdc = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  noe 
 CNSsolve>    class tens 
 CNSsolve>    @@RUN:data/tensor/tensor.tbl 
 CNSsolve>    potential tens square 
 CNSsolve>    scale     tens 500.0 
 CNSsolve>  end 
 CNSsolve>  evaluate ($tensread = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve>!PCS restraints: 
 CNSsolve>xpcs reset nres=5000 end 
XDIPO_PCS: Allocating space for    5000number of restraints.
 CNSsolve>evaluate ($npcs=1) 
 EVALUATE: symbol $NPCS set to    1.00000     (real)
 CNSsolve>while ($npcs <= $Data.numpcs) loop pcs 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($Data.pcs_lastit_$npcs ge $Iteration) then 
 CNSsolve>    if ($Data.pcs_firstit_$npcs le $Iteration) then 
 CNSsolve>      if ($Data.pcs_choice_$npcs eq "XPCS") then 
 CNSsolve>        evaluate ($Data.flags.xpcs = true) 
 CNSsolve>	evaluate ($restfile="RUN:data/pcs/pcs"+encode($npcs)+".tbl") 
 CNSsolve>	evaluate ($cln="pc"+encode($npcs)) 
 CNSsolve>        evaluate ($inixpcs=1) 
 CNSsolve>        xpcs 
 CNSsolve>          class $cln 
 CNSsolve>          force 0.0 
 CNSsolve>          @@$restfile 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($npcs= $npcs + 1) 
 CNSsolve>end loop pcs 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($tensread eq FALSE) then 
 CNSsolve>    noe 
 CNSsolve>      class tens 
 CNSsolve>      @@RUN:data/tensor/tensor.tbl 
 CNSsolve>      potential tens square 
 CNSsolve>      scale     tens 500.0 
 CNSsolve>    end 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve>!DANI restraints: 
 CNSsolve> 
 CNSsolve>evaluate ($ndani=1) 
 EVALUATE: symbol $NDANI set to    1.00000     (real)
 CNSsolve>dani reset nres=5000 end 
DANI: Allocating space for    5000
number of constraints 
 CNSsolve>while ($ndani <= $Data.numdani) loop dani 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($Data.dan_lastit_$ndani ge $Iteration) then 
 CNSsolve>    if ($Data.dan_firstit_$ndani le $Iteration) then 
 CNSsolve>      if ($Data.dan_choice_$ndani eq "DANI") then 
 CNSsolve>        evaluate ($Data.flags.dani = true) 
 CNSsolve>	evaluate ($restfile="RUN:data/dani/dani"+encode($ndani)+".tbl") 
 CNSsolve>	evaluate ($cln="da"+encode($ndani)) 
 CNSsolve>        evaluate ($inidani=1) 
 CNSsolve>        dani 
 CNSsolve>          class $cln 
 CNSsolve>          force 0.0 
 CNSsolve>          potential square 
 CNSsolve>          @@$restfile 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($ndani = $ndani + 1) 
 CNSsolve>end loop dani 
 CNSsolve>    if ($data.flags.em = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>        @RUN:protocols/em_read_data.cns(Data=$data;) 
 ASSFIL: file em_read_data.cns opened.
 CNSsolve>module (Data;) 
 CNSsolve>    {* 
 CNSsolve>    Module reads in the cryoEM data, supposed to be the CryoEM map. Since CNS 
 CNSsolve>    is mainly build for X-ray Crystallography and thus reciprocal space, 
 CNSsolve>    working in real space is a bit cumbersome. Therefor we first determine the 
 CNSsolve>    map size and such befor reading it in. The unit cell is determined first 
 CNSsolve>    and the resolution cutoff.  After that the FFT parameters can be determined 
 CNSsolve>    and space is generated for the reflections. 
 CNSsolve> 
 CNSsolve>    It follows with reading in the form factors for all the atoms. The arrays 
 CNSsolve>    FOBS, FCALC, FPART and MAP are allocated. The CryoEM map is read and the 
 CNSsolve>    target function is set, which is here the so called vector potential. The 
 CNSsolve>    vector potential is the reciprocal space variant of the cross correlation 
 CNSsolve>    between two maps. 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    Data : Data object 
 CNSsolve>        The Data object holds all the parameter for the CryoEM functionality 
 CNSsolve> 
 CNSsolve>    Notes 
 CNSsolve>    ----- 
 CNSsolve>    After the call of this module one is able to use the XREF energy flag at will. 
 CNSsolve> 
 CNSsolve>    Examples 
 CNSsolve>    -------- 
 CNSsolve>    >>> ! Use the XREF energy term 
 CNSsolve>    >>> @RUN:protocols/em_read_data.cns(Data=&Data;) 
 CNSsolve>    >>> flags include XREF end 
 CNSsolve>    *} 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>        ! Set unit cell parameters. The angles are implicitely assumed to be 90' 
 CNSsolve>        symmetry=(x, y, z) 
 CNSsolve>        a=&Data.em.xlength 
 CNSsolve>        b=&Data.em.ylength 
 CNSsolve>        c=&Data.em.zlength 
 CNSsolve> 
 CNSsolve>        ! set target resolution 
 CNSsolve>        mapresolution &Data.em.resolution 
 CNSsolve> 
 CNSsolve>        ! set up FFT 
 CNSsolve>        method=FFT 
 CNSsolve>        evaluate($voxelspacing = &Data.em.xlength / &Data.em.nx) 
 CNSsolve>        evaluate($gridsize = $voxelspacing/&Data.em.resolution) 
 CNSsolve>        fft 
 CNSsolve>            automemory=true 
 CNSsolve>            gridsize=$gridsize 
 CNSsolve>            bscale=100 
 CNSsolve>            elimit=9 
 CNSsolve>            prime=5 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! allocate space for the reflections. 
 CNSsolve>        generate 100000 &Data.em.resolution 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    xray 
 CNSsolve>        ! read in atomic form factors 
 CNSsolve>        @RUN:toppar/scatter.lib 
 ASSFIL: file scatter.lib opened.
 CNSsolve>! file libraries/xray/scatter.lib 
 CNSsolve>! Atomic scattering factors without anomalous contribution 
 CNSsolve>! Library for CNS 
 CNSsolve> 
 CNSsolve>! Authors: Paul Adams, Joe Jaeger, and Axel T. Brunger 
 CNSsolve> 
 CNSsolve>!BEWARE: 
 CNSsolve>!(1) element Cf (Californium) has to be referred to as Cff 
 CNSsolve>!(2) element Sm (Samarium) has to be referred to as Smm 
 CNSsolve>!(3) element Np (Neptunium) has to be referred to as Npp 
 CNSsolve>!(3) types of elements with ionic state (i.e., +/-) specifications have 
 CNSsolve>!    to be put in double quotes in selection statements. 
 CNSsolve> 
 CNSsolve>set message ? end 
 CNSsolve>evaluate ($message_old_sclib=$result) 
 CNSsolve>set echo ? end 
 CNSsolve>evaluate ($echo_old_sclib=$result) 
 CNSsolve>set echo=off message=off end 
 CNSsolve> 
 CNSsolve> checkversion 1.3 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>SCATter ( chemical H* and not ( 
 CNSsolve>          chemical "He" or chemical "HE" or 
 CNSsolve>          chemical "Ho" or chemical "HO" or 
 CNSsolve>          chemical "Ho+3" or chemical "HO+3" or 
 CNSsolve>          chemical "Hf" or chemical "HF" or 
 CNSsolve>          chemical "Hf+4" or chemical "HF+4" or 
 CNSsolve>          chemical "Hg" or chemical "HG" or 
 CNSsolve>          chemical "Hg+1" or chemical "HG+1" or 
 CNSsolve>          chemical "Hg+2" or chemical "HG+2" )) 
 CNSsolve>  0.489918 20.6593 0.262003 7.74039 0.196767 49.5519 0.049879 2.20159 0.001305 
 CNSsolve>SCATter ( chemical "He" or chemical "HE" ) 
 CNSsolve>  0.8734 9.1037 0.6309 3.3568 0.3112 22.9276 0.178 0.9821 0.0064 
 CNSsolve>SCATter ( chemical "Li" or chemical "LI" ) 
 CNSsolve>  1.1282 3.9546 0.7508 1.0524 0.6175 85.3905 0.4653 168.261 0.0377 
 CNSsolve>SCATter ( chemical "Li+1" or chemical "LI+1" ) 
 CNSsolve>  0.6968 4.6237 0.7888 1.9557 0.3414 0.6316 0.1563 10.0953 0.0167 
 CNSsolve>SCATter ( chemical "Be" or chemical "BE" ) 
 CNSsolve>  1.5919 43.6427 1.1278 1.8623 0.5391 103.483 0.7029 0.542 0.0385 
 CNSsolve>SCATter ( chemical "Be+2" or chemical "BE+2" ) 
 CNSsolve>  6.2603 0.0027 0.8849 0.8313 0.7993 2.2758 0.1647 5.1146 -6.1092 
 CNSsolve>SCATter ( chemical "B" ) 
 CNSsolve>  2.0545 23.2185 1.3326 1.021 1.0979 60.3498 0.7068 0.1403 -0.1932 
 CNSsolve>SCATter ( chemical C* and not 
 CNSsolve>        ( chem "Ca" or chem "CA" or chem "Ca+2" or chem "CA+2" or 
 CNSsolve>          chem "Ce" or chem "CE" or chem "Ce+3" or chem "CE+3" or chem "Ce+4" or chem "CE+4" or 
 CNSsolve>          chem "Co" or chem "CO" or chem "Co+2" or chem "CO+2" or chem "Co+3" or chem "CO+3" or 
 CNSsolve>          chem "Cr" or chem "CR" or chem "Cr+2" or chem "CR+2" or chem "Cr+3" or chem "CR+3" or 
 CNSsolve>          chem "Cu" or chem "CU" or chem "Cu+1" or chem "CU+1" or chem "Cu+2" or chem "CU+2" or 
 CNSsolve>          chem "Cd" or chem "CD" or chem "Cd+2" or chem "CD+2" or 
 CNSsolve>          chem "Cs" or chem "CS" or chem "Cs+1" or chem "CS+1" or 
 CNSsolve>          chem "Cm" or chem "CM" or 
 CNSsolve>          chem "Cl" or chem "CL" or chem "Cl-1" or chem "CL-1" or 
 CNSsolve>          chem "Cff" or chem "CFF" or chem "Cval" or chem "CVAL" )) 
 CNSsolve>  2.31 20.8439 1.02 10.2075 1.5886 0.5687 0.865 51.6512 0.2156 
 CNSsolve>SCATter ( chemical "Cval" or chemical "CVAL" ) 
 CNSsolve>  2.26069 22.6907 1.56165 0.656665 1.05075 9.75618 0.839259 55.5949 0.286977 
 CNSsolve>SCATter ( chemical N* and not 
 CNSsolve>        ( chem "Ne" or chem "NE" or 
 CNSsolve>          chem "Na" or chem "NA" or chem "Na+1" or chem "NA+1" or 
 CNSsolve>          chem "Ni" or chem "NI" or chem "Ni+2" or chem "NI+2" or chem "Ni+3" or chem "NI+3" or 
 CNSsolve>          chem "Nb" or chem "NB" or chem "Nb+3" or chem "NB+3" or chem "Nb+5" or chem "NB+5" or 
 CNSsolve>          chem "Nd" or chem "ND" or chem "Nd+3" or chem "ND+3" or 
 CNSsolve>          chem "Npp" or chem "NPP" or chem "Np+3" or chem "NP+3" or chem "Np+4" or chem "NP+4" or 
 CNSsolve>          chem "Np+6" or chem "NP+6" )) 
 CNSsolve>  12.2126 0.0057 3.1322 9.8933 2.0125 28.9975 1.1663 0.5826 -11.529 
 CNSsolve>SCATter ( chemical O* and not ( chem "O-1" or chem "Os" or chem "OS" or chem "Os+4" or chem "OS+4" ) ) 
 CNSsolve>  3.0485 13.2771 2.2868 5.7011 1.5463 0.3239 0.867 32.9089 0.2508 
 CNSsolve>SCATter ( chemical "O-1" ) 
 CNSsolve>  4.1916 12.8573 1.63969 4.17236 1.52673 47.0179 -20.307 -0.01404 21.9412 
 CNSsolve>SCATter ( chemical "F" ) 
 CNSsolve>  3.5392 10.2825 2.6412 4.2944 1.517 0.2615 1.0243 26.1476 0.2776 
 CNSsolve>SCATter ( chemical "F-1" ) 
 CNSsolve>  3.6322 5.27756 3.51057 14.7353 1.26064 0.442258 0.940706 47.3437 0.653396 
 CNSsolve>SCATter ( chemical "Ne" or chemical "NE" ) 
 CNSsolve>  3.9553 8.4042 3.1125 3.4262 1.4546 0.2306 1.1251 21.7184 0.3515 
 CNSsolve>SCATter ( chemical "Na" or chemical "NA" ) 
 CNSsolve>  4.7626 3.285 3.1736 8.8422 1.2674 0.3136 1.1128 129.424 0.676 
 CNSsolve>SCATter ( chemical "Na+1" or chemical "NA+1" ) 
 CNSsolve>  3.2565 2.6671 3.9362 6.1153 1.3998 0.2001 1.0032 14.039 0.404 
 CNSsolve>SCATter ( chemical "Mg" or chemical "MG" ) 
 CNSsolve>  5.4204 2.8275 2.1735 79.2611 1.2269 0.3808 2.3073 7.1937 0.8584 
 CNSsolve>SCATter ( chemical "Mg+2" or chemical "MG+2" ) 
 CNSsolve>  3.4988 2.1676 3.8378 4.7542 1.3284 0.185 0.8497 10.1411 0.4853 
 CNSsolve>SCATter ( chemical "Al" or chemical "AL" ) 
 CNSsolve>  6.4202 3.0387 1.9002 0.7426 1.5936 31.5472 1.9646 85.0886 1.1151 
 CNSsolve>SCATter ( chemical "Al+3" or chemical "AL+3" ) 
 CNSsolve>  4.17448 1.93816 3.3876 4.14553 1.20296 0.228753 0.528137 8.28524 0.706786 
 CNSsolve>SCATter ( chemical "Si" or chemical "SI" ) 
 CNSsolve>  6.2915 2.4386 3.0353 32.3337 1.9891 0.6785 1.541 81.6937 1.1407 
 CNSsolve>SCATter ( chemical "Siv" or chemical "SIV" ) 
 CNSsolve>  5.66269 2.6652 3.07164 38.6634 2.62446 0.916946 1.3932 93.5458 1.24707 
 CNSsolve>SCATter ( chemical "Si+4" or chemical "SI+4" ) 
 CNSsolve>  4.43918 1.64167 3.20345 3.43757 1.19453 0.2149 0.41653 6.65365 0.746297 
 CNSsolve>SCATter ( chemical P* and not ( 
 CNSsolve>          chem "Pd" or chem "Pr" or chem "Pm" or chem "Pt" or 
 CNSsolve>          chem "Pb" or chem "Po" or chem "Pa" or chem "Pu" or 
 CNSsolve>          chem "PD" or chem "PR" or chem "PM" or chem "PT" or 
 CNSsolve>          chem "PB" or chem "PO" or chem "PA" or chem "PU" or 
 CNSsolve>          chem "Pr+3" or chem "PR+3" or 
 CNSsolve>          chem "Pr+4" or chem "PR+4" or 
 CNSsolve>          chem "Pm+3" or chem "PM+3" or 
 CNSsolve>          chem "Pt+2" or chem "PT+2" or 
 CNSsolve>          chem "Pt+4" or chem "PT+4" or 
 CNSsolve>          chem "Pb+2" or chem "PB+2" or 
 CNSsolve>          chem "Pb+4" or chem "PB+4" or 
 CNSsolve>          chem "Pu+3" or chem "PU+3" or 
 CNSsolve>          chem "Pu+4" or chem "PU+4" or 
 CNSsolve>          chem "Pu+6" or chem "PU+6" )) 
 CNSsolve>  6.4345 1.9067 4.1791 27.157 1.78 0.526 1.4908 68.1645 1.1149 
 CNSsolve>SCATter ( chemical S* and not ( 
 CNSsolve>          chem "Sc" or chem "SC" or chem "Sc+3" or chem "SC+3" or 
 CNSsolve>          chem "Se" or chem "SE" or 
 CNSsolve>          chem "Sr" or chem "SR" or chem "Sr+2" or chem "SR+2" or 
 CNSsolve>          chem "Sn" or chem "SN" or chem "Sn+2" or chem "SN+2" or chem "Sn+4" or chem "SN+4" or 
 CNSsolve>          chem "Sb" or chem "SB" or chem "Sb+3" or chem "SB+3" or chem "Sb+5" or chem "SB+5" or 
 CNSsolve>          chem "Smm" or chem "SMM" or chem "Sm+3" or chem "SM+3" or 
 CNSsolve>          chem "Si" or chem "SI" or chem "Si+4" or chem "SI+4"  )) 
 CNSsolve>  6.9053 1.4679 5.2034 22.2151 1.4379 0.2536 1.5863 56.172 0.8669 
 CNSsolve>SCATter ( chemical "Cl" or chemical "CL" ) 
 CNSsolve>  11.4604 0.0104 7.1964 1.1662 6.2556 18.5194 1.6455 47.7784 -9.5574 
 CNSsolve>SCATter ( chemical "Cl-1" or chemical "CL-1" ) 
 CNSsolve>  18.2915 0.0066 7.2084 1.1717 6.5337 19.5424 2.3386 60.4486 -16.378 
 CNSsolve>SCATter ( chemical "Ar" or chemical "AR" ) 
 CNSsolve>  7.4845 0.9072 6.7723 14.8407 0.6539 43.8983 1.6442 33.3929 1.4445 
 CNSsolve>SCATter ( chemical "K" ) 
 CNSsolve>  8.2186 12.7949 7.4398 0.7748 1.0519 213.187 0.8659 41.6841 1.4228 
 CNSsolve>SCATter ( chemical "K+1" ) 
 CNSsolve>  7.9578 12.6331 7.4917 0.7674 6.359 -0.002 1.1915 31.9128 -4.9978 
 CNSsolve>SCATter ( chemical "Ca" or chemical "CA" ) 
 CNSsolve>  8.6266 10.4421 7.3873 0.6599 1.5899 85.7484 1.0211 178.437 1.3751 
 CNSsolve>SCATter ( chemical "Ca+2" or chemical "CA+2" ) 
 CNSsolve>  15.6348 -0.0074 7.9518 0.6089 8.4372 10.3116 0.8537 25.9905 -14.875 
 CNSsolve>SCATter ( chemical "Sc" or chemical "SC" ) 
 CNSsolve>  9.189 9.0213 7.3679 0.5729 1.6409 136.108 1.468 51.3531 1.3329 
 CNSsolve>SCATter ( chemical "Sc+3" or chemical "SC+3" ) 
 CNSsolve>  13.4008 0.29854 8.0273 7.9629 1.65943 -0.28604 1.57936 16.0662 -6.6667 
 CNSsolve>SCATter ( chemical "Ti" or chemical "TI" ) 
 CNSsolve>  9.7595 7.8508 7.3558 0.5 1.6991 35.6338 1.9021 116.105 1.2807 
 CNSsolve>SCATter ( chemical "Ti+2" or chemical "TI+2" ) 
 CNSsolve>  9.11423 7.5243 7.62174 0.457585 2.2793 19.5361 0.087899 61.6558 0.897155 
 CNSsolve>SCATter ( chemical "Ti+3" or chemical "TI+3" ) 
 CNSsolve>  17.7344 0.22061 8.73816 7.04716 5.25691 -0.15762 1.92134 15.9768 -14.652 
 CNSsolve>SCATter ( chemical "Ti+4" or chemical "TI+4" ) 
 CNSsolve>  19.5114 0.178847 8.23473 6.67018 2.01341 -0.29263 1.5208 12.9464 -13.28 
 CNSsolve>SCATter ( chemical "V" ) 
 CNSsolve>  10.2971 6.8657 7.3511 0.4385 2.0703 26.8938 2.0571 102.478 1.2199 
 CNSsolve>SCATter ( chemical "V+2" ) 
 CNSsolve>  10.106 6.8818 7.3541 0.4409 2.2884 20.3004 0.0223 115.122 1.2298 
 CNSsolve>SCATter ( chemical "V+3" ) 
 CNSsolve>  9.43141 6.39535 7.7419 0.383349 2.15343 15.1908 0.016865 63.969 0.656565 
 CNSsolve>SCATter ( chemical "V+5" ) 
 CNSsolve>  15.6887 0.679003 8.14208 5.40135 2.03081 9.97278 -9.576 0.940464 1.7143 
 CNSsolve>SCATter ( chemical "Cr" or chemical "CR" ) 
 CNSsolve>  10.6406 6.1038 7.3537 0.392 3.324 20.2626 1.4922 98.7399 1.1832 
 CNSsolve>SCATter ( chemical "Cr+2" or chemical "CR+2" ) 
 CNSsolve>  9.54034 5.66078 7.7509 0.344261 3.58274 13.3075 0.509107 32.4224 0.616898 
 CNSsolve>SCATter ( chemical "Cr+3" or chemical "CR+3" ) 
 CNSsolve>  9.6809 5.59463 7.81136 0.334393 2.87603 12.8288 0.113575 32.8761 0.518275 
 CNSsolve>SCATter ( chemical "Mn" or chemical "MN" ) 
 CNSsolve>  11.2819 5.3409 7.3573 0.3432 3.0193 17.8674 2.2441 83.7543 1.0896 
 CNSsolve>SCATter ( chemical "Mn+2" or chemical "MN+2" ) 
 CNSsolve>  10.8061 5.2796 7.362 0.3435 3.5268 14.343 0.2184 41.3235 1.0874 
 CNSsolve>SCATter ( chemical "Mn+3" or chemical "MN+3" ) 
 CNSsolve>  9.84521 4.91797 7.87194 0.294393 3.56531 10.8171 0.323613 24.1281 0.393974 
 CNSsolve>SCATter ( chemical "Mn+4" or chemical "MN+4" ) 
 CNSsolve>  9.96253 4.8485 7.97057 0.283303 2.76067 10.4852 0.054447 27.573 0.251877 
 CNSsolve>SCATter ( chemical "Fe" or chemical "FE" ) 
 CNSsolve>  11.7695 4.7611 7.3573 0.3072 3.5222 15.3535 2.3045 76.8805 1.0369 
 CNSsolve>SCATter ( chemical "Fe+2" or chemical "FE+2" ) 
 CNSsolve>  11.0424 4.6538 7.374 0.3053 4.1346 12.0546 0.4399 31.2809 1.0097 
 CNSsolve>SCATter ( chemical "Fe+3" or chemical "FE+3" ) 
 CNSsolve>  11.1764 4.6147 7.3863 0.3005 3.3948 11.6729 0.0724 38.5566 0.9707 
 CNSsolve>SCATter ( chemical "Co" or chemical "CO" ) 
 CNSsolve>  12.2841 4.2791 7.3409 0.2784 4.0034 13.5359 2.3488 71.1692 1.0118 
 CNSsolve>SCATter ( chemical "Co+2" or chemical "CO+2" ) 
 CNSsolve>  11.2296 4.1231 7.3883 0.2726 4.7393 10.2443 0.7108 25.6466 0.9324 
 CNSsolve>SCATter ( chemical "Co+3" or chemical "CO+3" ) 
 CNSsolve>  10.338 3.90969 7.88173 0.238668 4.76795 8.35583 0.725591 18.3491 0.286667 
 CNSsolve>SCATter ( chemical "Ni" or chemical "NI" ) 
 CNSsolve>  12.8376 3.8785 7.292 0.2565 4.4438 12.1763 2.38 66.3421 1.0341 
 CNSsolve>SCATter ( chemical "Ni+2" or chemical "NI+2" ) 
 CNSsolve>  11.4166 3.6766 7.4005 0.2449 5.3442 8.873 0.9773 22.1626 0.8614 
 CNSsolve>SCATter ( chemical "Ni+3" or chemical "NI+3" ) 
 CNSsolve>  10.7806 3.5477 7.75868 0.22314 5.22746 7.64468 0.847114 16.9673 0.386044 
 CNSsolve>SCATter ( chemical "Cu" or chemical "CU" ) 
 CNSsolve>  13.338 3.5828 7.1676 0.247 5.6158 11.3966 1.6735 64.8126 1.191 
 CNSsolve>SCATter ( chemical "Cu+1" or chemical "CU+1" ) 
 CNSsolve>  11.9475 3.3669 7.3573 0.2274 6.2455 8.6625 1.5578 25.8487 0.89 
 CNSsolve>SCATter ( chemical "Cu+2" or chemical "CU+2" ) 
 CNSsolve>  11.8168 3.37484 7.11181 0.244078 5.78135 7.9876 1.14523 19.897 1.14431 
 CNSsolve>SCATter ( chemical "Zn" or chemical "ZN" ) 
 CNSsolve>  14.0743 3.2655 7.0318 0.2333 5.1652 10.3163 2.41 58.7097 1.3041 
 CNSsolve>SCATter ( chemical "Zn+2" or chemical "ZN+2" ) 
 CNSsolve>  11.9719 2.9946 7.3862 0.2031 6.4668 7.0826 1.394 18.0995 0.7807 
 CNSsolve>SCATter ( chemical "Ga" or chemical "GA" ) 
 CNSsolve>  15.2354 3.0669 6.7006 0.2412 4.3591 10.7805 2.9623 61.4135 1.7189 
 CNSsolve>SCATter ( chemical "Ga+3" or chemical "GA+3" ) 
 CNSsolve>  12.692 2.81262 6.69883 0.22789 6.06692 6.36441 1.0066 14.4122 1.53545 
 CNSsolve>SCATter ( chemical "Ge" or chemical "GE" ) 
 CNSsolve>  16.0816 2.8509 6.3747 0.2516 3.7068 11.4468 3.683 54.7625 2.1313 
 CNSsolve>SCATter ( chemical "Ge+4" or chemical "GE+4" ) 
 CNSsolve>  12.9172 2.53718 6.70003 0.205855 6.06791 5.47913 0.859041 11.603 1.45572 
 CNSsolve>SCATter ( chemical "As" or chemical "AS" ) 
 CNSsolve>  16.6723 2.6345 6.0701 0.2647 3.4313 12.9479 4.2779 47.7972 2.531 
 CNSsolve>SCATter ( chemical "Se" or chemical "SE" ) 
 CNSsolve>  17.0006 2.4098 5.8196 0.2726 3.9731 15.2372 4.3543 43.8163 2.8409 
 CNSsolve>SCATter ( chemical "Br" or chemical "BR" ) 
 CNSsolve>  17.1789 2.1723 5.2358 16.5796 5.6377 0.2609 3.9851 41.4328 2.9557 
 CNSsolve>SCATter ( chemical "Br-1" or chemical "BR-1" ) 
 CNSsolve>  17.1718 2.2059 6.3338 19.3345 5.5754 0.2871 3.7272 58.1535 3.1776 
 CNSsolve>SCATter ( chemical "Kr" or chemical "KR" ) 
 CNSsolve>  17.3555 1.9384 6.7286 16.5623 5.5493 0.2261 3.5375 39.3972 2.825 
 CNSsolve>SCATter ( chemical "Rb" or chemical "RB" ) 
 CNSsolve>  17.1784 1.7888 9.6435 17.3151 5.1399 0.2748 1.5292 164.934 3.4873 
 CNSsolve>SCATter ( chemical "Rb+1" or chemical "RB+1" ) 
 CNSsolve>  17.5816 1.7139 7.6598 14.7957 5.8981 0.1603 2.7817 31.2087 2.0782 
 CNSsolve>SCATter ( chemical "Sr" or chemical "SR" ) 
 CNSsolve>  17.5663 1.5564 9.8184 14.0988 5.422 0.1664 2.6694 132.376 2.5064 
 CNSsolve>SCATter ( chemical "Sr+2" or chemical "SR+2" ) 
 CNSsolve>  18.0874 1.4907 8.1373 12.6963 2.5654 24.5651 -34.193 -0.0138 41.4025 
 CNSsolve>SCATter ( chemical "Y" ) 
 CNSsolve>  17.776 1.4029 10.2946 12.8006 5.72629 0.125599 3.26588 104.354 1.91213 
 CNSsolve>SCATter ( chemical "Y+3" ) 
 CNSsolve>  17.9268 1.35417 9.1531 11.2145 1.76795 22.6599 -33.108 -0.01319 40.2602 
 CNSsolve>SCATter ( chemical "Zr" or chemical "ZR" ) 
 CNSsolve>  17.8765 1.27618 10.948 11.916 5.41732 0.117622 3.65721 87.6627 2.06929 
 CNSsolve>SCATter ( chemical "Zr+4" or chemical "ZR+4" ) 
 CNSsolve>  18.1668 1.2148 10.0562 10.1483 1.01118 21.6054 -2.6479 -0.10276 9.41454 
 CNSsolve>SCATter ( chemical "Nb" or chemical "NB" ) 
 CNSsolve>  17.6142 1.18865 12.0144 11.766 4.04183 0.204785 3.53346 69.7957 3.75591 
 CNSsolve>SCATter ( chemical "Nb+3" or chemical "NB+3" ) 
 CNSsolve>  19.8812 0.019175 18.0653 1.13305 11.0177 10.1621 1.94715 28.3389 -12.912 
 CNSsolve>SCATter ( chemical "Nb+5" or chemical "NB+5" ) 
 CNSsolve>  17.9163 1.12446 13.3417 0.028781 10.799 9.28206 0.337905 25.7228 -6.3934 
 CNSsolve>SCATter ( chemical "Mo" or chemical "MO" ) 
 CNSsolve>  3.7025 0.2772 17.2356 1.0958 12.8876 11.004 3.7429 61.6584 4.3875 
 CNSsolve>SCATter ( chemical "Mo+3" or chemical "MO+3" ) 
 CNSsolve>  21.1664 0.014734 18.2017 1.03031 11.7423 9.53659 2.30951 26.6307 -14.421 
 CNSsolve>SCATter ( chemical "Mo+5" or chemical "MO+5" ) 
 CNSsolve>  21.0149 0.014345 18.0992 1.02238 11.4632 8.78809 0.740625 23.3452 -14.316 
 CNSsolve>SCATter ( chemical "Mo+6" or chemical "MO+6" ) 
 CNSsolve>  17.8871 1.03649 11.175 8.48061 6.57891 0.058881 0 0 0.344941 
 CNSsolve>SCATter ( chemical "Tc" or chemical "TC" ) 
 CNSsolve>  19.1301 0.864132 11.0948 8.14487 4.64901 21.5707 2.71263 86.8472 5.40428 
 CNSsolve>SCATter ( chemical "Ru" or chemical "RU" ) 
 CNSsolve>  19.2674 0.80852 12.9182 8.43467 4.86337 24.7997 1.56756 94.2928 5.37874 
 CNSsolve>SCATter ( chemical "Ru+3" or chemical "RU+3" ) 
 CNSsolve>  18.5638 0.847329 13.2885 8.37164 9.32602 0.017662 3.00964 22.887 -3.1892 
 CNSsolve>SCATter ( chemical "Ru+4" or chemical "RU+4" ) 
 CNSsolve>  18.5003 0.844582 13.1787 8.12534 4.71304 0.36495 2.18535 20.8504 1.42357 
 CNSsolve>SCATter ( chemical "Rh" or chemical "RH" ) 
 CNSsolve>  19.2957 0.751536 14.3501 8.21758 4.73425 25.8749 1.28918 98.6062 5.328 
 CNSsolve>SCATter ( chemical "Rh+3" or chemical "RH+3" ) 
 CNSsolve>  18.8785 0.764252 14.1259 7.84438 3.32515 21.2487 -6.1989 -0.01036 11.8678 
 CNSsolve>SCATter ( chemical "Rh+4" or chemical "RH+4" ) 
 CNSsolve>  18.8545 0.760825 13.9806 7.62436 2.53464 19.3317 -5.6526 -0.0102 11.2835 
 CNSsolve>SCATter ( chemical "Pd" or chemical "PD" ) 
 CNSsolve>  19.3319 0.698655 15.5017 7.98929 5.29537 25.2052 0.605844 76.8986 5.26593 
 CNSsolve>SCATter ( chemical "Pd+2" or chemical "PD+2" ) 
 CNSsolve>  19.1701 0.696219 15.2096 7.55573 4.32234 22.5057 0 0 5.2916 
 CNSsolve>SCATter ( chemical "Pd+4" or chemical "PD+4" ) 
 CNSsolve>  19.2493 0.683839 14.79 7.14833 2.89289 17.9144 -7.9492 0.005127 13.0174 
 CNSsolve>SCATter ( chemical "Ag" or chemical "AG" ) 
 CNSsolve>  19.2808 0.6446 16.6885 7.4726 4.8045 24.6605 1.0463 99.8156 5.179 
 CNSsolve>SCATter ( chemical "Ag+1" or chemical "AG+1" ) 
 CNSsolve>  19.1812 0.646179 15.9719 7.19123 5.27475 21.7326 0.357534 66.1147 5.21572 
 CNSsolve>SCATter ( chemical "Ag+2" or chemical "AG+2" ) 
 CNSsolve>  19.1643 0.645643 16.2456 7.18544 4.3709 21.4072 0 0 5.21404 
 CNSsolve>SCATter ( chemical "Cd" or chemical "CD" ) 
 CNSsolve>  19.2214 0.5946 17.6444 6.9089 4.461 24.7008 1.6029 87.4825 5.0694 
 CNSsolve>SCATter ( chemical "Cd+2" or chemical "CD+2" ) 
 CNSsolve>  19.1514 0.597922 17.2535 6.80639 4.47128 20.2521 0 0 5.11937 
 CNSsolve>SCATter ( chemical "In" or chemical "IN" ) 
 CNSsolve>  19.1624 0.5476 18.5596 6.3776 4.2948 25.8499 2.0396 92.8029 4.9391 
 CNSsolve>SCATter ( chemical "In+3" or chemical "IN+3" ) 
 CNSsolve>  19.1045 0.551522 18.1108 6.3247 3.78897 17.3595 0 0 4.99635 
 CNSsolve>SCATter ( chemical "Sn" or chemical "SN" ) 
 CNSsolve>  19.1889 5.8303 19.1005 0.5031 4.4585 26.8909 2.4663 83.9571 4.7821 
 CNSsolve>SCATter ( chemical "Sn+2" or chemical "SN+2" ) 
 CNSsolve>  19.1094 0.5036 19.0548 5.8378 4.5648 23.3752 0.487 62.2061 4.7861 
 CNSsolve>SCATter ( chemical "Sn+4" or chemical "SN+4" ) 
 CNSsolve>  18.9333 5.764 19.7131 0.4655 3.4182 14.0049 0.0193 -0.7583 3.9182 
 CNSsolve>SCATter ( chemical "Sb" or chemical "SB" ) 
 CNSsolve>  19.6418 5.3034 19.0455 0.4607 5.0371 27.9074 2.6827 75.2825 4.5909 
 CNSsolve>SCATter ( chemical "Sb+3" or chemical "SB+3" ) 
 CNSsolve>  18.9755 0.467196 18.933 5.22126 5.10789 19.5902 0.288753 55.5113 4.69626 
 CNSsolve>SCATter ( chemical "Sb+5" or chemical "SB+5" ) 
 CNSsolve>  19.8685 5.44853 19.0302 0.467973 2.41253 14.1259 0 0 4.69263 
 CNSsolve>SCATter ( chemical "Te" or chemical "TE" ) 
 CNSsolve>  19.9644 4.81742 19.0138 0.420885 6.14487 28.5284 2.5239 70.8403 4.352 
 CNSsolve>SCATter ( chemical "I" or chemical "I5U" ) 
 CNSsolve>  20.1472 4.347 18.9949 0.3814 7.5138 27.766 2.2735 66.8776 4.0712 
 CNSsolve>SCATter ( chemical "I-1" ) 
 CNSsolve>  20.2332 4.3579 18.997 0.3815 7.8069 29.5259 2.8868 84.9304 4.0714 
 CNSsolve>SCATter ( chemical "Xe" or chemical "XE" ) 
 CNSsolve>  20.2933 3.9282 19.0298 0.344 8.9767 26.4659 1.99 64.2658 3.7118 
 CNSsolve>SCATter ( chemical "Cs" or chemical "CS" ) 
 CNSsolve>  20.3892 3.569 19.1062 0.3107 10.662 24.3879 1.4953 213.904 3.3352 
 CNSsolve>SCATter ( chemical "Cs+1" or chemical "CS+1" ) 
 CNSsolve>  20.3524 3.552 19.1278 0.3086 10.2821 23.7128 0.9615 59.4565 3.2791 
 CNSsolve>SCATter ( chemical "Ba" or chemical "BA" ) 
 CNSsolve>  20.3361 3.216 19.297 0.2756 10.888 20.2073 2.6959 167.202 2.7731 
 CNSsolve>SCATter ( chemical "Ba+2" or chemical "BA+2" ) 
 CNSsolve>  20.1807 3.21367 19.1136 0.28331 10.9054 20.0558 0.77634 51.746 3.02902 
 CNSsolve>SCATter ( chemical "La" or chemical "LA" ) 
 CNSsolve>  20.578 2.94817 19.599 0.244475 11.3727 18.7726 3.28719 133.124 2.14678 
 CNSsolve>SCATter ( chemical "La+3" or chemical "LA+3" ) 
 CNSsolve>  20.2489 2.9207 19.3763 0.250698 11.6323 17.8211 0.336048 54.9453 2.4086 
 CNSsolve>SCATter ( chemical "Ce" or chemical "CE" ) 
 CNSsolve>  21.1671 2.81219 19.7695 0.226836 11.8513 17.6083 3.33049 127.113 1.86264 
 CNSsolve>SCATter ( chemical "Ce+3" or chemical "CE+3" ) 
 CNSsolve>  20.8036 2.77691 19.559 0.23154 11.9369 16.5408 0.612376 43.1692 2.09013 
 CNSsolve>SCATter ( chemical "Ce+4" or chemical "CE+4" ) 
 CNSsolve>  20.3235 2.65941 19.8186 0.21885 12.1233 15.7992 0.144583 62.2355 1.5918 
 CNSsolve>SCATter ( chemical "Pr" or chemical "PR" ) 
 CNSsolve>  22.044 2.77393 19.6697 0.222087 12.3856 16.7669 2.82428 143.644 2.0583 
 CNSsolve>SCATter ( chemical "Pr+3" or chemical "PR+3" ) 
 CNSsolve>  21.3727 2.6452 19.7491 0.214299 12.1329 15.323 0.97518 36.4065 1.77132 
 CNSsolve>SCATter ( chemical "Pr+4" or chemical "PR+4" ) 
 CNSsolve>  20.9413 2.54467 20.0539 0.202481 12.4668 14.8137 0.296689 45.4643 1.24285 
 CNSsolve>SCATter ( chemical "Nd" or chemical "ND" ) 
 CNSsolve>  22.6845 2.66248 19.6847 0.210628 12.774 15.885 2.85137 137.903 1.98486 
 CNSsolve>SCATter ( chemical "Nd+3" or chemical "ND+3" ) 
 CNSsolve>  21.961 2.52722 19.9339 0.199237 12.12 14.1783 1.51031 30.8717 1.47588 
 CNSsolve>SCATter ( chemical "Pm" or chemical "PM" ) 
 CNSsolve>  23.3405 2.5627 19.6095 0.202088 13.1235 15.1009 2.87516 132.721 2.02876 
 CNSsolve>SCATter ( chemical "Pm+3" or chemical "PM+3" ) 
 CNSsolve>  22.5527 2.4174 20.1108 0.185769 12.0671 13.1275 2.07492 27.4491 1.19499 
 CNSsolve>SCATter ( chemical "Smm" or chemical "SMM" ) 
 CNSsolve>  24.0042 2.47274 19.4258 0.196451 13.4396 14.3996 2.89604 128.007 2.20963 
 CNSsolve>SCATter ( chemical "Sm+3" or chemical "SM+3" ) 
 CNSsolve>  23.1504 2.31641 20.2599 0.174081 11.9202 12.1571 2.71488 24.8242 0.954586 
 CNSsolve>SCATter ( chemical "Eu" or chemical "EU" ) 
 CNSsolve>  24.6274 2.3879 19.0886 0.1942 13.7603 13.7546 2.9227 123.174 2.5745 
 CNSsolve>SCATter ( chemical "Eu+2" or chemical "EU+2" ) 
 CNSsolve>  24.0063 2.27783 19.9504 0.17353 11.8034 11.6096 3.87243 26.5156 1.36389 
 CNSsolve>SCATter ( chemical "Eu+3" or chemical "EU+3" ) 
 CNSsolve>  23.7497 2.22258 20.3745 0.16394 11.8509 11.311 3.26503 22.9966 0.759344 
 CNSsolve>SCATter ( chemical "Gd" or chemical "GD" ) 
 CNSsolve>  25.0709 2.25341 19.0798 0.181951 13.8518 12.9331 3.54545 101.398 2.4196 
 CNSsolve>SCATter ( chemical "Gd+3" or chemical "GD+3" ) 
 CNSsolve>  24.3466 2.13553 20.4208 0.155525 11.8708 10.5782 3.7149 21.7029 0.645089 
 CNSsolve>SCATter ( chemical "Tb" or chemical "TB" ) 
 CNSsolve>  25.8976 2.24256 18.2185 0.196143 14.3167 12.6648 2.95354 115.362 3.58324 
 CNSsolve>SCATter ( chemical "Tb+3" or chemical "TB+3" ) 
 CNSsolve>  24.9559 2.05601 20.3271 0.149525 12.2471 10.0499 3.773 21.2773 0.691967 
 CNSsolve>SCATter ( chemical "Dy" or chemical "DY" ) 
 CNSsolve>  26.507 2.1802 17.6383 0.202172 14.5596 12.1899 2.96577 111.874 4.29728 
 CNSsolve>SCATter ( chemical "Dy+3" or chemical "DY+3" ) 
 CNSsolve>  25.5395 1.9804 20.2861 0.143384 11.9812 9.34972 4.50073 19.581 0.68969 
 CNSsolve>SCATter ( chemical "Ho" or chemical "HO" ) 
 CNSsolve>  26.9049 2.07051 17.294 0.19794 14.5583 11.4407 3.63837 92.6566 4.56796 
 CNSsolve>SCATter ( chemical "Ho+3" or chemical "HO+3" ) 
 CNSsolve>  26.1296 1.91072 20.0994 0.139358 11.9788 8.80018 4.93676 18.5908 0.852795 
 CNSsolve>SCATter ( chemical "Er" or chemical "ER" ) 
 CNSsolve>  27.6563 2.07356 16.4285 0.223545 14.9779 11.3604 2.98233 105.703 5.92046 
 CNSsolve>SCATter ( chemical "Er+3" or chemical "ER+3" ) 
 CNSsolve>  26.722 1.84659 19.7748 0.13729 12.1506 8.36225 5.17379 17.8974 1.17613 
 CNSsolve>SCATter ( chemical "Tm" or chemical "TM" ) 
 CNSsolve>  28.1819 2.02859 15.8851 0.238849 15.1542 10.9975 2.98706 102.961 6.75621 
 CNSsolve>SCATter ( chemical "Tm+3" or chemical "TM+3" ) 
 CNSsolve>  27.3083 1.78711 19.332 0.136974 12.3339 7.96778 5.38348 17.2922 1.63929 
 CNSsolve>SCATter ( chemical "Yb" or chemical "YB" ) 
 CNSsolve>  28.6641 1.9889 15.4345 0.257119 15.3087 10.6647 2.98963 100.417 7.56672 
 CNSsolve>SCATter ( chemical "Yb+2" or chemical "YB+2" ) 
 CNSsolve>  28.1209 1.78503 17.6817 0.15997 13.3335 8.18304 5.14657 20.39 3.70983 
 CNSsolve>SCATter ( chemical "Yb+3" or chemical "YB+3" ) 
 CNSsolve>  27.8917 1.73272 18.7614 0.13879 12.6072 7.64412 5.47647 16.8153 2.26001 
 CNSsolve>SCATter ( chemical "Lu" or chemical "LU" ) 
 CNSsolve>  28.9476 1.90182 15.2208 9.98519 15.1 0.261033 3.71601 84.3298 7.97628 
 CNSsolve>SCATter ( chemical "Lu+3" or chemical "LU+3" ) 
 CNSsolve>  28.4628 1.68216 18.121 0.142292 12.8429 7.33727 5.59415 16.3535 2.97573 
 CNSsolve>SCATter ( chemical "Hf" or chemical "HF" ) 
 CNSsolve>  29.144 1.83262 15.1726 9.5999 14.7586 0.275116 4.30013 72.029 8.58154 
 CNSsolve>SCATter ( chemical "Hf+4" or chemical "HF+4" ) 
 CNSsolve>  28.8131 1.59136 18.4601 0.128903 12.7285 6.76232 5.59927 14.0366 2.39699 
 CNSsolve>SCATter ( chemical "Ta" or chemical "TA" ) 
 CNSsolve>  29.2024 1.77333 15.2293 9.37046 14.5135 0.295977 4.76492 63.3644 9.24354 
 CNSsolve>SCATter ( chemical "Ta+5" or chemical "TA+5" ) 
 CNSsolve>  29.1587 1.50711 18.8407 0.116741 12.8268 6.31524 5.38695 12.4244 1.78555 
 CNSsolve>SCATter ( chemical "W" ) 
 CNSsolve>  29.0818 1.72029 15.43 9.2259 14.4327 0.321703 5.11982 57.056 9.8875 
 CNSsolve>SCATter ( chemical "W+6" ) 
 CNSsolve>  29.4936 1.42755 19.3763 0.104621 13.0544 5.93667 5.06412 11.1972 1.01074 
 CNSsolve>SCATter ( chemical "Re" or chemical "RE" ) 
 CNSsolve>  28.7621 1.67191 15.7189 9.09227 14.5564 0.3505 5.44174 52.0861 10.472 
 CNSsolve>SCATter ( chemical "Os" or chemical "OS" ) 
 CNSsolve>  28.1894 1.62903 16.155 8.97948 14.9305 0.382661 5.67589 48.1647 11.0005 
 CNSsolve>SCATter ( chemical "Os+4" or chemical "OS+4" ) 
 CNSsolve>  30.419 1.37113 15.2637 6.84706 14.7458 0.165191 5.06795 18.003 6.49804 
 CNSsolve>SCATter ( chemical "Ir" or chemical "IR" ) 
 CNSsolve>  27.3049 1.59279 16.7296 8.86553 15.6115 0.417916 5.83377 45.0011 11.4722 
 CNSsolve>SCATter ( chemical "Ir+3" or chemical "IR+3" ) 
 CNSsolve>  30.4156 1.34323 15.862 7.10909 13.6145 0.204633 5.82008 20.3254 8.27903 
 CNSsolve>SCATter ( chemical "Ir+4" or chemical "IR+4" ) 
 CNSsolve>  30.7058 1.30923 15.5512 6.71983 14.2326 0.167252 5.53672 17.4911 6.96824 
 CNSsolve>SCATter ( chemical "Pt" or chemical "PT" ) 
 CNSsolve>  27.0059 1.51293 17.7639 8.81174 15.7131 0.424593 5.7837 38.6103 11.6883 
 CNSsolve>SCATter ( chemical "Pt+2" or chemical "PT+2" ) 
 CNSsolve>  29.8429 1.32927 16.7224 7.38979 13.2153 0.263297 6.35234 22.9426 9.85329 
 CNSsolve>SCATter ( chemical "Pt+4" or chemical "PT+4" ) 
 CNSsolve>  30.9612 1.24813 15.9829 6.60834 13.7348 0.16864 5.92034 16.9392 7.39534 
 CNSsolve>SCATter ( chemical "Au" or chemical "AU" ) 
 CNSsolve>  16.8819 0.4611 18.5913 8.6216 25.5582 1.4826 5.86 36.3956 12.0658 
 CNSsolve>SCATter ( chemical "Au+1" or chemical "AU+1" ) 
 CNSsolve>  28.0109 1.35321 17.8204 7.7395 14.3359 0.356752 6.58077 26.4043 11.2299 
 CNSsolve>SCATter ( chemical "Au+3" or chemical "AU+3" ) 
 CNSsolve>  30.6886 1.2199 16.9029 6.82872 12.7801 0.212867 6.52354 18.659 9.0968 
 CNSsolve>SCATter ( chemical "Hg" or chemical "HG" ) 
 CNSsolve>  20.6809 0.545 19.0417 8.4484 21.6575 1.5729 5.9676 38.3246 12.6089 
 CNSsolve>SCATter ( chemical "Hg+1" or chemical "HG+1" ) 
 CNSsolve>  25.0853 1.39507 18.4973 7.65105 16.8883 0.443378 6.48216 28.2262 12.0205 
 CNSsolve>SCATter ( chemical "Hg+2" or chemical "HG+2" ) 
 CNSsolve>  29.5641 1.21152 18.06 7.05639 12.8374 0.284738 6.89912 20.7482 10.6268 
 CNSsolve>SCATter ( chemical "Tl" or chemical "TL" ) 
 CNSsolve>  27.5446 0.65515 19.1584 8.70751 15.538 1.96347 5.52593 45.8149 13.1746 
 CNSsolve>SCATter ( chemical "Tl+1" or chemical "TL+1" ) 
 CNSsolve>  21.3985 1.4711 20.4723 0.517394 18.7478 7.43463 6.82847 28.8482 12.5258 
 CNSsolve>SCATter ( chemical "Tl+3" or chemical "TL+3" ) 
 CNSsolve>  30.8695 1.1008 18.3841 6.53852 11.9328 0.219074 7.00574 17.2114 9.8027 
 CNSsolve>SCATter ( chemical "Pb" or chemical "PB" ) 
 CNSsolve>  31.0617 0.6902 13.0637 2.3576 18.442 8.618 5.9696 47.2579 13.4118 
 CNSsolve>SCATter ( chemical "Pb+2" or chemical "PB+2" ) 
 CNSsolve>  21.7886 1.3366 19.5682 0.488383 19.1406 6.7727 7.01107 23.8132 12.4734 
 CNSsolve>SCATter ( chemical "Pb+4" or chemical "PB+4" ) 
 CNSsolve>  32.1244 1.00566 18.8003 6.10926 12.0175 0.147041 6.96886 14.714 8.08428 
 CNSsolve>SCATter ( chemical "Bi" or chemical "BI" ) 
 CNSsolve>  33.3689 0.704 12.951 2.9238 16.5877 8.7937 6.4692 48.0093 13.5782 
 CNSsolve>SCATter ( chemical "Bi+3" or chemical "BI+3" ) 
 CNSsolve>  21.8053 1.2356 19.5026 6.24149 19.1053 0.469999 7.10295 20.3185 12.4711 
 CNSsolve>SCATter ( chemical "Bi+5" or chemical "BI+5" ) 
 CNSsolve>  33.5364 0.91654 25.0946 0.39042 19.2497 5.71414 6.91555 12.8285 -6.7994 
 CNSsolve>SCATter ( chemical "Po" or chemical "PO" ) 
 CNSsolve>  34.6726 0.700999 15.4733 3.55078 13.1138 9.55642 7.02588 47.0045 13.677 
 CNSsolve>SCATter ( chemical "At" or chemical "AT" ) 
 CNSsolve>  35.3163 0.68587 19.0211 3.97458 9.49887 11.3824 7.42518 45.4715 13.7108 
 CNSsolve>SCATter ( chemical "Rn" or chemical "RN" ) 
 CNSsolve>  35.5631 0.6631 21.2816 4.0691 8.0037 14.0422 7.4433 44.2473 13.6905 
 CNSsolve>SCATter ( chemical "Fr" or chemical "FR" ) 
 CNSsolve>  35.9299 0.646453 23.0547 4.17619 12.1439 23.1052 2.11253 150.645 13.7247 
 CNSsolve>SCATter ( chemical "Ra" or chemical "RA" ) 
 CNSsolve>  35.763 0.616341 22.9064 3.87135 12.4739 19.9887 3.21097 142.325 13.6211 
 CNSsolve>SCATter ( chemical "Ra+2" or chemical "RA+2" ) 
 CNSsolve>  35.215 0.604909 21.67 3.5767 7.91342 12.601 7.65078 29.8436 13.5431 
 CNSsolve>SCATter ( chemical "Ac" or chemical "AC" ) 
 CNSsolve>  35.6597 0.589092 23.1032 3.65155 12.5977 18.599 4.08655 117.02 13.5266 
 CNSsolve>SCATter ( chemical "Ac+3" or chemical "AC+3" ) 
 CNSsolve>  35.1736 0.579689 22.1112 3.41437 8.19216 12.9187 7.05545 25.9443 13.4637 
 CNSsolve>SCATter ( chemical "Th" or chemical "TH" ) 
 CNSsolve>  35.5645 0.563359 23.4219 3.46204 12.7473 17.8309 4.80703 99.1722 13.4314 
 CNSsolve>SCATter ( chemical "Th+4" or chemical "TH+4" ) 
 CNSsolve>  35.1007 0.555054 22.4418 3.24498 9.78554 13.4661 5.29444 23.9533 13.376 
 CNSsolve>SCATter ( chemical "Pa" or chemical "PA" ) 
 CNSsolve>  35.8847 0.547751 23.2948 3.41519 14.1891 16.9235 4.17287 105.251 13.4287 
 CNSsolve>SCATter ( chemical "U" ) 
 CNSsolve>  36.0228 0.5293 23.4128 3.3253 14.9491 16.0927 4.188 100.613 13.3966 
 CNSsolve>SCATter ( chemical "U+3" ) 
 CNSsolve>  35.5747 0.52048 22.5259 3.12293 12.2165 12.7148 5.37073 26.3394 13.3092 
 CNSsolve>SCATter ( chemical "U+4" ) 
 CNSsolve>  35.3715 0.516598 22.5326 3.05053 12.0291 12.5723 4.7984 23.4582 13.2671 
 CNSsolve>SCATter ( chemical "U+6" ) 
 CNSsolve>  34.8509 0.507079 22.7584 2.8903 14.0099 13.1767 1.21457 25.2017 13.1665 
 CNSsolve>SCATter ( chemical "Npp" or chemical "NPP" ) 
 CNSsolve>  36.1874 0.511929 23.5964 3.25396 15.6402 15.3622 4.1855 97.4908 13.3573 
 CNSsolve>SCATter ( chemical "Np+3" or chemical "NP+3" ) 
 CNSsolve>  35.7074 0.502322 22.613 3.03807 12.9898 12.1449 5.43227 25.4928 13.2544 
 CNSsolve>SCATter ( chemical "Np+4" or chemical "NP+4" ) 
 CNSsolve>  35.5103 0.498626 22.5787 2.96627 12.7766 11.9484 4.92159 22.7502 13.2116 
 CNSsolve>SCATter ( chemical "Np+6" or chemical "NP+6" ) 
 CNSsolve>  35.0136 0.48981 22.7286 2.81099 14.3884 12.33 1.75669 22.6581 13.113 
 CNSsolve>SCATter ( chemical "Pu" or chemical "PU" ) 
 CNSsolve>  36.5254 0.499384 23.8083 3.26371 16.7707 14.9455 3.47947 105.98 13.3812 
 CNSsolve>SCATter ( chemical "Pu+3" or chemical "PU+3" ) 
 CNSsolve>  35.84 0.484938 22.7169 2.96118 13.5807 11.5331 5.66016 24.3992 13.1991 
 CNSsolve>SCATter ( chemical "Pu+4" or chemical "PU+4" ) 
 CNSsolve>  35.6493 0.481422 22.646 2.8902 13.3595 11.316 5.18831 21.8301 13.1555 
 CNSsolve>SCATter ( chemical "Pu+6" or chemical "PU+6" ) 
 CNSsolve>  35.1736 0.473204 22.7181 2.73848 14.7635 11.553 2.28678 20.9303 13.0582 
 CNSsolve>SCATter ( chemical "Am" or chemical "AM" ) 
 CNSsolve>  36.6706 0.483629 24.0992 3.20647 17.3415 14.3136 3.49331 102.273 13.3592 
 CNSsolve>SCATter ( chemical "Cm" or chemical "CM" ) 
 CNSsolve>  36.6488 0.465154 24.4096 3.08997 17.399 13.4346 4.21665 88.4834 13.2887 
 CNSsolve>SCATter ( chemical "Bk" or chemical "BK" ) 
 CNSsolve>  36.7881 0.451018 24.7736 3.04619 17.8919 12.8946 4.23284 86.003 13.2754 
 CNSsolve>SCATter ( chemical "Cff" or chemical "CFF" ) 
 CNSsolve>  36.9185 0.437533 25.1995 3.00775 18.3317 12.4044 4.24391 83.7881 13.2674 
 CNSsolve> 
 CNSsolve>set message=$message_old_sclib echo=$echo_old_sclib end 
 CNSsolve> 
 CNSsolve>        ! reciprocal space complex arrays 
 CNSsolve>        declare name=fobs  domain=reciprocal type=complex end 
 CNSsolve>        declare name=fcalc domain=reciprocal type=complex end 
 CNSsolve>        declare name=fpart domain=reciprocal type=complex end 
 CNSsolve> 
 CNSsolve>        ! real space arrays 
 CNSsolve>        declare name=map domain=real end 
 CNSsolve> 
 CNSsolve>        ! only calculate structure factors for protein and DNA 
 CNSsolve>        associate fcalc (not (name H* or resn HOH or resn TIP3 or resn DAN or resn XAN or resn DUM)) 
 CNSsolve> 
 CNSsolve>        ! read in map 
 CNSsolve>        read map 
 CNSsolve>            to=map 
 CNSsolve>            input=RUN:data/cryo-em/cryo-em.xplor 
 CNSsolve>            formatted=True 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! set initial values 
 CNSsolve>        do (fobs = ft(map)) (all) 
 CNSsolve>        do (fcalc = 0) (all) 
 CNSsolve>        do (fpart = 0) (all) 
 CNSsolve> 
 CNSsolve>        ! set which Fourier coefficients are used for XREF term and which 
 CNSsolve>        ! are used for cross-validation 
 CNSsolve>        tselection=(all) 
 CNSsolve>        cvselection=(not all) 
 CNSsolve> 
 CNSsolve>        ! set target function and target derivative function for XREF energy 
 CNSsolve>        target =( vector(combine(amplitude(fobs),phase(fobs)), (fcalc), 1)) 
 CNSsolve>        dtarget=(dvector(combine(amplitude(fobs),phase(fobs)), (fcalc), 1)) 
 CNSsolve> 
 CNSsolve>        ! set weight of target function 
 CNSsolve>        wa=&Data.em.kscale 
 CNSsolve> 
 CNSsolve>        ! set tolerance level for recomputing structure factors. This 
 CNSsolve>        ! should maybe be higher during the refinement stage. 
 CNSsolve>        tolerance=0.0 
 CNSsolve>    end 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.centroids = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>        if ($iteration = 0) then 
 CNSsolve>            @RUN:protocols/centroids_set_restraints.cns 
 ASSFIL: file centroids_set_restraints.cns opened.
 CNSsolve>{Sets the centroid based distance restraints} 
 CNSsolve> 
 CNSsolve>if ($iteration = 0) then 
 CNSsolve> 
 CNSsolve>  noe 
 CNSsolve>    ! define a new class for the centroid based distance restraints 
 CNSsolve>    class       centroid 
 CNSsolve>    averaging   centroid sum 
 CNSsolve>    potential   centroid soft 
 CNSsolve>    scale       centroid $Data.centroids.kscale 
 CNSsolve>    sqconstant  centroid 1.0 
 CNSsolve>    sqexponent  centroid 2 
 CNSsolve>    soexponent  centroid 1 
 CNSsolve>    rswitch     centroid 1.0 
 CNSsolve>    sqoffset    centroid 0.0 
 CNSsolve>    asymptote   centroid 2.0 
 CNSsolve>    msoexponent centroid 1 
 CNSsolve>    masymptote  centroid -0.1 
 CNSsolve>    mrswitch    centroid 1.0 
 CNSsolve> 
 CNSsolve>    ! set the restraints between each DUM and MAP atom for each chain. in case 
 CNSsolve>    ! of ambiguous restraints, each DUM atom is assigned with all MAP atoms 
 CNSsolve>    evaluate($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < $Data.ncomponents) loop distloop 
 CNSsolve>        evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>        if ($Data.centroids.ambi_$nchain1 = true) then 
 CNSsolve>            assign (name MAP) 
 CNSsolve>                   ((name DUM) and (segid $Toppar.prot_segid_$nchain1)) 0.0 0.0 0.0 
 CNSsolve>        else 
 CNSsolve>            assign ((name MAP) and (segid $Toppar.prot_segid_$nchain1)) 
 CNSsolve>                   ((name DUM) and (segid $Toppar.prot_segid_$nchain1)) 0.0 0.0 0.0 
 CNSsolve>        end if 
 CNSsolve>    end loop distloop 
 CNSsolve>  end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($iteration > 0) then 
 CNSsolve> 
 CNSsolve>! define centroid based distance restraints for expand/refine protocol 
 CNSsolve> 
 CNSsolve>  noe 
 CNSsolve>    ! define a new class for the centroid based distance restraints 
 CNSsolve>    class       centroid 
 CNSsolve>    averaging   centroid center 
 CNSsolve>    potential   centroid soft 
 CNSsolve>    scale       centroid $Data.centroids.kscale 
 CNSsolve>    sqconstant  centroid 1.0 
 CNSsolve>    sqexponent  centroid 2 
 CNSsolve>    soexponent  centroid 1 
 CNSsolve>    rswitch     centroid 1.0 
 CNSsolve>    sqoffset    centroid 0.0 
 CNSsolve>    asymptote   centroid 2.0 
 CNSsolve>    msoexponent centroid 1 
 CNSsolve>    masymptote  centroid -0.1 
 CNSsolve>    mrswitch    centroid 1.0 
 CNSsolve> 
 CNSsolve>    ! set the restraints between the heavy atoms of each chain and the 
 CNSsolve>    ! initially stored center of mass of each chain 
 CNSsolve>    evaluate($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < $Data.ncomponents) loop distloop 
 CNSsolve>        evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>        assign (not name H* and not name DUM and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>               (name DUM and segid $Toppar.prot_segid_$nchain1) 0.0 0.0 0.0 
 CNSsolve>    end loop distloop 
 CNSsolve> 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve>        end if 
 CNSsolve>    end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>{* ======================= reset coordinates and proceed *} 
 CNSsolve> 
 CNSsolve>do (x = refx) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>do (y = refy) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>do (z = refz) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>inline @RUN:protocols/read_water1.cns 
 ASSFIL: file read_water1.cns opened.
 CNSsolve>! read_water1.cns 
 CNSsolve>!   Read water coordinates from solvated docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($nchain=0) 
 EVALUATE: symbol $NCHAIN set to    0.00000     (real)
 CNSsolve>while ($nchain < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    1.00000     (real)
 CNSsolve>  evaluate ($watersegname_$nchain="WA" + encode($nchain)) 
 EVALUATE: symbol $WATERSEGNAME_1 set to "WA1" (string)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    2.00000     (real)
 CNSsolve>  evaluate ($watersegname_$nchain="WA" + encode($nchain)) 
 EVALUATE: symbol $WATERSEGNAME_2 set to "WA2" (string)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($nchain = $nchain + 1) 
 CNSsolve>  evaluate ($watersegname_$nchain="WA" + encode($nchain)) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($data.waterdock eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  noe reset end 
 CNSsolve>  rest dihe reset end 
 CNSsolve>  evaluate($watercoorfile = $file - ".pdb" + "_water.pdbw") 
 CNSsolve>  fileexist $watercoorfile end 
 CNSsolve>  evaluate ($waterfileexist=$result) 
 CNSsolve>  if ($waterfileexist eq true) then 
 CNSsolve>    if ($iteration < 2) then 
 CNSsolve>      evaluate($sol_topology_infile="RUN:/toppar/water-allhdg5-4.top") 
 CNSsolve>      topology @@$sol_topology_infile end 
 CNSsolve>    end if 
 CNSsolve>    segment 
 CNSsolve>      chain 
 CNSsolve>        separate-by-segid = true 
 CNSsolve>        coor @@$watercoorfile 
 CNSsolve>      end 
 CNSsolve>    end 
 CNSsolve>    coor @@$watercoorfile 
 CNSsolve>    ident (store5) (not all) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve>if ($data.waterdock eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  inline @RUN:protocols/water_rest.cns 
 ASSFIL: file water_rest.cns opened.
 CNSsolve>! water_rest.cns 
 CNSsolve>!    Define restraints between interfacial water molecules and highly solvated 
 CNSsolve>!    amino-acids 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>! This script define distance restraints between water molecule and amino-acids 
 CNSsolve>! often found to be involved in water-mediated contacts 
 CNSsolve>! See van Dijk and Bonvin, Bioinformatics 2006 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($nchain=0) 
 CNSsolve>while ($nchain < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate ($nchain = $nchain + 1) 
 CNSsolve>  evaluate ($watersegname_$nchain="WA" + encode($nchain)) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($data.waterdock eq true) then 
 CNSsolve> 
 CNSsolve>  if ($data.solvate_method eq "restraints") then 
 CNSsolve>    evaluate ($nchain=0) 
 CNSsolve>    while ($nchain < $data.ncomponents) loop nloop2 
 CNSsolve>      evaluate ($nchain = $nchain + 1) 
 CNSsolve>      noe class amwa end 
 CNSsolve>      for $atom_id in id ((resn WAT or resn HOH) and name OH2 and segid $watersegname_$nchain and not store5) loop waterrestraint 
 CNSsolve>        noe 
 CNSsolve>          assi (segid $toppar.prot_segid_$nchain and 
 CNSsolve>	        (resn arg or resn asn or resn asp or resn gln or resn glu or resn his* 
 CNSsolve>		 or resn lys or resn pro or resn ser or resn thr or resn tyr) 
 CNSsolve>	        and ((id $atom_id) around $data.water_restraint_cutoff)) 
 CNSsolve>               (id $atom_id) $data.water_restraint_cutoff $data.water_restraint_cutoff 0.0 
 CNSsolve>        end 
 CNSsolve>      end loop waterrestraint 
 CNSsolve>    end loop nloop2 
 CNSsolve>    evaluate($amwa_scale = $data.water_restraint_scale) 
 CNSsolve>    noe scale amwa $amwa_scale end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve>  set seed $seed end 
 CNSsolve>  set message=normal echo=on end 
 CNSsolve>  inline @RUN:protocols/read_data.cns 
 ASSFIL: file read_data.cns opened.
 CNSsolve>! read_data.cns 
 CNSsolve>!    Read the various restraints data 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>!module(Iteration; Data; count;) 
 CNSsolve> 
 CNSsolve>!NOEs, hbonds 
 CNSsolve>noe 
 CNSsolve>  reset 
 CNSsolve>  nrestraints = 12000000     ! allocate space for NOEs 
 CNSsolve>  ceiling 1000 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>if ($Data.amb_lastit ge $Iteration) then 
 CNSsolve>  if ($Data.amb_firstit le $Iteration)   then 
 CNSsolve>     evaluate ($filenam0 = "NEWIT:ambig.tbl_" + encode($count)) 
 CNSsolve>     fileexist $filenam0 end 
 CNSsolve>     if ($result eq false) then 
 CNSsolve>       evaluate ($filenam0 = "NEWIT:ambig.tbl") 
 CNSsolve>     end if 
 CNSsolve>     noe class ambi @@$filenam0 end 
 CNSsolve>     if ($Data.noecv eq true) then 
 CNSsolve>       noe part $Data.ncvpart end 
 CNSsolve>     end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.unamb_lastit ge $Iteration) then 
 CNSsolve>  if ($Data.unamb_firstit le $Iteration) then 
 CNSsolve>     noe class dist @@NEWIT:unambig.tbl end 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.hbond_lastit ge $Iteration) then 
 CNSsolve>  if ($Data.hbond_firstit le $Iteration) then 
 CNSsolve>    if ($Data.hbonds_on eq true) then 
 CNSsolve>      noe @@RUN:data/hbonds/hbonds.tbl end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>  averaging  * sum 
 CNSsolve>  potential  * soft 
 CNSsolve>  scale      * 1.0 
 CNSsolve>  sqconstant * 1.0 
 CNSsolve>  sqexponent * 2 
 CNSsolve>  soexponent * 1 
 CNSsolve>  rswitch    * 1.0 
 CNSsolve>  sqoffset   * 0.0 
 CNSsolve>  asymptote  * 2.0 
 CNSsolve>  msoexponent * 1 
 CNSsolve>  masymptote  * -0.1 
 CNSsolve>  mrswitch    * 1.0 
 CNSsolve>  avexpo hbond 20 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve>!dihedral restraints: 
 CNSsolve>restraints dihedral 
 CNSsolve>   reset 
 CNSsolve>   nassign 10000 
 CNSsolve>end 
 CNSsolve>if ($Data.cdih.on eq true) then 
 CNSsolve>  restraints dihedral 
 CNSsolve>    @@RUN:data/dihedrals/dihedrals.tbl 
 CNSsolve>  end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>restraints dihedral ? end 
 CNSsolve> 
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve>!residual dipolar couplings: 
 CNSsolve> 
 CNSsolve>evaluate ($Data.flags.sani = false) 
 CNSsolve>evaluate ($Data.flags.xrdc = false) 
 CNSsolve>evaluate ($Data.flags.xpcs = false) 
 CNSsolve>evaluate ($Data.flags.dani = false) 
 CNSsolve>evaluate ($Data.flags.vean = false) 
 CNSsolve>evaluate ($inisani=0) 
 CNSsolve>evaluate ($inixrdc=0) 
 CNSsolve>evaluate ($inixpcs=0) 
 CNSsolve>evaluate ($inidani=0) 
 CNSsolve>evaluate ($inivean = 0) 
 CNSsolve> 
 CNSsolve>sani reset nres=5000 end 
 CNSsolve>vean reset nres=10000 end 
 CNSsolve>xrdc reset nres=5000 end 
 CNSsolve>evaluate ($nrdc=1) 
 CNSsolve>while ($nrdc <= $Data.numrdc) loop rdc 
 CNSsolve>  evaluate ($cln="rd"+encode($nrdc)) 
 CNSsolve>  if ($Data.rdc_lastit_$nrdc ge $Iteration) then 
 CNSsolve>    if ($Data.rdc_firstit_$nrdc le $Iteration) then 
 CNSsolve>      if ($Data.rdc_choice_$nrdc eq "SANI") then 
 CNSsolve>        evaluate ($Data.flags.sani = true) 
 CNSsolve>	evaluate ($restfile="RUN:data/rdcs/rdc"+encode($nrdc)+".tbl") 
 CNSsolve>        evaluate ($inisani=1) 
 CNSsolve>        sani 
 CNSsolve>          class $cln 
 CNSsolve>          force 0.0 
 CNSsolve>          potential square 
 CNSsolve>          @@$restfile 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>      if ($Data.rdc_choice_$nrdc eq "XRDC") then 
 CNSsolve>        evaluate ($Data.flags.xrdc = true) 
 CNSsolve>	evaluate ($restfile="RUN:data/rdcs/rdc"+encode($nrdc)+".tbl") 
 CNSsolve>        evaluate ($inixrdc=1) 
 CNSsolve>        xrdc 
 CNSsolve>          class $cln 
 CNSsolve>          force 0.0 
 CNSsolve>          @@$restfile 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>      if ($Data.rdc_choice_$nrdc eq "VANGLE") then 
 CNSsolve>        evaluate ($Data.flags.vean = true) 
 CNSsolve>	evaluate ($restfile="RUN:data/rdcs/rdc"+encode($nrdc)+".tbl") 
 CNSsolve>        evaluate ($inivean = 1) 
 CNSsolve>        if ($Data.rdc_firstIt_$nrdc le $Iteration) then 
 CNSsolve>          vean 
 CNSsolve>            class $cln 
 CNSsolve>            force 0.0 0.0 
 CNSsolve>            @@$restfile 
 CNSsolve>          end 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($nrdc = $nrdc + 1) 
 CNSsolve>end loop rdc 
 CNSsolve> 
 CNSsolve>evaluate ($tensread = false) 
 CNSsolve>if ($Data.flags.xrdc = true) then 
 CNSsolve>  noe 
 CNSsolve>    class tens 
 CNSsolve>    @@RUN:data/tensor/tensor.tbl 
 CNSsolve>    potential tens square 
 CNSsolve>    scale     tens 500.0 
 CNSsolve>  end 
 CNSsolve>  evaluate ($tensread = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve>!PCS restraints: 
 CNSsolve>xpcs reset nres=5000 end 
 CNSsolve>evaluate ($npcs=1) 
 CNSsolve>while ($npcs <= $Data.numpcs) loop pcs 
 CNSsolve>  if ($Data.pcs_lastit_$npcs ge $Iteration) then 
 CNSsolve>    if ($Data.pcs_firstit_$npcs le $Iteration) then 
 CNSsolve>      if ($Data.pcs_choice_$npcs eq "XPCS") then 
 CNSsolve>        evaluate ($Data.flags.xpcs = true) 
 CNSsolve>	evaluate ($restfile="RUN:data/pcs/pcs"+encode($npcs)+".tbl") 
 CNSsolve>	evaluate ($cln="pc"+encode($npcs)) 
 CNSsolve>        evaluate ($inixpcs=1) 
 CNSsolve>        xpcs 
 CNSsolve>          class $cln 
 CNSsolve>          force 0.0 
 CNSsolve>          @@$restfile 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($npcs= $npcs + 1) 
 CNSsolve>end loop pcs 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs = true) then 
 CNSsolve>  if ($tensread eq FALSE) then 
 CNSsolve>    noe 
 CNSsolve>      class tens 
 CNSsolve>      @@RUN:data/tensor/tensor.tbl 
 CNSsolve>      potential tens square 
 CNSsolve>      scale     tens 500.0 
 CNSsolve>    end 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve>!DANI restraints: 
 CNSsolve> 
 CNSsolve>evaluate ($ndani=1) 
 CNSsolve>dani reset nres=5000 end 
 CNSsolve>while ($ndani <= $Data.numdani) loop dani 
 CNSsolve>  if ($Data.dan_lastit_$ndani ge $Iteration) then 
 CNSsolve>    if ($Data.dan_firstit_$ndani le $Iteration) then 
 CNSsolve>      if ($Data.dan_choice_$ndani eq "DANI") then 
 CNSsolve>        evaluate ($Data.flags.dani = true) 
 CNSsolve>	evaluate ($restfile="RUN:data/dani/dani"+encode($ndani)+".tbl") 
 CNSsolve>	evaluate ($cln="da"+encode($ndani)) 
 CNSsolve>        evaluate ($inidani=1) 
 CNSsolve>        dani 
 CNSsolve>          class $cln 
 CNSsolve>          force 0.0 
 CNSsolve>          potential square 
 CNSsolve>          @@$restfile 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($ndani = $ndani + 1) 
 CNSsolve>end loop dani 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!set the energy flags: 
 CNSsolve>inline @RUN:protocols/setflags.cns 
 ASSFIL: file setflags.cns opened.
 CNSsolve>! setflags.cns 
 CNSsolve>!    Defines energy flags 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>if ($Data.cdih.on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   evaluate ($Data.flags.cdih =  true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($nrdc=1) 
 EVALUATE: symbol $NRDC set to    1.00000     (real)
 CNSsolve>while ($nrdc <= $Data.numrdc) loop rdc 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($Data.rdc_choice_$nrdc eq "SANI") then 
 CNSsolve>    evaluate ($Data.flags.sani = true) 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.rdc_choice_$nrdc eq "VANGLE") then 
 CNSsolve>    evaluate ($Data.flags.vean = true) 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.rdc_choice_$nrdc eq "XRDC") then 
 CNSsolve>    evaluate ($Data.flags.xrdc = true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($nrdc=$nrdc+1) 
 CNSsolve>end loop rdc 
 CNSsolve> 
 CNSsolve>evaluate ($ndani=1) 
 EVALUATE: symbol $NDANI set to    1.00000     (real)
 CNSsolve>while ($ndani <= $Data.numdani) loop dani 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($Data.dan_choice_$ndani eq "DANI") then 
 CNSsolve>     evaluate ($Data.flags.DANI = true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($ndani=$ndani+1) 
 CNSsolve>end loop dani 
 CNSsolve> 
 CNSsolve>evaluate ($npcs=1) 
 EVALUATE: symbol $NPCS set to    1.00000     (real)
 CNSsolve>while ($npcs <= $Data.numpcs) loop pcs 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($Data.pcs_choice_$npcs eq "XPCS") then 
 CNSsolve>     evaluate ($Data.flags.XPCS = true) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($npcs=$npcs+1) 
 CNSsolve>end loop pcs 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.harm = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.harm = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.noe  =  TRUE) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   flags include noe end 
 CNSsolve>elseif ($Data.flags.centroids = true) then 
 CNSsolve>    flags include noe end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.cdih =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include cdih end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.vean =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include vean end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.sani =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include sani end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.xrdc =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include xrdc end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.xpcs =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include xpcs end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include dani end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.plan =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include plan end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.ncs  =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include ncs end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.rg = TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($data.rgtarg > 0) then 
 CNSsolve>    flags include coll end 
 CNSsolve>  else 
 CNSsolve>    evaluate ($Data.flags.rg = false) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>{* random removal of restaints ================================== *} 
 CNSsolve>if ($Data.noecv eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  set message=on echo=on end 
 CNSsolve>  noe cv $npart ? end 
 NOE: total number of restraints:    24 partitioned into      2 classes
 NOE: ceiling=    1000.000 current allocation=12000000
 NOE: data are partitioned into working set and test set.
 NOE: test set number=     2
 CNSsolve>else 
 CNSsolve>  evaluate ($npart = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set message=normal echo=on end 
 CNSsolve>else 
 CNSsolve>   set message=off echo=off end 
 For set   1 there are    24 distance restraints.
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 -----nonbonded-list-options-------------------------------
 | CUTNb=   9.500 TOLErance=   0.500 WMIN=   0.500 ATOM   |
 | INHIbit=   0.250                                       |
 -----electrostatic options--------------------------------
 | EPS=  10.000 E14Fac=   0.400 RDIElectric POTEN SWITch  |
 -----van der Waals options--------------------------------
 | VSWItch                                                |
 -----switching /shifting parameters-----------------------
 | CTONNB=   6.500 CTOFNB=   8.500                        |
 -----exclusion list options-------------------------------
 | NBXMOD=   5                                            |
 ----------------------------------------------------------
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond HN   N3T 
 %PARRDR-info: duplication of angle CH2E C    NH1 
 %PARRDR-info: duplication of angle CR1E CR1E CY2 
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry OH  
 %PARRDR-info: duplication of nonbonded entry P   
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HN  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 EVALUATE: symbol $NCOUNT set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>  ! store original coordinates 
 CNSsolve>  do (refx = x) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>  do (refy = y) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>  do (refz = z) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate ($ncount = $ncount +1) 
 EVALUATE: symbol $NCOUNT set to    1.00000     (real)
 CNSsolve>    evaluate ($dim_$ncount = 0.0) 
 EVALUATE: symbol $DIM_1 set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>    !orient molecule 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount) end 
 SELRPN:   3166 atoms have been selected out of   3253
 COOR: using atom subset.
 MOMENTS
 426055.23367027 -74858.78121329  17012.32828387
                 237734.17980531  68318.91563594
                                 542466.85089582


 Oriented coordinate set r' related to original set r by r'=R*r  + T
 Translation vector T = (   16.8105   40.8989  -19.6316)

 Rotation matrix =
    0.978249    0.207257    0.008603
   -0.057975    0.312991   -0.947985
   -0.199169    0.926866    0.318199
 Corresp. Eulerian angles (theta1,theta2,theta3)   192.1275   71.4460  179.4801
 Corresp. spherical polar angles (psi,phi,kappa)    83.7381    8.0521  287.7413
 Corresp. rotation angle    72.2587 about axis      -0.9842   -0.1091    0.1392
 Corresp. quaternions     0.8077   -0.5803   -0.0643    0.0821

 CNSsolve> 
 CNSsolve>    ! find dimensions 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:    337 atoms have been selected out of   3253
 SHOW: maximum of selected elements =      27.640603
 CNSsolve>    evaluate ($xdim = $result) 
 EVALUATE: symbol $XDIM set to    27.6406     (real)
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:    337 atoms have been selected out of   3253
 SHOW: maximum of selected elements =      23.508431
 CNSsolve>    evaluate ($ydim = $result) 
 EVALUATE: symbol $YDIM set to    23.5084     (real)
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:    337 atoms have been selected out of   3253
 SHOW: maximum of selected elements =      15.507353
 CNSsolve>    evaluate ($zdim = $result) 
 EVALUATE: symbol $ZDIM set to    15.5074     (real)
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:    337 atoms have been selected out of   3253
 SHOW: minimum of selected elements =     -24.948901
 CNSsolve>    evaluate ($xdim = $xdim - $result) 
 EVALUATE: symbol $XDIM set to    52.5895     (real)
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:    337 atoms have been selected out of   3253
 SHOW: minimum of selected elements =     -26.537704
 CNSsolve>    evaluate ($ydim = $ydim - $result) 
 EVALUATE: symbol $YDIM set to    50.0461     (real)
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:    337 atoms have been selected out of   3253
 SHOW: minimum of selected elements =     -15.748110
 CNSsolve>    evaluate ($zdim = $zdim - $result) 
 EVALUATE: symbol $ZDIM set to    31.2555     (real)
 CNSsolve> 
 CNSsolve>    evaluate ($corr = max($xdim,$ydim)) 
 EVALUATE: symbol $CORR set to    52.5895     (real)
 CNSsolve>    evaluate ($corr = max($corr,$zdim)) 
 EVALUATE: symbol $CORR set to    52.5895     (real)
 CNSsolve> 
 CNSsolve>    if  ($data.cmtight eq false) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      ! use average of all three dimensions + 10A 
 CNSsolve>      evaluate ($dim_$ncount = ($xdim + $ydim + $zdim)/6.0) 
 CNSsolve>    else 
 CNSsolve>      ! use only the average of the smallest two dimensions 
 CNSsolve>      evaluate ($dim_$ncount = ($xdim + $ydim + $zdim - $corr)/4.0) 
 EVALUATE: symbol $DIM_1 set to    20.3254     (real)
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($toppar.dna_$ncount = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      ! Check first if not protein-DNA complex 
 CNSsolve>      do (store6 = 0) (all) 
 CNSsolve>      do (store6 = 1) (segid $Toppar.prot_segid_$ncount and (name CA or name BB)) 
 CNSsolve>      show sum (store6) (all) 
 CNSsolve>      if ($result eq 0) then 
 CNSsolve>        ! we are dealing with a nucleic acid - check if DNA or RNA 
 CNSsolve>        do (store6 = 0) (all) 
 CNSsolve>        do (store6 = 1) (resn DA or resn DT or resn DC or resn DG) 
 CNSsolve>        show sum (store6) (all) 
 CNSsolve>        if ($result > 0) then 
 CNSsolve>          ! we are delaing with DNA - set dimension to 0 
 CNSsolve>          evaluate ($dim_$ncount = 0.0) 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    do (store6 = 0) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>    do (store6 = 1) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:    337 atoms have been selected out of   3253
 CNSsolve>    show sum (store6) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 SHOW: sum over selected elements =     337.000000
 CNSsolve>    if ($result eq 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      ! we are dealing with a ligand set dimension to 0 
 CNSsolve>      evaluate ($dim_$ncount = 0.0) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate ($ncount = $ncount +1) 
 EVALUATE: symbol $NCOUNT set to    2.00000     (real)
 CNSsolve>    evaluate ($dim_$ncount = 0.0) 
 EVALUATE: symbol $DIM_2 set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>    !orient molecule 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount) end 
 SELRPN:     87 atoms have been selected out of   3253
 COOR: using atom subset.
 MOMENTS
    630.26491254    447.74286053    -22.64319381
                   1620.54819220   -267.37784664
                                    820.95326400


 Oriented coordinate set r' related to original set r by r'=R*r  + T
 Translation vector T = (   -2.0572    9.5683   14.5973)

 Rotation matrix =
    0.242141   -0.910007   -0.336535
    0.944813    0.142267    0.295108
   -0.220673   -0.389420    0.894235
 Corresp. Eulerian angles (theta1,theta2,theta3)   330.4611   26.5897  311.2476
 Corresp. spherical polar angles (psi,phi,kappa)    86.6462   69.7432   81.9914
 Corresp. rotation angle    81.9914 about axis       0.3456    0.0585   -0.9365
 Corresp. quaternions     0.7548    0.2267    0.0384   -0.6144

 CNSsolve> 
 CNSsolve>    ! find dimensions 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:      9 atoms have been selected out of   3253
 SHOW: maximum of selected elements =       6.944224
 CNSsolve>    evaluate ($xdim = $result) 
 EVALUATE: symbol $XDIM set to    6.94422     (real)
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:      9 atoms have been selected out of   3253
 SHOW: maximum of selected elements =       3.052151
 CNSsolve>    evaluate ($ydim = $result) 
 EVALUATE: symbol $YDIM set to    3.05215     (real)
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:      9 atoms have been selected out of   3253
 SHOW: maximum of selected elements =       2.736832
 CNSsolve>    evaluate ($zdim = $result) 
 EVALUATE: symbol $ZDIM set to    2.73683     (real)
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:      9 atoms have been selected out of   3253
 SHOW: minimum of selected elements =      -7.365284
 CNSsolve>    evaluate ($xdim = $xdim - $result) 
 EVALUATE: symbol $XDIM set to    14.3095     (real)
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:      9 atoms have been selected out of   3253
 SHOW: minimum of selected elements =      -2.385673
 CNSsolve>    evaluate ($ydim = $ydim - $result) 
 EVALUATE: symbol $YDIM set to    5.43782     (real)
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:      9 atoms have been selected out of   3253
 SHOW: minimum of selected elements =      -3.230333
 CNSsolve>    evaluate ($zdim = $zdim - $result) 
 EVALUATE: symbol $ZDIM set to    5.96716     (real)
 CNSsolve> 
 CNSsolve>    evaluate ($corr = max($xdim,$ydim)) 
 EVALUATE: symbol $CORR set to    14.3095     (real)
 CNSsolve>    evaluate ($corr = max($corr,$zdim)) 
 EVALUATE: symbol $CORR set to    14.3095     (real)
 CNSsolve> 
 CNSsolve>    if  ($data.cmtight eq false) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      ! use average of all three dimensions + 10A 
 CNSsolve>      evaluate ($dim_$ncount = ($xdim + $ydim + $zdim)/6.0) 
 CNSsolve>    else 
 CNSsolve>      ! use only the average of the smallest two dimensions 
 CNSsolve>      evaluate ($dim_$ncount = ($xdim + $ydim + $zdim - $corr)/4.0) 
 EVALUATE: symbol $DIM_2 set to    2.85125     (real)
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($toppar.dna_$ncount = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      ! Check first if not protein-DNA complex 
 CNSsolve>      do (store6 = 0) (all) 
 CNSsolve>      do (store6 = 1) (segid $Toppar.prot_segid_$ncount and (name CA or name BB)) 
 CNSsolve>      show sum (store6) (all) 
 CNSsolve>      if ($result eq 0) then 
 CNSsolve>        ! we are dealing with a nucleic acid - check if DNA or RNA 
 CNSsolve>        do (store6 = 0) (all) 
 CNSsolve>        do (store6 = 1) (resn DA or resn DT or resn DC or resn DG) 
 CNSsolve>        show sum (store6) (all) 
 CNSsolve>        if ($result > 0) then 
 CNSsolve>          ! we are delaing with DNA - set dimension to 0 
 CNSsolve>          evaluate ($dim_$ncount = 0.0) 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    do (store6 = 0) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>    do (store6 = 1) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 SELRPN:      9 atoms have been selected out of   3253
 CNSsolve>    show sum (store6) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 SHOW: sum over selected elements =       9.000000
 CNSsolve>    if ($result eq 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      ! we are dealing with a ligand set dimension to 0 
 CNSsolve>      evaluate ($dim_$ncount = 0.0) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate ($ncount = $ncount +1) 
 CNSsolve>    evaluate ($dim_$ncount = 0.0) 
 CNSsolve> 
 CNSsolve>    !orient molecule 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount) end 
 CNSsolve> 
 CNSsolve>    ! find dimensions 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 CNSsolve>    evaluate ($xdim = $result) 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 CNSsolve>    evaluate ($ydim = $result) 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 CNSsolve>    evaluate ($zdim = $result) 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 CNSsolve>    evaluate ($xdim = $xdim - $result) 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 CNSsolve>    evaluate ($ydim = $ydim - $result) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 CNSsolve>    evaluate ($zdim = $zdim - $result) 
 CNSsolve> 
 CNSsolve>    evaluate ($corr = max($xdim,$ydim)) 
 CNSsolve>    evaluate ($corr = max($corr,$zdim)) 
 CNSsolve> 
 CNSsolve>    if  ($data.cmtight eq false) then 
 CNSsolve>      ! use average of all three dimensions + 10A 
 CNSsolve>      evaluate ($dim_$ncount = ($xdim + $ydim + $zdim)/6.0) 
 CNSsolve>    else 
 CNSsolve>      ! use only the average of the smallest two dimensions 
 CNSsolve>      evaluate ($dim_$ncount = ($xdim + $ydim + $zdim - $corr)/4.0) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($toppar.dna_$ncount = true) then 
 CNSsolve>      ! Check first if not protein-DNA complex 
 CNSsolve>      do (store6 = 0) (all) 
 CNSsolve>      do (store6 = 1) (segid $Toppar.prot_segid_$ncount and (name CA or name BB)) 
 CNSsolve>      show sum (store6) (all) 
 CNSsolve>      if ($result eq 0) then 
 CNSsolve>        ! we are dealing with a nucleic acid - check if DNA or RNA 
 CNSsolve>        do (store6 = 0) (all) 
 CNSsolve>        do (store6 = 1) (resn DA or resn DT or resn DC or resn DG) 
 CNSsolve>        show sum (store6) (all) 
 CNSsolve>        if ($result > 0) then 
 CNSsolve>          ! we are delaing with DNA - set dimension to 0 
 CNSsolve>          evaluate ($dim_$ncount = 0.0) 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    do (store6 = 0) (all) 
 CNSsolve>    do (store6 = 1) (segid $Toppar.prot_segid_$ncount and (name CA or name BB or name N1)) 
 CNSsolve>    show sum (store6) (all) 
 CNSsolve>    if ($result eq 0) then 
 CNSsolve>      ! we are dealing with a ligand set dimension to 0 
 CNSsolve>      evaluate ($dim_$ncount = 0.0) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  ! restore original coordinates 
 CNSsolve>  do (x = refx) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>  do (y = refy) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>  do (z = refz) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>  eval($nchain = 0) 
 EVALUATE: symbol $NCHAIN set to    0.00000     (real)
 CNSsolve>  do (store9 = 0) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>  do (store9 = 1) (name CA or name BB or name N1) 
 SELRPN:    346 atoms have been selected out of   3253
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    1.00000     (real)
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 SELRPN:   3166 atoms have been selected out of   3253
 SHOW: sum over selected elements =     337.000000
 CNSsolve>    if ($result < 3) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($selat$nchain = 0 ) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1 ) 
 EVALUATE: symbol $SELAT1 set to    1.00000     (real)
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    2.00000     (real)
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 SELRPN:     87 atoms have been selected out of   3253
 SHOW: sum over selected elements =       9.000000
 CNSsolve>    if ($result < 3) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($selat$nchain = 0 ) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1 ) 
 EVALUATE: symbol $SELAT2 set to    1.00000     (real)
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($nchain = $nchain + 1) 
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 CNSsolve>    if ($result < 3) then 
 CNSsolve>      evaluate ($selat$nchain = 0 ) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1 ) 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>  noe 
 NOE>    class contact 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 NOE>      eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 NOE>      eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    1.00000     (real)
 NOE>      if ($Toppar.shape_$nchain1 eq false) then 
 NEXTCD: condition evaluated as true
 NOE>        while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as true
 NOE>          eval($nchain2 = $nchain2 + 1) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 NOE>          if ($Toppar.shape_$nchain2 eq false) then 
 NEXTCD: condition evaluated as true
 NOE>            if  ($data.cmtight eq false) then 
 NEXTCD: condition evaluated as false
 NOE>              eval($cm_dist = $dim_$nchain1 + $dim_$nchain2) 
 NOE>            else 
 NOE>              eval($cm_dist = ($dim_$nchain1 + $dim_$nchain2)/2 ) 
 EVALUATE: symbol $CM_DIST set to    11.5883     (real)
 NOE>            end if 
 NOE>            if ($selat$nchain1 = 1) then 
 NEXTCD: condition evaluated as true
 NOE>              if ($selat$nchain2 = 1) then 
 NEXTCD: condition evaluated as true
 NOE>                assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 SELRPN:    337 atoms have been selected out of   3253
 SELRPN>                   (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $cm_dist $cm_dist 1.0 
 SELRPN:      9 atoms have been selected out of   3253
 NOE>              else 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>              end if 
 NOE>            else 
 NOE>              if ($selat$nchain2 = 1) then 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>              else 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>              end if 
 NOE>            end if 
 NOE>          end if 
 NOE>        end loop nloop2 
 NOE>        while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 NOE>          eval($nchain2 = $nchain2 + 1) 
 NOE>          if ($Toppar.shape_$nchain2 eq false) then 
 NOE>            if  ($data.cmtight eq false) then 
 NOE>              eval($cm_dist = $dim_$nchain1 + $dim_$nchain2) 
 NOE>            else 
 NOE>              eval($cm_dist = ($dim_$nchain1 + $dim_$nchain2)/2 ) 
 NOE>            end if 
 NOE>            if ($selat$nchain1 = 1) then 
 NOE>              if ($selat$nchain2 = 1) then 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>              else 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>              end if 
 NOE>            else 
 NOE>              if ($selat$nchain2 = 1) then 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>              else 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>              end if 
 NOE>            end if 
 NOE>          end if 
 NOE>        end loop nloop2 
 NOE>      end if 
 NOE>    end loop nloop1 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 NOE>      eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 NOE>      eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 NOE>      if ($Toppar.shape_$nchain1 eq false) then 
 NEXTCD: condition evaluated as true
 NOE>        while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 NOE>          eval($nchain2 = $nchain2 + 1) 
 NOE>          if ($Toppar.shape_$nchain2 eq false) then 
 NOE>            if  ($data.cmtight eq false) then 
 NOE>              eval($cm_dist = $dim_$nchain1 + $dim_$nchain2) 
 NOE>            else 
 NOE>              eval($cm_dist = ($dim_$nchain1 + $dim_$nchain2)/2 ) 
 NOE>            end if 
 NOE>            if ($selat$nchain1 = 1) then 
 NOE>              if ($selat$nchain2 = 1) then 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>              else 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>              end if 
 NOE>            else 
 NOE>              if ($selat$nchain2 = 1) then 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>              else 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>              end if 
 NOE>            end if 
 NOE>          end if 
 NOE>        end loop nloop2 
 NOE>      end if 
 NOE>    end loop nloop1 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 NOE>      eval($nchain1 = $nchain1 + 1) 
 NOE>      eval($nchain2 = $nchain1 ) 
 NOE>      if ($Toppar.shape_$nchain1 eq false) then 
 NOE>        while ($nchain2 < $data.ncomponents) loop nloop2 
 NOE>          eval($nchain2 = $nchain2 + 1) 
 NOE>          if ($Toppar.shape_$nchain2 eq false) then 
 NOE>            if  ($data.cmtight eq false) then 
 NOE>              eval($cm_dist = $dim_$nchain1 + $dim_$nchain2) 
 NOE>            else 
 NOE>              eval($cm_dist = ($dim_$nchain1 + $dim_$nchain2)/2 ) 
 NOE>            end if 
 NOE>            if ($selat$nchain1 = 1) then 
 NOE>              if ($selat$nchain2 = 1) then 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>              else 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>              end if 
 NOE>            else 
 NOE>              if ($selat$nchain2 = 1) then 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>              else 
 NOE>                assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>                   (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>              end if 
 NOE>            end if 
 NOE>          end if 
 NOE>        end loop nloop2 
 NOE>      end if 
 NOE>    end loop nloop1 
 NOE> 
 NOE>    averaging  contact center 
 NOE>    scale      contact $Data.kcont 
 NOE>    sqconstant contact 1.0 
 NOE>    sqexponent contact 2 
 NOE>    soexponent contact 1 
 NOE>    rswitch    contact 1.0 
 NOE>    sqoffset   contact 0.0 
 NOE>    asymptote  contact 2.0 
 NOE>    msoexponent contact 1 
 NOE>    masymptote  contact -0.1 
 NOE>    mrswitch    contact 1.0 
 NOE>  end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.surfrest eq true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    @RUN:protocols/surf-restraints.cns 
 ASSFIL: file surf-restraints.cns opened.
 CNSsolve>! surf-restraints.cns 
 CNSsolve>!    Define surface contact restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>!define surface contact restraints between all molecules 
 CNSsolve>!using distance restraints between CA atoms with sum averaging 
 CNSsolve> 
 CNSsolve>  set echo=on message=on end 
 CNSsolve> 
 CNSsolve>  eval($nchain = 0) 
 EVALUATE: symbol $NCHAIN set to    0.00000     (real)
 CNSsolve>  do (store9 = 0) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>  do (store9 = 1) (name CA or name BB or name N1) 
 SELRPN:    346 atoms have been selected out of   3253
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    1.00000     (real)
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 SELRPN:   3166 atoms have been selected out of   3253
 SHOW: sum over selected elements =     337.000000
 CNSsolve>    if ($result < 3) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($selat$nchain = 0) 
 CNSsolve>      evaluate ($dist$nchain = 1.0) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1) 
 EVALUATE: symbol $SELAT1 set to    1.00000     (real)
 CNSsolve>      evaluate ($dist$nchain = 3.5) 
 EVALUATE: symbol $DIST1 set to    3.50000     (real)
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    2.00000     (real)
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 SELRPN:     87 atoms have been selected out of   3253
 SHOW: sum over selected elements =       9.000000
 CNSsolve>    if ($result < 3) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($selat$nchain = 0) 
 CNSsolve>      evaluate ($dist$nchain = 1.0) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1) 
 EVALUATE: symbol $SELAT2 set to    1.00000     (real)
 CNSsolve>      evaluate ($dist$nchain = 3.5) 
 EVALUATE: symbol $DIST2 set to    3.50000     (real)
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($nchain = $nchain + 1) 
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 CNSsolve>    if ($result < 3) then 
 CNSsolve>      evaluate ($selat$nchain = 0) 
 CNSsolve>      evaluate ($dist$nchain = 1.0) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1) 
 CNSsolve>      evaluate ($dist$nchain = 3.5) 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>  noe class surface 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 NOE>      eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 NOE>      eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    1.00000     (real)
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as true
 NOE>        eval($nchain2 = $nchain2 + 1) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 NOE>        evaluate ($updist = $dist$nchain1 + $dist$nchain2) 
 EVALUATE: symbol $UPDIST set to    7.00000     (real)
 NOE>        if ($selat$nchain1 = 1) then 
 NEXTCD: condition evaluated as true
 NOE>          if ($selat$nchain2 = 1) then 
 NEXTCD: condition evaluated as true
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 SELRPN:    337 atoms have been selected out of   3253
 SELRPN>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $updist $updist 1.0 
 SELRPN:      9 atoms have been selected out of   3253
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 NOE>        eval($nchain2 = $nchain2 + 1) 
 NOE>        evaluate ($updist = $dist$nchain1 + $dist$nchain2) 
 NOE>        if ($selat$nchain1 = 1) then 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>    end loop nloop1 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 NOE>      eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 NOE>      eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 NOE>        eval($nchain2 = $nchain2 + 1) 
 NOE>        evaluate ($updist = $dist$nchain1 + $dist$nchain2) 
 NOE>        if ($selat$nchain1 = 1) then 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>    end loop nloop1 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 NOE>      eval($nchain1 = $nchain1 + 1) 
 NOE>      eval($nchain2 = $nchain1 ) 
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NOE>        eval($nchain2 = $nchain2 + 1) 
 NOE>        evaluate ($updist = $dist$nchain1 + $dist$nchain2) 
 NOE>        if ($selat$nchain1 = 1) then 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name BB or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name BB or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>    end loop nloop1 
 NOE> 
 NOE>    averaging  surface sum 
 NOE>    scale      surface $Data.ksurf 
 NOE>    sqconstant surface 1.0 
 NOE>    sqexponent surface 2 
 NOE>    soexponent surface 1 
 NOE>    rswitch    surface 1.0 
 NOE>    sqoffset   surface 0.0 
 NOE>    asymptote  surface 2.0 
 NOE>    msoexponent surface 1 
 NOE>    masymptote  surface -0.1 
 NOE>    mrswitch    surface 1.0 
 NOE>  end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.flags.centroids eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      @RUN:protocols/centroids_initialize.cns 
 ASSFIL: file centroids_initialize.cns opened.
 CNSsolve>{Places DUM-residue on the center of each segid} 
 CNSsolve> 
 CNSsolve>eval($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    show ave(x) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.x = $RESULT) 
 CNSsolve>    show ave(y) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.y = $RESULT) 
 CNSsolve>    show ave(z) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.z = $RESULT) 
 CNSsolve> 
 CNSsolve>    do (x = $center.x) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>    do (y = $center.y) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>    do (z = $center.z) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>end loop nloop1 
 CNSsolve>      @RUN:protocols/centroids_set_map.cns 
 ASSFIL: file centroids_set_map.cns opened.
 CNSsolve>! set coordinates of centroids (MAP atom) 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $Data.ncomponents) loop nloop1 
 CNSsolve>    evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>    do (x = $Data.centroids.xcom_$nchain1) (segid $Toppar.prot_segid_$nchain1 and name MAP) 
 CNSsolve>    do (y = $Data.centroids.ycom_$nchain1) (segid $Toppar.prot_segid_$nchain1 and name MAP) 
 CNSsolve>    do (z = $Data.centroids.zcom_$nchain1) (segid $Toppar.prot_segid_$nchain1 and name MAP) 
 CNSsolve>end loop nloop1 
 CNSsolve>      noe scale centroid $data.centroids.kscale end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  flag excl ncs end 
 CNSsolve>  evaluate ($nrig = 0) 
 EVALUATE: symbol $NRIG set to    0.00000     (real)
 CNSsolve>  evaluate ($nfirst = 1) 
 EVALUATE: symbol $NFIRST set to    1.00000     (real)
 CNSsolve>  evaluate ($bestair = 0) 
 EVALUATE: symbol $BESTAIR set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>  if ($SaProtocol.rigidmini eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    while ($nrig < $SaProtocol.ntrials) loop trials 
 CNSsolve> 
 CNSsolve>      evaluate ($nrig = $nrig + 1) 
 CNSsolve> 
 CNSsolve>      if ( $log_level = verbose ) then 
 CNSsolve>        set message=normal echo=on end 
 CNSsolve>       else 
 CNSsolve>        set message=off echo=off end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      ! random placement of molecules 
 CNSsolve>      if ($SaProtocol.randorien eq true) then 
 CNSsolve>          @RUN:protocols/separate.cns(Data=$Data; Toppar=$Toppar) 
 ASSFIL: file separate.cns opened.
 CNSsolve>! separate.cns 
 CNSsolve>! Distribute molecules in 3D space 
 CNSsolve>! Orient each molecule according to its principal axes 
 CNSsolve>! and restore them all at the end (after the while loop) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve> 
 CNSsolve>! first flag all fixed molecules 
 CNSsolve>do (store4 = 0) (all) 
 CNSsolve>evaluate ($ncount = 0) 
 CNSsolve>evaluate ($nfixed = 0) 
 CNSsolve>while ($ncount < $data.ncomponents) loop orientmol 
 CNSsolve>  evaluate ($ncount = $ncount + 1) 
 CNSsolve>  if ($Toppar.fix_origin_$ncount eq true) then 
 CNSsolve>    evaluate ($nfixed = $nfixed + 1) 
 CNSsolve>    do (store4 = 1) (segid $Toppar.prot_segid_$ncount) 
 CNSsolve>  end if 
 CNSsolve>end loop orientmol 
 CNSsolve> 
 CNSsolve>if ($nfixed < $data.ncomponents) then 
 CNSsolve> 
 CNSsolve>    evaluate ($xc = 0.0) 
 CNSsolve>    evaluate ($yc = 0.0) 
 CNSsolve>    evaluate ($zc = 0.0) 
 CNSsolve>    ! then define the geometrical center of the fixed molecules if present 
 CNSsolve>    show sum (store4) (all) 
 CNSsolve>    if ($result > 0) then 
 CNSsolve>      show ave (x) (attribute store4 = 1) 
 CNSsolve>      evaluate ($xc = $result) 
 CNSsolve>      show ave (y) (attribute store4 = 1) 
 CNSsolve>      evaluate ($yc = $result) 
 CNSsolve>      show ave (z) (attribute store4 = 1) 
 CNSsolve>      evaluatee ($zc = $result) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    do (xcomp = x) (all) 
 CNSsolve>    do (ycomp = y) (all) 
 CNSsolve>    do (zcomp = z) (all) 
 CNSsolve> 
 CNSsolve>    ! then orient each moving molecule separately at the origin 
 CNSsolve>    ! and translate it to the geometric center of the fixed molecules 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop orientmol 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      eval($watersegname_$ncount="WA" + encode($ncount)) 
 CNSsolve>      if ($Toppar.fix_origin_$ncount eq false) then 
 CNSsolve>        coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>        coor sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) translate vector = ($xc $yc $zc) end 
 CNSsolve>        do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>        do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>        do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      end if 
 CNSsolve>    end loop orientmol 
 CNSsolve> 
 CNSsolve>    do (x = xcomp) (not (resn ANI or resn XAN or resn DAN)) 
 CNSsolve>    do (y = ycomp) (not (resn ANI or resn XAN or resn DAN)) 
 CNSsolve>    do (z = zcomp) (not (resn ANI or resn XAN or resn DAN)) 
 CNSsolve> 
 CNSsolve>    ! Find the largest axis of all molecules 
 CNSsolve>    evaluate ($minispacing = 25.0) 
 CNSsolve>    evaluate ($mxdim = 0) 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>    while ($ncount < $data.ncomponents) loop findmax 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve> 
 CNSsolve>      show max (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdim = $result) 
 CNSsolve>      show min (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdim = $xdim - $result) 
 CNSsolve> 
 CNSsolve>      show max (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydim = $result) 
 CNSsolve>      show min (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydim = $ydim - $result) 
 CNSsolve> 
 CNSsolve>      show max (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdim = $result) 
 CNSsolve>      show min (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdim = $zdim - $result) 
 CNSsolve> 
 CNSsolve>      ! Check which dimension (x,y,z) is the largest = mxdim 
 CNSsolve>      evaluate ($mxdim = max($mxdim, $xdim, $ydim, $zdim)) 
 CNSsolve> 
 CNSsolve>    end loop findmax 
 CNSsolve> 
 CNSsolve>    evaluate ($spacing = $minispacing + $mxdim ) 
 CNSsolve>    display SPACING SET TO $spacing ANGSTROM 
 CNSsolve> 
 CNSsolve>    ! This has to be manually coded because of the variable name 
 CNSsolve>    ! Should be fine since we support only a few types of symmetry 
 CNSsolve>    ! Maybe change the variable name later if these are expanded 
 CNSsolve>    ! to have the number at the end? 
 CNSsolve> 
 CNSsolve>    inline @RUN:protocols/check-homomers.cns 
 ASSFIL: file check-homomers.cns opened.
 CNSsolve>! check-homomers.cns 
 CNSsolve>! check for homomeric complexes 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  evaluate ($homosymmetry = false) 
 CNSsolve> 
 CNSsolve>  evaluate($n_moving_mol = 0) 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.ncomponents) loop checkmol 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    if ($Toppar.shape_$ncount eq false) then 
 CNSsolve>      evaluate($n_moving_mol = $n_moving_mol + 1) 
 CNSsolve>    end if 
 CNSsolve>  end loop checkmol 
 CNSsolve> 
 CNSsolve>  if ($data.flags.sym eq true) then 
 CNSsolve>    if ($data.numc2sym > 0) then 
 CNSsolve>      if ($n_moving_mol = 2) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($data.numc2sym = 6) then 
 CNSsolve>      if ($n_moving_mol = 4) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($data.numc3sym > 0) then 
 CNSsolve>      if ($n_moving_mol = 3) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($data.numc4sym > 0) then 
 CNSsolve>      if ($n_moving_mol = 4) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($data.numc5sym > 0) then 
 CNSsolve>      if ($n_moving_mol = 5) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($data.numc6sym > 0) then 
 CNSsolve>      if ($n_moving_mol = 6) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    if ($homosymmetry eq true) then 
 CNSsolve>      ! In case of homosymmetry, place molecules in a plane 
 CNSsolve>      do (store4 = 0) (all) 
 CNSsolve>      evaluate ($ncount = 0) 
 CNSsolve>      while ($ncount < $data.ncomponents) loop orientmol 
 CNSsolve>        evaluate ($ncount = $ncount + 1) 
 CNSsolve>        if ($Toppar.fix_origin_$ncount eq false) then 
 CNSsolve>          do (store4 = 1) (segid $Toppar.prot_segid_$ncount) 
 CNSsolve>        end if 
 CNSsolve>      end loop orientmol 
 CNSsolve> 
 CNSsolve>      {* translate and generate symmetric positions by rotation around z *} 
 CNSsolve>      coor trans sele=(attr store4=1) vector=($spacing,0,0) end 
 CNSsolve> 
 CNSsolve>      ! if one molecule is fixed (e.g. plane), move all others along z-axis 
 CNSsolve>      !if ($data.ncomponents > $n_moving_mol) then 
 CNSsolve>      !  coor trans sele=(attr store4=1) vector=(0,0,$spacing) end 
 CNSsolve>      !end if 
 CNSsolve> 
 CNSsolve>      evaluate ($ncount = 2) 
 CNSsolve>      evaluate ($increment = 360/$n_moving_mol) 
 CNSsolve>      while ($ncount le $data.ncomponents) loop orientsym 
 CNSsolve> 
 CNSsolve>        if ($Toppar.fix_origin_$ncount eq false) then 
 CNSsolve> 
 CNSsolve>          {* rotate around z axis *} 
 CNSsolve>          evaluate ($xr = $increment) 
 CNSsolve>          evaluate ($x1 = cos($xr)) 
 CNSsolve>          evaluate ($x2 = -sin($xr)) 
 CNSsolve>          evaluate ($x3 = 0 ) 
 CNSsolve>          evaluate ($y1 = sin($xr)) 
 CNSsolve>          evaluate ($y2 = cos($xr)) 
 CNSsolve>          evaluate ($y3 = 0 ) 
 CNSsolve>          evaluate ($z1 = 0 ) 
 CNSsolve>          evaluate ($z2 = 0 ) 
 CNSsolve>          evaluate ($z3 = 1 ) 
 CNSsolve>          coor 
 CNSsolve>            center=($xc $yc $zc) 
 CNSsolve>            rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>            sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>          end 
 CNSsolve>          evaluate ($increment = $xr + 360/$n_moving_mol) 
 CNSsolve> 
 CNSsolve>        end if 
 CNSsolve>      evaluate ($ncount = $ncount + 1) 
 CNSsolve> 
 CNSsolve>      end loop orientsym 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      ! Do we need fix any molecule? 
 CNSsolve>      evaluate($n_moving_mol = 0) 
 CNSsolve>      evaluate ($ncount = 0) 
 CNSsolve>      while ($ncount < $data.ncomponents) loop centermol 
 CNSsolve>        evaluate ($ncount = $ncount + 1) 
 CNSsolve>        if ($Toppar.fix_origin_$ncount eq false) then 
 CNSsolve>          evaluate($n_moving_mol = $n_moving_mol + 1) 
 CNSsolve>        end if 
 CNSsolve>      end loop centermol 
 CNSsolve> 
 CNSsolve>      ! Translate molecules to positions calculated using an algorithm 
 CNSsolve>      ! based on minimization of electrostatic potential of N equally charged particles. 
 CNSsolve>      ! See Thomson problem: http://en.wikipedia.org/wiki/Thomson_problem 
 CNSsolve>      evaluate ($filename = "RUN:toppar/initial_positions/trans_vector_" + encode($n_moving_mol) ) 
 CNSsolve>      inline @@$filename 
 CNSsolve> 
 CNSsolve>      ! Logic: 
 CNSsolve>      ! Assign a random number larger than 0 to every molecule 
 CNSsolve>      ! Assign 0.0 to fixed molecules 
 CNSsolve>      ! For every i up to the number of molecules 
 CNSsolve>      ! pick the mol with the largest number and displace it 
 CNSsolve>      ! then zero its number. 
 CNSsolve>      ! This will place molecules in space sort of randomly 
 CNSsolve>      ! Stop when the sum of all numbers is zero 
 CNSsolve> 
 CNSsolve>      ! Generate as many random numbers as the # of mols 
 CNSsolve>      evaluate ($ncount = 0) 
 CNSsolve>      while ($ncount < $data.ncomponents) loop genrandom 
 CNSsolve>        evaluate ($ncount = $ncount + 1) 
 CNSsolve>        if ($Toppar.fix_origin_$ncount eq true) then 
 CNSsolve>          evaluate ($random_$ncount = 0.0) 
 CNSsolve>        else 
 CNSsolve>          evaluate ($random_$ncount = random()) 
 CNSsolve>        end if 
 CNSsolve>      end loop genrandom 
 CNSsolve> 
 CNSsolve>      ! Randomly pick a molecule and place it 
 CNSsolve>      ! on the pre-defined position - iterate 
 CNSsolve>      evaluate ($sum_random = 999) 
 CNSsolve>      evaluate ($molcounter = 1) 
 CNSsolve> 
 CNSsolve>      while ($sum_random > 0) loop placemol 
 CNSsolve>          evaluate ($maximum = 0) 
 CNSsolve>          evaluate ($maxid = 0) 
 CNSsolve>          evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>          ! Select molecule with largest random number 
 CNSsolve>          while ($ncount < $data.ncomponents) loop selectmol 
 CNSsolve>            evaluate ($ncount = $ncount + 1) 
 CNSsolve>            if ($random_$ncount > $maximum) then 
 CNSsolve>              evaluate ($maximum = $random_$ncount) 
 CNSsolve>              evaluate ($maxid = $ncount) 
 CNSsolve>            end if 
 CNSsolve>          end loop selectmol 
 CNSsolve> 
 CNSsolve>          if ($Toppar.fix_origin_$maxid eq false) then 
 CNSsolve>            coor trans 
 CNSsolve>  	       sele=(segid $Toppar.prot_segid_$maxid or segid $watersegname_$maxid) 
 CNSsolve>  	       vector=($x_$molcounter, $y_$molcounter, $z_$molcounter) end 
 CNSsolve> 
 CNSsolve>            ! Reset random_ncount to 0 to avoid re-selecting 
 CNSsolve>            evaluate ($random_$maxid = 0) 
 CNSsolve> 
 CNSsolve>            ! Increment molcounter to update new 
 CNSsolve>            evaluate ($molcounter = $molcounter + 1) 
 CNSsolve> 
 CNSsolve>            ! Update sum_random 
 CNSsolve>            evaluate ($ncount = 0) 
 CNSsolve>            evaluate ($sum_random = 0) 
 CNSsolve> 
 CNSsolve>            while ($ncount < $data.ncomponents) loop resetsumrandom 
 CNSsolve>              evaluate ($ncount = $ncount + 1) 
 CNSsolve>              evaluate( $sum_random = $sum_random + $random_$ncount) 
 CNSsolve>            end loop resetsumrandom 
 CNSsolve> 
 CNSsolve>          end if 
 CNSsolve>      end loop placemol 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>    do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>    do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> end if 
 CNSsolve> 
 CNSsolve>          @RUN:protocols/random_rotations.cns 
 ASSFIL: file random_rotations.cns opened.
 CNSsolve>! random_rotations.cns 
 CNSsolve>!    Perform a random rotation 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>! check if homomer 
 CNSsolve> 
 CNSsolve>inline @RUN:protocols/check-homomers.cns 
 ASSFIL: file check-homomers.cns opened.
 CNSsolve>! check-homomers.cns 
 CNSsolve>! check for homomeric complexes 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  evaluate ($homosymmetry = false) 
 CNSsolve> 
 CNSsolve>  evaluate($n_moving_mol = 0) 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.ncomponents) loop checkmol 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    if ($Toppar.shape_$ncount eq false) then 
 CNSsolve>      evaluate($n_moving_mol = $n_moving_mol + 1) 
 CNSsolve>    end if 
 CNSsolve>  end loop checkmol 
 CNSsolve> 
 CNSsolve>  if ($data.flags.sym eq true) then 
 CNSsolve>    if ($data.numc2sym > 0) then 
 CNSsolve>      if ($n_moving_mol = 2) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($data.numc2sym = 6) then 
 CNSsolve>      if ($n_moving_mol = 4) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($data.numc3sym > 0) then 
 CNSsolve>      if ($n_moving_mol = 3) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($data.numc4sym > 0) then 
 CNSsolve>      if ($n_moving_mol = 4) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($data.numc5sym > 0) then 
 CNSsolve>      if ($n_moving_mol = 5) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($data.numc6sym > 0) then 
 CNSsolve>      if ($n_moving_mol = 6) then 
 CNSsolve>        evaluate ($homosymmetry = true) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>do (store4 = 0) (all) 
 CNSsolve>evaluate ($ncount = 0) 
 CNSsolve>while ($ncount < $data.ncomponents) loop fixed 
 CNSsolve>  evaluate ($ncount = $ncount + 1) 
 CNSsolve>  if ($Toppar.fix_origin_$ncount eq true) then 
 CNSsolve>    do (store4 = 1) (segid $Toppar.prot_segid_$ncount) 
 CNSsolve>  end if 
 CNSsolve>end loop fixed 
 CNSsolve> 
 CNSsolve>if ($homosymmetry eq false) then 
 CNSsolve>  ! Random translation within a 10A cube 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.ncomponents) loop randtrans 
 CNSsolve>    evaluate ($ncount = $ncount +1) 
 CNSsolve>    if ($Toppar.fix_origin_$ncount eq false) then 
 CNSsolve>      evaluate ($xd = 10.0 * (0.5 - ran())) 
 CNSsolve>      evaluate ($yd = 10.0 * (0.5 - ran())) 
 CNSsolve>      evaluate ($zd = 10.0 * (0.5 - ran())) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xd,$yd,$zd) end 
 CNSsolve>    end if 
 CNSsolve>  end loop randtrans 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! Random rotation of molecules 
 CNSsolve>evaluate ($ncount = 0) 
 CNSsolve>evaluate ($nrotset = 0) 
 CNSsolve>while ($ncount < $data.ncomponents) loop randrot 
 CNSsolve>  evaluate ($ncount = $ncount +1) 
 CNSsolve>  if ($Toppar.fix_origin_$ncount eq false) then 
 CNSsolve>    show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    evaluate ($xc = $result) 
 CNSsolve>    show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    evaluate ($yc = $result) 
 CNSsolve>    show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    evaluate ($zc = $result) 
 CNSsolve> 
 CNSsolve>    ! Random rotation for each molecule except for symmtrical homomers for which 
 CNSsolve>    ! the same rotation is applied to all molecules to keep the symmetry 
 CNSsolve>    if ($nrotset = 0) then 
 CNSsolve>      !1. Generate random e1 e2 e3 and e4 in [-1, 1] so that e1^2 + e2^2 < 1 and e3^2+e4^2 < 1 
 CNSsolve>      evaluate ($RRM_e1 = ran () * 2 - 1) 
 CNSsolve>      evaluate ($RRM_e2 = ran () * 2 - 1) 
 CNSsolve>      evaluate ($RRM_s1 = ($RRM_e1)*($RRM_e1) + ($RRM_e2)*($RRM_e2)) 
 CNSsolve> 
 CNSsolve>      while ( $RRM_s1  >= 1) loop s1loop 
 CNSsolve>        evaluate ($RRM_e1 = ran () * 2 - 1) 
 CNSsolve>        evaluate ($RRM_e2 = ran () * 2 - 1) 
 CNSsolve>        evaluate ($RRM_s1 = ($RRM_e1)*($RRM_e1) + ($RRM_e2)*($RRM_e2)) 
 CNSsolve>      end loop s1loop 
 CNSsolve> 
 CNSsolve>      evaluate ($RRM_e3 = ran () * 2 - 1) 
 CNSsolve>      evaluate ($RRM_e4 = ran () * 2 - 1) 
 CNSsolve>      evaluate ($RRM_s2 = ($RRM_e3)*($RRM_e3) + ($RRM_e4)*($RRM_e4)) 
 CNSsolve>      while ( $RRM_s2  >= 1) loop s2loop 
 CNSsolve>        evaluate ($RRM_e3 = ran () * 2 - 1) 
 CNSsolve>        evaluate ($RRM_e4 = ran () * 2 - 1) 
 CNSsolve>        evaluate ($RRM_s2 = ($RRM_e3)*($RRM_e3) + ($RRM_e4)*($RRM_e4)) 
 CNSsolve>      end loop s2loop 
 CNSsolve> 
 CNSsolve>      !2. the quaternion q0 q1 q2 q3 
 CNSsolve>      evaluate($RRM_q0 = $RRM_e1) 
 CNSsolve>      evaluate($RRM_q1 = $RRM_e2) 
 CNSsolve>      evaluate($RRM_q2 = $RRM_e3 * sqrt((1 - $RRM_s1)/$RRM_s2) ) 
 CNSsolve>      evaluate($RRM_q3 = $RRM_e4 * sqrt((1 - $RRM_s1)/$RRM_s2) ) 
 CNSsolve> 
 CNSsolve>      !3. The rotation matrix from the quaternion 
 CNSsolve>      evaluate ($x1 = $RRM_q0 * $RRM_q0  +  $RRM_q1 * $RRM_q1  -  $RRM_q2 * $RRM_q2  -  $RRM_q3 * $RRM_q3) 
 CNSsolve>      evaluate ($x2 = 2 * ($RRM_q1 * $RRM_q2 - $RRM_q0 * $RRM_q3) ) 
 CNSsolve>      evaluate ($x3 = 2 * ($RRM_q1 * $RRM_q3 + $RRM_q0 * $RRM_q2) ) 
 CNSsolve>      evaluate ($y1 = 2 * ($RRM_q1 * $RRM_q2 + $RRM_q0 * $RRM_q3) ) 
 CNSsolve>      evaluate ($y2 = $RRM_q0 * $RRM_q0  -  $RRM_q1 * $RRM_q1  +  $RRM_q2 * $RRM_q2  -  $RRM_q3 * $RRM_q3) 
 CNSsolve>      evaluate ($y3 = 2 * ($RRM_q2 * $RRM_q3 - $RRM_q0 * $RRM_q1) ) 
 CNSsolve>      evaluate ($z1 = 2 * ($RRM_q1 * $RRM_q3 - $RRM_q0 * $RRM_q2) ) 
 CNSsolve>      evaluate ($z2 = 2 * ($RRM_q2 * $RRM_q3 + $RRM_q0 * $RRM_q1) ) 
 CNSsolve>      evaluate ($z3 = $RRM_q0 * $RRM_q0  -  $RRM_q1 * $RRM_q1  -  $RRM_q2 * $RRM_q2  +  $RRM_q3 * $RRM_q3) 
 CNSsolve> 
 CNSsolve>      if ($homosymmetry eq true) then 
 CNSsolve>        evaluate ($nrotset = 1) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    !4. The rotation 
 CNSsolve>    coor 
 CNSsolve>      center=($xc $yc $zc) 
 CNSsolve>      rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>      sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    end 
 CNSsolve>  end if 
 CNSsolve>end loop randrot 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! If there are fixed molecules, randomly rotate as one unit all non-fixed ones 
 CNSsolve>! around the geometric center of the fixed ones 
 CNSsolve> 
 CNSsolve>show sum (store4) (all) 
 CNSsolve> 
 CNSsolve>if ($result > 0) then 
 CNSsolve> 
 CNSsolve>    show ave (x) (attribute store4 = 1) 
 CNSsolve>    evaluate ($xc = $result) 
 CNSsolve>    show ave (y) (attribute store4 = 1) 
 CNSsolve>    evaluate ($yc = $result) 
 CNSsolve>    show ave (z) (attribute store4 = 1) 
 CNSsolve>    evaluate ($zc = $result) 
 CNSsolve> 
 CNSsolve>    ! Random rotation for each molecule except for symmtrical homomers for which 
 CNSsolve>    ! the same rotation is applied to all molecules to keep the symmetry 
 CNSsolve>    if ($nrotset = 0) then 
 CNSsolve>      !1. Generate random e1 e2 e3 and e4 in [-1, 1] so that e1^2 + e2^2 < 1 and e3^2+e4^2 < 1 
 CNSsolve>      evaluate ($RRM_e1 = ran () * 2 - 1) 
 CNSsolve>      evaluate ($RRM_e2 = ran () * 2 - 1) 
 CNSsolve>      evaluate ($RRM_s1 = ($RRM_e1)*($RRM_e1) + ($RRM_e2)*($RRM_e2)) 
 CNSsolve> 
 CNSsolve>      while ( $RRM_s1  >= 1) loop s1loop 
 CNSsolve>        evaluate ($RRM_e1 = ran () * 2 - 1) 
 CNSsolve>        evaluate ($RRM_e2 = ran () * 2 - 1) 
 CNSsolve>        evaluate ($RRM_s1 = ($RRM_e1)*($RRM_e1) + ($RRM_e2)*($RRM_e2)) 
 CNSsolve>      end loop s1loop 
 CNSsolve> 
 CNSsolve>      evaluate ($RRM_e3 = ran () * 2 - 1) 
 CNSsolve>      evaluate ($RRM_e4 = ran () * 2 - 1) 
 CNSsolve>      evaluate ($RRM_s2 = ($RRM_e3)*($RRM_e3) + ($RRM_e4)*($RRM_e4)) 
 CNSsolve>      while ( $RRM_s2  >= 1) loop s2loop 
 CNSsolve>        evaluate ($RRM_e3 = ran () * 2 - 1) 
 CNSsolve>        evaluate ($RRM_e4 = ran () * 2 - 1) 
 CNSsolve>        evaluate ($RRM_s2 = ($RRM_e3)*($RRM_e3) + ($RRM_e4)*($RRM_e4)) 
 CNSsolve>      end loop s2loop 
 CNSsolve> 
 CNSsolve>      !2. the quaternion q0 q1 q2 q3 
 CNSsolve>      evaluate($RRM_q0 = $RRM_e1) 
 CNSsolve>      evaluate($RRM_q1 = $RRM_e2) 
 CNSsolve>      evaluate($RRM_q2 = $RRM_e3 * sqrt((1 - $RRM_s1)/$RRM_s2) ) 
 CNSsolve>      evaluate($RRM_q3 = $RRM_e4 * sqrt((1 - $RRM_s1)/$RRM_s2) ) 
 CNSsolve> 
 CNSsolve>      !3. The rotation matrix from the quaternion 
 CNSsolve>      evaluate ($x1 = $RRM_q0 * $RRM_q0  +  $RRM_q1 * $RRM_q1  -  $RRM_q2 * $RRM_q2  -  $RRM_q3 * $RRM_q3) 
 CNSsolve>      evaluate ($x2 = 2 * ($RRM_q1 * $RRM_q2 - $RRM_q0 * $RRM_q3) ) 
 CNSsolve>      evaluate ($x3 = 2 * ($RRM_q1 * $RRM_q3 + $RRM_q0 * $RRM_q2) ) 
 CNSsolve>      evaluate ($y1 = 2 * ($RRM_q1 * $RRM_q2 + $RRM_q0 * $RRM_q3) ) 
 CNSsolve>      evaluate ($y2 = $RRM_q0 * $RRM_q0  -  $RRM_q1 * $RRM_q1  +  $RRM_q2 * $RRM_q2  -  $RRM_q3 * $RRM_q3) 
 CNSsolve>      evaluate ($y3 = 2 * ($RRM_q2 * $RRM_q3 - $RRM_q0 * $RRM_q1) ) 
 CNSsolve>      evaluate ($z1 = 2 * ($RRM_q1 * $RRM_q3 - $RRM_q0 * $RRM_q2) ) 
 CNSsolve>      evaluate ($z2 = 2 * ($RRM_q2 * $RRM_q3 + $RRM_q0 * $RRM_q1) ) 
 CNSsolve>      evaluate ($z3 = $RRM_q0 * $RRM_q0  -  $RRM_q1 * $RRM_q1  -  $RRM_q2 * $RRM_q2  +  $RRM_q3 * $RRM_q3) 
 CNSsolve> 
 CNSsolve>      if ($homosymmetry eq true) then 
 CNSsolve>        evaluate ($nrotset = 1) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    !4. The rotation 
 CNSsolve>    coor 
 CNSsolve>      center=($xc $yc $zc) 
 CNSsolve>      rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>      sele=(attribute store4 = 0) 
 CNSsolve>    end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>do (x = refx) (resn ANI or resn DAN or resn XAN or resn SHA) 
 CNSsolve>do (y = refy) (resn ANI or resn DAN or resn XAN or resn SHA) 
 CNSsolve>do (z = refz) (resn ANI or resn DAN or resn XAN or resn SHA) 
 CNSsolve> 
 CNSsolve>!evaluate ($outname = "RUN:" + "begin/" + $Filenames.fileroot + "_init_" + encode($count) + ".pdb") 
 CNSsolve>!write coor format=pdbo output=$outname end 
 CNSsolve>          if ($Data.flags.centroids eq true) then 
 CNSsolve>              ! place the centroids on their positions 
 CNSsolve>              @RUN:protocols/centroids_initialize.cns 
 ASSFIL: file centroids_initialize.cns opened.
 CNSsolve>{Places DUM-residue on the center of each segid} 
 CNSsolve> 
 CNSsolve>eval($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    show ave(x) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.x = $RESULT) 
 CNSsolve>    show ave(y) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.y = $RESULT) 
 CNSsolve>    show ave(z) (segid $Toppar.prot_segid_$nchain1 and (not name H*) and (not resn DUM)) 
 CNSsolve>    eval($center.z = $RESULT) 
 CNSsolve> 
 CNSsolve>    do (x = $center.x) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>    do (y = $center.y) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>    do (z = $center.z) (segid $Toppar.prot_segid_$nchain1 and resn DUM) 
 CNSsolve>end loop nloop1 
 CNSsolve>              @RUN:protocols/centroids_set_map.cns 
 ASSFIL: file centroids_set_map.cns opened.
 CNSsolve>! set coordinates of centroids (MAP atom) 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $Data.ncomponents) loop nloop1 
 CNSsolve>    evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>    do (x = $Data.centroids.xcom_$nchain1) (segid $Toppar.prot_segid_$nchain1 and name MAP) 
 CNSsolve>    do (y = $Data.centroids.ycom_$nchain1) (segid $Toppar.prot_segid_$nchain1 and name MAP) 
 CNSsolve>    do (z = $Data.centroids.zcom_$nchain1) (segid $Toppar.prot_segid_$nchain1 and name MAP) 
 CNSsolve>end loop nloop1 
 CNSsolve>              if ($fixmol eq false) then 
 CNSsolve>                  ! place the molecules around the centroids 
 CNSsolve>                  @RUN:protocols/centroids_init_placement.cns 
 ASSFIL: file centroids_init_placement.cns opened.
 CNSsolve>proc cross(in1; in2; out;) 
 PROC-BODY>    {Calculate the cross-product of two vectors} 
 PROC-BODY>    eval(&out.x = &in1.y * &in2.z - &in1.z * &in2.y) 
 PROC-BODY>    eval(&out.y = &in1.z * &in2.x - &in1.x * &in2.z) 
 PROC-BODY>    eval(&out.z = &in1.x * &in2.y - &in1.y * &in2.x) 
 PROC-BODY>endp 
 CNSsolve> 
 CNSsolve>proc get_angle(in1; in2; angle;) 
 PROC-BODY>    {Calculate the angle in degree between two vectors} 
 PROC-BODY>    call inner(in1=&in1; in2=&in2; out=$tmp) 
 PROC-BODY>    call norm(vec=&in1; norm=$norm1;) 
 PROC-BODY>    call norm(vec=&in2; norm=$norm2;) 
 PROC-BODY>    eval(&angle = acos($tmp / ($norm1 * $norm2))) 
 PROC-BODY>endp 
 CNSsolve> 
 CNSsolve>proc inner(in1; in2; out;) 
 PROC-BODY>    {In-product of two vectors} 
 PROC-BODY>    eval(&out = &in1.x * &in2.x + &in1.y * &in2.y + &in1.z * &in2.z) 
 PROC-BODY>endp 
 CNSsolve> 
 CNSsolve>proc norm(vec; norm;) 
 PROC-BODY>    {Calculates the norm of a vector} 
 PROC-BODY>    eval(&norm = sqrt(&vec.x**2 + &vec.y**2 + &vec.z**2)) 
 PROC-BODY>endp 
 CNSsolve> 
 CNSsolve>! get center of map coordinates 
 CNSsolve>show average(x) (name MAP) 
 CNSsolve>eval($map_ave.x = $RESULT) 
 CNSsolve>show average(y) (name MAP) 
 CNSsolve>eval($map_ave.y = $RESULT) 
 CNSsolve>show average(z) (name MAP) 
 CNSsolve>eval($map_ave.z = $RESULT) 
 CNSsolve> 
 CNSsolve>! determine whether the molecules should be placed in the same plane of the 
 CNSsolve>! centroids for symmetric systems 
 CNSsolve>eval($place_molecules_in_plane = false) 
 CNSsolve>if ($data.ncomponents > 2) then 
 CNSsolve>    if ($data.flags.sym = true) then 
 CNSsolve>        eval($place_molecules_in_plane = true) 
 CNSsolve>    end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! in case of c-symmetry get axis of symmetry from map-coordinates 
 CNSsolve>if ($place_molecules_in_plane = true) then 
 CNSsolve> 
 CNSsolve>    ! axis of symmetry is orthogonal to the symmetry plane 
 CNSsolve>    ! get two vectors representing the symmetry plane 
 CNSsolve>    eval($pq.x = $Data.centroids.xcom_1 - $map_ave.x) 
 CNSsolve>    eval($pq.y = $data.centroids.ycom_1 - $map_ave.y) 
 CNSsolve>    eval($pq.z = $data.centroids.zcom_1 - $map_ave.z) 
 CNSsolve>    eval($pr.x = $data.centroids.xcom_2 - $map_ave.x) 
 CNSsolve>    eval($pr.y = $data.centroids.ycom_2 - $map_ave.y) 
 CNSsolve>    eval($pr.z = $data.centroids.zcom_2 - $map_ave.z) 
 CNSsolve> 
 CNSsolve>    ! the axis of symmetry is orthogonal to the symmetry plane and 
 CNSsolve>    ! is the cross-product of those two vectors 
 CNSsolve>    call cross(in1=$pq; in2=$pr; out=$sym_axis;) 
 PROC-DECLARATION>(in1 ; in2 ; out ;) 
 PROC-INVOCATION>(in1=$pq; in2=$pr; out=$sym_axis;) 
 CNSsolve>    eval(&out.x = &in1.y * &in2.z - &in1.z * &in2.y) 
 CNSsolve>    eval(&out.y = &in1.z * &in2.x - &in1.x * &in2.z) 
 CNSsolve>    eval(&out.z = &in1.x * &in2.y - &in1.y * &in2.x)  
 CNSsolve> 
 CNSsolve>    ! get angle between the axis of symmetry and current symmetry z-axis 
 CNSsolve>    eval($z_axis.x = 0) 
 CNSsolve>    eval($z_axis.y = 0) 
 CNSsolve>    eval($z_axis.z = 1) 
 CNSsolve>    call get_angle(in1=$sym_axis; in2=$z_axis; angle=$angle) 
 PROC-DECLARATION>(in1 ; in2 ; angle ;) 
 PROC-INVOCATION>(in1=$sym_axis; in2=$z_axis; angle=$angle) 
 CNSsolve>    call inner(in1=&in1; in2=&in2; out=$tmp) 
 PROC-DECLARATION>(in1 ; in2 ; out ;) 
 PROC-INVOCATION>(in1=&in1; in2=&in2; out=$tmp) 
 CNSsolve>    eval(&out = &in1.x * &in2.x + &in1.y * &in2.y + &in1.z * &in2.z)  
 CNSsolve>    call norm(vec=&in1; norm=$norm1;) 
 PROC-DECLARATION>(vec ; norm ;) 
 PROC-INVOCATION>(vec=&in1; norm=$norm1;) 
 CNSsolve>    eval(&norm = sqrt(&vec.x**2 + &vec.y**2 + &vec.z**2))  
 CNSsolve>    call norm(vec=&in2; norm=$norm2;) 
 PROC-DECLARATION>(vec ; norm ;) 
 PROC-INVOCATION>(vec=&in2; norm=$norm2;) 
 CNSsolve>    eval(&norm = sqrt(&vec.x**2 + &vec.y**2 + &vec.z**2))  
 CNSsolve>    eval(&angle = acos($tmp / ($norm1 * $norm2)))  
 CNSsolve> 
 CNSsolve>    ! rotate the current system around the axis orthogonal to the 
 CNSsolve>    ! current axis of symmetry and future axis of symmetry 
 CNSsolve>    ! first get an orthogonal vector to the axis of symmetry 
 CNSsolve>    call cross(in1=$z_axis; in2=$sym_axis; out=$rot_axis;) 
 PROC-DECLARATION>(in1 ; in2 ; out ;) 
 PROC-INVOCATION>(in1=$z_axis; in2=$sym_axis; out=$rot_axis;) 
 CNSsolve>    eval(&out.x = &in1.y * &in2.z - &in1.z * &in2.y) 
 CNSsolve>    eval(&out.y = &in1.z * &in2.x - &in1.x * &in2.z) 
 CNSsolve>    eval(&out.z = &in1.x * &in2.y - &in1.y * &in2.x)  
 CNSsolve> 
 CNSsolve>    ! do the rotation around the origin 
 CNSsolve>    eval($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < $Data.ncomponents) loop nloop1 
 CNSsolve>        eval($nchain1 = $nchain1 + 1) 
 CNSsolve>        coor rotate 
 CNSsolve>            selection=((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP) 
 CNSsolve>            axis ($rot_axis.x $rot_axis.y $rot_axis.z) $angle 
 CNSsolve>        end 
 CNSsolve>    end loop nloop1 
 CNSsolve> 
 CNSsolve>    ! perform an extra random rotation around the symmetry axis for better 
 CNSsolve>    ! unbiases sampling for volume data 
 CNSsolve>    eval($nchain1 = 0) 
 CNSsolve>    eval($angle = 360.0 * random()) 
 CNSsolve>    while ($nchain1 < $Data.ncomponents) loop nloop1 
 CNSsolve>        eval($nchain1 = $nchain1 + 1) 
 CNSsolve>        coor rotate 
 CNSsolve>            selection=((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP) 
 CNSsolve>            axis ($sym_axis.x $sym_axis.y $sym_axis.z) $angle 
 CNSsolve>        end 
 CNSsolve>    end loop nloop1 
 CNSsolve>else 
 CNSsolve>    ! random rotation of the whole system around origin to reduce bias 
 CNSsolve>    ! for volume data fitting 
 CNSsolve>    @RUN:protocols/get_random_rotation.cns(Rotation=$rr;) 
 ASSFIL: file get_random_rotation.cns opened.
 CNSsolve>! get_random_rotation.cns 
 CNSsolve>!    Define a random rotation 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{* 
 CNSsolve>   The random rotation is calculated by taking a random unit quaternion, 
 CNSsolve>   so that all rotations are uniformely distributed. For more details, see 
 CNSsolve>   "Quaternions in molecular modeling" Charles F.F. Karney 
 CNSsolve>   Journal of Molecular Graphics and Modelling 25 (2007) 595-604 
 CNSsolve> 
 CNSsolve>   Original author: Christophe Schmidt 
 CNSsolve>   Modularized it: Gydo van Zundert 
 CNSsolve> 
 CNSsolve>   Parameters 
 CNSsolve>   ---------- 
 CNSsolve>       Rotation : A struct which will hold the random rotation 
 CNSsolve> 
 CNSsolve>       Type : Optional string, either 'Quaternion' or 'Matrix' 
 CNSsolve>           Determines whether the random rotation is expressed as a quaternion or a matrix 
 CNSsolve> 
 CNSsolve>   Note 
 CNSsolve>   ---- 
 CNSsolve>       There is no need in general to specify the Type as a matrix when performing the rotation. 
 CNSsolve> 
 CNSsolve>   Example: 
 CNSsolve>   >>>> ! $rand_rot does NOT have to exist currently 
 CNSsolve>   >>>> @RUN:protocols/get_random_rotation.cns(Rotation=$rand_rot;) 
 CNSsolve>   >>>> coor rotate 
 CNSsolve>   >>>>    quaternion $rand_rot.q0 $rand_rot.q1 $rand_rot.q2 $rand_rot.q3 
 CNSsolve>   >>>>    selection=(all) 
 CNSsolve>   >>>> end 
 CNSsolve> 
 CNSsolve>   Example using a rotation matrix: 
 CNSsolve>   >>>> @RUN:protocols/get_random_rotation.cns(Rotation=$rr; Type='Matrix';) 
 CNSsolve>   >>>> coor rotate 
 CNSsolve>   >>>>    matrix $rr.a11 $rr.a12 $rr.a13 
 CNSsolve>   >>>>           $rr.a21 $rr.a22 $rr.a23 
 CNSsolve>   >>>>           $rr.a31 $rr.a32 $rr.a33 
 CNSsolve>   >>>>    selection=(all) 
 CNSsolve>   >>>> end 
 CNSsolve>*} 
 CNSsolve> 
 CNSsolve>module {random_rotation} (Rotation; 
 MODULE-DECLARATION>                          Type='Quaternion'; 
 MODULE-DECLARATION>                          ) 
 CNSsolve> 
 CNSsolve>    !1. Generate random e1 e2 e3 and e4 in [-1, 1] so that e1^2 + e2^2 < 1 and e3^2+e4^2 < 1 
 CNSsolve>    evaluate ($RRM_e1 = random() * 2 - 1) 
 CNSsolve>    evaluate ($RRM_e2 = random() * 2 - 1) 
 CNSsolve>    evaluate ($RRM_s1 = ($RRM_e1)*($RRM_e1) + ($RRM_e2)*($RRM_e2)) 
 CNSsolve>    while ( $RRM_s1  >= 1) loop s1loop 
 CNSsolve>      evaluate ($RRM_e1 = random() * 2 - 1) 
 CNSsolve>      evaluate ($RRM_e2 = random() * 2 - 1) 
 CNSsolve>      evaluate ($RRM_s1 = ($RRM_e1)*($RRM_e1) + ($RRM_e2)*($RRM_e2)) 
 CNSsolve>    end loop s1loop 
 CNSsolve> 
 CNSsolve>    evaluate ($RRM_e3 = random() * 2 - 1) 
 CNSsolve>    evaluate ($RRM_e4 = random() * 2 - 1) 
 CNSsolve>    evaluate ($RRM_s2 = ($RRM_e3)*($RRM_e3) + ($RRM_e4)*($RRM_e4)) 
 CNSsolve>    while ( $RRM_s2  >= 1) loop s2loop 
 CNSsolve>      evaluate ($RRM_e3 = random() * 2 - 1) 
 CNSsolve>      evaluate ($RRM_e4 = random() * 2 - 1) 
 CNSsolve>      evaluate ($RRM_s2 = ($RRM_e3)*($RRM_e3) + ($RRM_e4)*($RRM_e4)) 
 CNSsolve>    end loop s2loop 
 CNSsolve> 
 CNSsolve>    !2. the quaternion q0 q1 q2 q3 
 CNSsolve>    evaluate($RRM_q0 = $RRM_e1) 
 CNSsolve>    evaluate($RRM_q1 = $RRM_e2) 
 CNSsolve>    evaluate($RRM_q2 = $RRM_e3 * sqrt((1 - $RRM_s1)/$RRM_s2) ) 
 CNSsolve>    evaluate($RRM_q3 = $RRM_e4 * sqrt((1 - $RRM_s1)/$RRM_s2) ) 
 CNSsolve> 
 CNSsolve>    ! package it in a struct 
 CNSsolve>    if (&Type='Quaternion') then 
 CNSsolve>        evaluate(&Rotation.q0 = $RRM_q0) 
 CNSsolve>        evaluate(&Rotation.q1 = $RRM_q1) 
 CNSsolve>        evaluate(&Rotation.q2 = $RRM_q2) 
 CNSsolve>        evaluate(&Rotation.q3 = $RRM_q3) 
 CNSsolve>    elseif (&Type='Matrix') then 
 CNSsolve>        evaluate (&Rotation.a11 = $RRM_q0 * $RRM_q0  +  $RRM_q1 * $RRM_q1  -  $RRM_q2 * $RRM_q2  -  $RRM_q3 * $RRM_q3) 
 CNSsolve>        evaluate (&Rotation.a12 = 2 * ($RRM_q1 * $RRM_q2 - $RRM_q0 * $RRM_q3) ) 
 CNSsolve>        evaluate (&Rotation.a13 = 2 * ($RRM_q1 * $RRM_q3 + $RRM_q0 * $RRM_q2) ) 
 CNSsolve>        evaluate (&Rotation.a21 = 2 * ($RRM_q1 * $RRM_q2 + $RRM_q0 * $RRM_q3) ) 
 CNSsolve>        evaluate (&Rotation.a22 = $RRM_q0 * $RRM_q0  -  $RRM_q1 * $RRM_q1  +  $RRM_q2 * $RRM_q2  -  $RRM_q3 * $RRM_q3) 
 CNSsolve>        evaluate (&Rotation.a23 = 2 * ($RRM_q2 * $RRM_q3 - $RRM_q0 * $RRM_q1) ) 
 CNSsolve>        evaluate (&Rotation.a31 = 2 * ($RRM_q1 * $RRM_q3 - $RRM_q0 * $RRM_q2) ) 
 CNSsolve>        evaluate (&Rotation.a32 = 2 * ($RRM_q2 * $RRM_q3 + $RRM_q0 * $RRM_q1) ) 
 CNSsolve>        evaluate (&Rotation.a33 = $RRM_q0 * $RRM_q0  -  $RRM_q1 * $RRM_q1  -  $RRM_q2 * $RRM_q2  +  $RRM_q3 * $RRM_q3) 
 CNSsolve>    end if 
 CNSsolve>    eval($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < $Data.ncomponents) loop nloop1 
 CNSsolve>        eval($nchain1 = $nchain1 + 1) 
 CNSsolve>        coor rotate 
 CNSsolve>            selection=((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP) 
 CNSsolve>            quaternion $rr.q0 $rr.q1 $rr.q2 $rr.q3 
 CNSsolve>        end 
 CNSsolve>    end loop nloop1 
 CNSsolve>end if ! $place_molecules_in_plane = true 
 CNSsolve> 
 CNSsolve>! translate subunits so that the map-center is the origin 
 CNSsolve>eval($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $Data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    coor translate 
 CNSsolve>        selection=((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP) 
 CNSsolve>        vector=($map_ave.x $map_ave.y $map_ave.z) 
 CNSsolve>    end 
 CNSsolve>end loop nloop1 
 CNSsolve>              end if 
 CNSsolve>          end if 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.sani eq true) then 
 CNSsolve>        coor @@RUN:toppar/tensor.pdb 
 CNSsolve>        do (x = x + $xcent + 100) (resn ANI) 
 CNSsolve>        do (y = y + $ycent + 100) (resn ANI) 
 CNSsolve>        do (z = z + $zcent + 100) (resn ANI) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.dani eq true) then 
 CNSsolve>        coor @@RUN:toppar/tensor_dani.pdb 
 CNSsolve>        do (x=x+$xcent+100) (resn DAN) 
 CNSsolve>        do (y=y+$ycent+100) (resn DAN) 
 CNSsolve>        do (z=z+$zcent+100) (resn DAN) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.xrdc eq true) then 
 CNSsolve>        coor @@RUN:toppar/tensor_para.pdb 
 CNSsolve>        do (x=x+$xcent+100) (resn XAN) 
 CNSsolve>        do (y=y+$ycent+100) (resn XAN) 
 CNSsolve>        do (z=z+$zcent+100) (resn XAN) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.xpcs eq true) then 
 CNSsolve>        coor @@RUN:toppar/tensor_para.pdb 
 CNSsolve>        do (x=x+$xcent+100) (resn XAN) 
 CNSsolve>        do (y=y+$ycent+100) (resn XAN) 
 CNSsolve>        do (z=z+$zcent+100) (resn XAN) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($unamb_scale = 1.0) 
 CNSsolve>      evaluate ($ambig_scale = 1.0) 
 CNSsolve>      evaluate ($hbond_scale = 1.0) 
 CNSsolve>      evaluate ($symm_scale = 1.0) 
 CNSsolve>      evaluate ($cont_scale = 0.0) 
 CNSsolve>      evaluate ($surf_scale = 0.0) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>        scale dist $unamb_scale 
 CNSsolve>        scale ambi $ambig_scale 
 CNSsolve>        scale hbon $hbond_scale 
 CNSsolve>        scale symm $symm_scale 
 CNSsolve>        scale contact $cont_scale 
 CNSsolve>        scale surface $surf_scale 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($nrdc=1) 
 CNSsolve>      while ($nrdc <= $data.numrdc) loop rdc 
 CNSsolve>        evaluate ($vea_bor_scale_$nrdc = min($Data.ini_bor_hot_$nrdc,$Data.fin_bor_cool3_$nrdc)) 
 CNSsolve>        evaluate ($vea_cen_scale_$nrdc = min($Data.ini_cen_hot_$nrdc,$Data.fin_cen_cool3_$nrdc)) 
 CNSsolve>        evaluate ($cln = "rd"+encode($nrdc) ) 
 CNSsolve>        evaluate ($san_scale_$nrdc = min($Data.rdc_hot_$nrdc,$Data.rdc_cool3_$nrdc)) 
 CNSsolve>        if ($Data.flags.vean eq true) then 
 CNSsolve>          vean class $cln force 0.0 0.0 end 
 CNSsolve>        end if 
 CNSsolve>        if ($Data.flags.sani eq true) then 
 CNSsolve>          sani class $cln force 0.0 end 
 CNSsolve>        end if 
 CNSsolve>        if ($Data.flags.xrdc eq true) then 
 CNSsolve>          xrdc class $cln force 0.0 end 
 CNSsolve>        end if 
 CNSsolve>        evaluate ($nrdc = $nrdc + 1) 
 CNSsolve>      end loop rdc 
 CNSsolve> 
 CNSsolve>      evaluate ($ndani=1) 
 CNSsolve>      while ($ndani <= $data.numdani) loop dani 
 CNSsolve>       evaluate ($dan_scale_$ndani = min($Data.dan_hot_$ndani,$Data.dan_cool3_$ndani)) 
 CNSsolve>       if ($Data.flags.dani eq true) then 
 CNSsolve>          evaluate ($cln = "da"+encode($ndani) ) 
 CNSsolve>          dani class $cln force 0.0 end 
 CNSsolve>        end if 
 CNSsolve>        evaluate ($ndani = $ndani + 1) 
 CNSsolve>      end loop dani 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.xpcs eq true) then 
 CNSsolve>        evaluate ($npcs=1) 
 CNSsolve>        while ($npcs <= $data.numpcs) loop pcs 
 CNSsolve>          evaluate ($pcs_scale_$npcs = min($Data.pcs_hot_$npcs,$Data.pcs_cool3_$npcs)) 
 CNSsolve>          evaluate ($cln = "pc"+encode($npcs) ) 
 CNSsolve>          xpcs class $cln force 0.0 end 
 CNSsolve>          evaluate ($npcs= $npcs + 1) 
 CNSsolve>        end loop pcs 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($kinter = $SaProtocol.inter_rigid) 
 CNSsolve>      @RUN:protocols/scale_inter_mini.cns 
 ASSFIL: file scale_inter_mini.cns opened.
 CNSsolve>! scale_inter_mini.cns 
 CNSsolve>!    Scaling of intermolecular interations 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DUM) (resn DUM) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn SHA) (resn SHA) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      ! a few rounds of rotational rigid body minimization for each independent chain 
 CNSsolve>      evaluate ($imini = 0) 
 CNSsolve>      while ($imini le 4) loop rigmin 
 CNSsolve> 
 CNSsolve>        if ($imini >= 1) then 
 CNSsolve>          evaluate ($paramin = false) 
 CNSsolve>          evaluate ($nrdc=1) 
 CNSsolve>          while ($nrdc <= $data.numrdc) loop rdc 
 CNSsolve>            evaluate ($vea_bor_scale_$nrdc = min($Data.ini_bor_hot_$nrdc,$Data.fin_bor_cool3_$nrdc)) 
 CNSsolve>            evaluate ($vea_cen_scale_$nrdc = min($Data.ini_cen_hot_$nrdc,$Data.fin_cen_cool3_$nrdc)) 
 CNSsolve>            evaluate ($san_scale_$nrdc = min($Data.rdc_hot_$nrdc,$Data.rdc_cool3_$nrdc)) 
 CNSsolve>            evaluate ($cln = "rd"+encode($nrdc) ) 
 CNSsolve>            if ($Data.flags.vean eq true) then 
 CNSsolve>              vean class $cln force $vea_bor_scale_$nrdc $vea_cen_scale_$nrdc end 
 CNSsolve>              evaluate ($vea_bor_scale_$nrdc = min(($vea_bor_scale_$nrdc * 2),$Data.fin_bor_cool3_$nrdc)) 
 CNSsolve>              evaluate ($vea_cen_scale_$nrdc = min(($vea_cen_scale_$nrdc * 2),$Data.fin_cen_cool3_$nrdc)) 
 CNSsolve>            end if 
 CNSsolve>            if ($Data.flags.sani eq true) then 
 CNSsolve>              sani class $cln force $san_scale_$nrdc end 
 CNSsolve>              evaluate ($san_scale_$nrdc = min($san_scale_$nrdc * 2,$Data.rdc_cool3_$nrdc)) 
 CNSsolve>            end if 
 CNSsolve>            if ($Data.flags.xrdc eq true) then 
 CNSsolve>              xrdc class $cln force $san_scale_$nrdc end 
 CNSsolve>              evaluate ($san_scale_$nrdc = min($san_scale_$nrdc * 2,$Data.rdc_cool3_$nrdc)) 
 CNSsolve>              evaluate ($paramin = true) 
 CNSsolve>            end if 
 CNSsolve>            evaluate ($nrdc = $nrdc + 1) 
 CNSsolve>          end loop rdc 
 CNSsolve> 
 CNSsolve>          if ($Data.flags.sani eq true) then 
 CNSsolve>            if ($rantens eq true) then 
 CNSsolve>              @RUN:protocols/mini_tensor.cns 
 ASSFIL: file mini_tensor.cns opened.
 CNSsolve>! mini_tensor.cns 
 CNSsolve>!    Optimize the RDC tensor orientation 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{* Optimize tensor orientation *} 
 CNSsolve> 
 CNSsolve>{* first randomize the tensor orientation because of some CNS problems *} 
 CNSsolve>{* possible resulting in infinite gradient and a failure of the EM     *} 
 CNSsolve> 
 CNSsolve>eval ($erdc = 999999999.0) 
 CNSsolve>eval ($ncount = 0) 
 CNSsolve>while ($ncount < 4) loop trial 
 CNSsolve>  eval ($ncount = $ncount + 1) 
 CNSsolve>  do (xcomp = x) (resn ANI) 
 CNSsolve>  do (ycomp = y) (resn ANI) 
 CNSsolve>  do (zcomp = z) (resn ANI) 
 CNSsolve> 
 CNSsolve>  !random rotation of tensor 
 CNSsolve> 
 CNSsolve>  show aver (x) (resn ANI) 
 CNSsolve>  evaluate ($xc = $result) 
 CNSsolve>  show aver (y) (resn ANI) 
 CNSsolve>  evaluate ($yc = $result) 
 CNSsolve>  show aver (z) (resn ANI) 
 CNSsolve>  evaluate ($zc = $result) 
 CNSsolve> 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  {* rotate around z axis *} 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = -sin($xr)) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = sin($xr)) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = 1 ) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  {* rotate around x axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = 1 ) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = -sin($xr)) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = sin($xr)) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve>  {* rotate around y axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = -sin($xr)) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = 1 ) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = sin($xr)) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  if ($ncount = 1) then 
 CNSsolve>    eval ($erdc=$sani) 
 CNSsolve>  end if 
 CNSsolve>  if ($sani < $erdc) then 
 CNSsolve>    eval ($erdc=$sani) 
 CNSsolve>    do (xcomp = x) (resn ANI) 
 CNSsolve>    do (ycomp = y) (resn ANI) 
 CNSsolve>    do (zcomp = z) (resn ANI) 
 CNSsolve>  else 
 CNSsolve>    do (x = xcomp) (resn ANI) 
 CNSsolve>    do (y = ycomp) (resn ANI) 
 CNSsolve>    do (z = zcomp) (resn ANI) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end loop trial 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve>fix sele=(name OO) end 
 CNSsolve>minimize rigid 
 CNSsolve>  group (not resn ANI) 
 CNSsolve>  translation=false 
 CNSsolve>  for $id in id (resn ANI and name OO) loop miniani 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop miniani 
 CNSsolve>  translation=false 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve>minimize rigid 
 CNSsolve>  eval($nchain1= 1) 
 CNSsolve>  while ($nchain1 <= $data.ncomponents) loop cloop1 
 CNSsolve>    group (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    translation=false 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>  end loop cloop1 
 CNSsolve>  for $id in id (resn ANI and name OO) loop miniani 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop miniani 
 CNSsolve>  translation=false 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          if ($Data.flags.xpcs eq true) then 
 CNSsolve>            evaluate ($npcs=1) 
 CNSsolve>            while ($npcs <= $data.numpcs) loop pcs 
 CNSsolve>              evaluate ($cln = "pc"+encode($npcs) ) 
 CNSsolve>              xpcs class $cln force $pcs_scale_$npcs end 
 CNSsolve>              evaluate ($pcs_scale_$npcs = min($pcs_scale_$npcs * 2,$Data.pcs_cool3_$npcs)) 
 CNSsolve>              evaluate ($npcs= $npcs + 1) 
 CNSsolve>            end loop pcs 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          if ($paramin eq TRUE) then 
 CNSsolve>            if ($rantens_para eq true) then 
 CNSsolve>              @RUN:protocols/mini_tensor_para.cns 
 ASSFIL: file mini_tensor_para.cns opened.
 CNSsolve>! mini_tensor_para.cns 
 CNSsolve>!    Optimize the tensor orientation for PCS restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>!set message on echo on end 
 CNSsolve> 
 CNSsolve>display STARTing mini_tensor_para.cns 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="trial.pdb" end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{* minimize tensor position *} 
 CNSsolve>display STARTing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>!flag excl * include noe end 
 CNSsolve>flag excl xpcs include noe end 
 CNSsolve>fix sele=(not resn XAN) end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve>  interaction (not all) (not all) 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>minimize rigid 
 CNSsolve>  group (resname XAN) 
 CNSsolve>  translation=true 
 CNSsolve>  nstep 1000 
 CNSsolve>  tole 0.1 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="position.pdb" end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>display STARTing minimization of orientation 
 CNSsolve> 
 CNSsolve>{* minimize tensor orientation *} 
 CNSsolve> 
 CNSsolve>evaluate ($protocol = 0) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($protocol = 0) then {* powell minimization protocol together *} 
 CNSsolve> 
 CNSsolve>  display protocol 0 
 CNSsolve>!  flag excl * include noe xpcs bond end 
 CNSsolve>  flag  include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>    interaction (not all) (not all) 
 CNSsolve>    interaction ( resn XAN ) ( resn XAN ) weight * 0 bond 1.0 end 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  fix sele=(not (resn XAN)) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve>elseif ($protocol = 1) then {* powell minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 1 
 CNSsolve>  flag excl * include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    igroup 
 CNSsolve>      interaction (not all) (not all) 
 CNSsolve>      interaction ( (byres(id $id)) ) ( (byres(id $id)) ) weight * 0 bond 1.0 end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    fix sele=(not ( (byres(id $id)) )) end 
 CNSsolve> 
 CNSsolve>    minimize powell 
 CNSsolve>      nstep=500 
 CNSsolve>      drop=10 
 CNSsolve>      nprint=10 
 CNSsolve>      tolgradient=0.01 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 4) then {* powell minimization protocol simultaneously *} 
 CNSsolve> 
 CNSsolve>  display protocol 4 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve> 
 CNSsolve>  fix sele=(not ( resname XAN )) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 2) then  {* rigid body minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 2 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    minimize rigid 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>      nstep 500 
 CNSsolve>      nprint 10 
 CNSsolve>      drop=10 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 3) then {* original rigid body minimization protocol *} 
 CNSsolve>  display protocol 3 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  fix sele=(not resname XAN) end 
 CNSsolve>  minimize rigid 
 CNSsolve>    group (not resname XAN) 
 CNSsolve>    translation=true 
 CNSsolve>    for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>    end loop miniani 
 CNSsolve>    translation=true 
 CNSsolve>    nstep 5000 
 CNSsolve> 
 CNSsolve>    nprint 10 
 CNSsolve>  end 
 CNSsolve>  display XPCS_ENERGY $xpcs 
 CNSsolve>  fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of orientation 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>          if ($Data.flags.dani eq true) then 
 CNSsolve>            evaluate ($ndani=1) 
 CNSsolve>            while ($ndani <= $data.numdani) loop dani 
 CNSsolve>              evaluate ($cln = "da"+encode($ndani) ) 
 CNSsolve>              dani class $cln force $dan_scale_$ndani end 
 CNSsolve>              evaluate ($dan_scale_$ndani = min($dan_scale_$ndani * 2,$Data.dan_cool3_$ndani)) 
 CNSsolve>              evaluate ($ndani = $ndani + 1) 
 CNSsolve>            end loop dani 
 CNSsolve>            if ($rantens_dani eq true) then 
 CNSsolve>              @RUN:protocols/mini_tensor_dani.cns 
 ASSFIL: file mini_tensor_dani.cns opened.
 CNSsolve>! mini_tensor_dani.cns 
 CNSsolve>!    Optimize the tensor orientation for diffusion anisotropy restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{* Optimize tensor orientation *} 
 CNSsolve>{* ADJ van Dijk*} 
 CNSsolve>{* copied from mini_tensor.cns *} 
 CNSsolve> 
 CNSsolve>{* first randomize the tensor orientation because of some CNS problems *} 
 CNSsolve>{* possible resulting in infinite gradient and a failure of the EM     *} 
 CNSsolve> 
 CNSsolve>eval ($edani = 999999999.0) 
 CNSsolve>eval ($ncount = 0) 
 CNSsolve>while ($ncount < 4) loop trial 
 CNSsolve>  eval ($ncount = $ncount + 1) 
 CNSsolve>  do (xcomp = x) (resn DAN) 
 CNSsolve>  do (ycomp = y) (resn DAN) 
 CNSsolve>  do (zcomp = z) (resn DAN) 
 CNSsolve> 
 CNSsolve>  !random rotation of tensor 
 CNSsolve> 
 CNSsolve>  show aver (x) (resn DAN) 
 CNSsolve>  evaluate ($xc = $result) 
 CNSsolve>  show aver (y) (resn DAN) 
 CNSsolve>  evaluate ($yc = $result) 
 CNSsolve>  show aver (z) (resn DAN) 
 CNSsolve>  evaluate ($zc = $result) 
 CNSsolve> 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  {* rotate around z axis *} 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = -sin($xr)) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = sin($xr)) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = 1 ) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  {* rotate around x axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = 1 ) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = -sin($xr)) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = sin($xr)) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve>  {* rotate around y axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = -sin($xr)) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = 1 ) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = sin($xr)) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  if ($ncount = 1) then 
 CNSsolve>    eval ($edani=$dani) 
 CNSsolve>  end if 
 CNSsolve>  if ($dani < $edani) then 
 CNSsolve>    eval ($edani=$dani) 
 CNSsolve>    do (xcomp = x) (resn DAN) 
 CNSsolve>    do (ycomp = y) (resn DAN) 
 CNSsolve>    do (zcomp = z) (resn DAN) 
 CNSsolve>  else 
 CNSsolve>    do (x = xcomp) (resn DAN) 
 CNSsolve>    do (y = ycomp) (resn DAN) 
 CNSsolve>    do (z = zcomp) (resn DAN) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end loop trial 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve>fix sele=(name OO) end 
 CNSsolve>minimize rigid 
 CNSsolve>  group (not resn DAN) 
 CNSsolve>  translation=false 
 CNSsolve>  for $id in id (resn DAN and name OO) loop minidan 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop minidan 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve>minimize rigid 
 CNSsolve>  eval($nchain1= 1) 
 CNSsolve>  while ($nchain1 <= $data.ncomponents) loop cloop1 
 CNSsolve>    group (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop cloop1 
 CNSsolve>  for $id in id (resn DAN and name OO) loop minidan 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop minidan 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve> 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        evaluate ($imini = $imini + 1) 
 CNSsolve>        eval ($ministeps = 500 * nint ($data.ncomponents/6 + 1)) 
 CNSsolve>        if ($SaProtocol.randorien eq true) then 
 CNSsolve>          flag excl vdw elec coll zhar end 
 CNSsolve>        end if 
 CNSsolve>        eval ($nchain1 = 0) 
 CNSsolve>        while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>          eval($nchain1 = $nchain1 + 1) 
 CNSsolve>          if ($Toppar.fix_origin_$nchain1 eq false) then 
 CNSsolve>            fix sele=(not all) end 
 CNSsolve>            fix sele=( not (segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name OO) end 
 CNSsolve>            minimize rigid 
 CNSsolve>              group ((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP) 
 CNSsolve>              translation=false 
 CNSsolve>              nstep $ministeps 
 CNSsolve>              drop 10.0 
 CNSsolve>              tole 0.1 
 CNSsolve>              nprint 10 
 CNSsolve>            end 
 CNSsolve>          end if 
 CNSsolve>        end loop nloop1 
 CNSsolve>        fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>        flag include vdw end 
 CNSsolve>        if ($Data.flags.elec0 eq true) then 
 CNSsolve>          flag include elec end 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        evaluate ($unamb_scale = min(($unamb_scale * 2),$Data.unamb_cool3)) 
 CNSsolve>        evaluate ($ambig_scale = min(($ambig_scale * 2),$Data.amb_cool3)) 
 CNSsolve>        evaluate ($hbond_scale = min(($hbond_scale * 2),$Data.hbond_cool3)) 
 CNSsolve>        evaluate ($symm_scale = min(($symm_scale * 2),$Data.ksym)) 
 CNSsolve> 
 CNSsolve>        noe 
 CNSsolve>          scale dist $unamb_scale 
 CNSsolve>          scale ambi $ambig_scale 
 CNSsolve>          scale hbon $hbond_scale 
 CNSsolve>          scale symm $symm_scale 
 CNSsolve>          if ($data.flags.centroids = true) then 
 CNSsolve>              scale centroid $data.centroids.kscale end 
 CNSsolve>          end if 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>      end loop rigmin 
 CNSsolve> 
 CNSsolve>      evaluate ($unamb_scale_store = $unamb_scale) 
 CNSsolve>      evaluate ($ambig_scale_store = $ambig_scale) 
 CNSsolve>      evaluate ($hbond_scale_store = $hbond_scale) 
 CNSsolve>      evaluate ($symm_scale_store = $symm_scale) 
 CNSsolve> 
 CNSsolve>      flag include vdw end 
 CNSsolve>      if ($Data.flags.elec0 eq true) then 
 CNSsolve>        flag include elec end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      if ($SaProtocol.rigidtrans eq true) then 
 CNSsolve> 
 CNSsolve>        if ($data.waterdock eq true) then 
 CNSsolve>         if ($data.solvate_method ne "db") then 
 CNSsolve>          inline @RUN:protocols/waterdock_remove-water.cns 
 ASSFIL: file waterdock_remove-water.cns opened.
 CNSsolve>! waterdock_remove-water.cns 
 CNSsolve>!    MC-based removal of waters in solvated docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> !store5 contains the waters that are to be "removed" 
 CNSsolve> ident (store5) (not all) 
 CNSsolve> 
 CNSsolve> ident (store5) ((resn WAT or resn HOH)) 
 CNSsolve> 
 CNSsolve> !count number of waters 
 CNSsolve> show sum(1) ((resn WAT or resn HOH) and name OH2) 
 CNSsolve> eval ($watercount=$result) 
 CNSsolve> 
 CNSsolve> !determine how many of those to keep 
 CNSsolve> eval ($randfrac = random(1.0)) 
 CNSsolve> eval ($randfrac = $randfrac * $data.water_randfrac) 
 CNSsolve> eval ($fractionkeep =$data.water_tokeep + $randfrac) 
 CNSsolve> eval ($tokeep = $fractionkeep * $watercount) 
 CNSsolve> 
 CNSsolve> display info: watercount $watercount 
 CNSsolve> display info: tokeep $tokeep 
 CNSsolve> !for each nrig value, different waters are "removed" 
 CNSsolve> for $atom_id in id ((resn WAT or resn HOH) and name OH2) loop loop2 
 CNSsolve>  eval ($r = random(1.0) * $watercount) 
 CNSsolve>  display info: r-value $r 
 CNSsolve>  if ($r > $tokeep) then 
 CNSsolve>     ident (store5) (store5 or id $atom_id) 
 CNSsolve>  end if 
 CNSsolve> end loop loop2 
 CNSsolve> 
 CNSsolve> ident (store5) (byres store5) 
 CNSsolve> 
 CNSsolve> !"removing" of water: interaction weight 0 
 CNSsolve> igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve> igroup 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction ((resn WAT or resn HOH or resn TIP*) and not store5) (segid $Toppar.prot_segid_$nchain1) weight * 1.0 end 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*) and not store5) 
 CNSsolve>	           ((resn WAT or resn HOH or resn TIP*) and not store5) weight * 1.0 end 
 CNSsolve>  interaction (store5) (all) weight * 0.0 end 
 CNSsolve>  interaction (resn DUM) (not resn DUM) weight * 0.0 end 
 CNSsolve>  interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 CNSsolve> end 
 CNSsolve> 
 CNSsolve> if ($data.solvate_method eq "restraints") then 
 CNSsolve>  noe reset end 
 CNSsolve>  !read again the NOE data 
 CNSsolve>  @RUN:protocols/read_noes.cns(Iteration=$Iteration; Data=$Data; count=$count) 
 ASSFIL: file read_noes.cns opened.
 CNSsolve>! read_noes.cns 
 CNSsolve>!    Read distance restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(Iteration; Data; count;) 
 CNSsolve> 
 CNSsolve>!NOEs, hbonds 
 CNSsolve>noe 
 CNSsolve>  reset 
 CNSsolve>  nrestraints = 12000000     ! allocate space for NOEs 
 CNSsolve>  ceiling 1000 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>display reading NEWIT:unambig.tbl in iteration &iteration with option &data.unamb_firstit 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if (&data.amb_firstit le &iteration)   then 
 CNSsolve>     evaluate ($filenam0 = "NEWIT:ambig.tbl_" + encode($count)) 
 CNSsolve>     fileexist $filenam0 end 
 CNSsolve>     if ($result eq false) then 
 CNSsolve>       evaluate ($filenam0 = "NEWIT:ambig.tbl") 
 CNSsolve>     end if 
 CNSsolve>     noe class ambi @@$filenam0 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.unamb_firstit le &iteration) then 
 CNSsolve>     noe class dist @@NEWIT:unambig.tbl end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.hbond_firstit le &iteration) then 
 CNSsolve>   if (&data.hbonds_on eq true) then 
 CNSsolve>      noe @@RUN:data/hbonds/hbonds.tbl end 
 CNSsolve>   end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>  averaging  * sum 
 CNSsolve>  potential  * soft 
 CNSsolve>  scale      * 1.0 
 CNSsolve>  sqconstant * 1.0 
 CNSsolve>  sqexponent * 2 
 CNSsolve>  soexponent * 1 
 CNSsolve>  rswitch    * 1.0 
 CNSsolve>  sqoffset   * 0.0 
 CNSsolve>  asymptote  * 2.0 
 CNSsolve>  msoexponent * 1 
 CNSsolve>  masymptote  * -0.1 
 CNSsolve>  mrswitch    * 1.0 
 CNSsolve>  avexpo hbond 20 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>if (&data.waterdock eq true) then 
 CNSsolve> if (&iteration eq 0) then 
 CNSsolve>  if (&data.solvate_method eq "restraints") then 
 CNSsolve>   evaluate ($nchain=0) 
 CNSsolve>   while ($nchain < &data.ncomponents) loop nloop1 
 CNSsolve>    evaluate ($nchain = $nchain + 1) 
 CNSsolve>    evaluate ($watersegname_$nchain="WA" + encode($nchain)) 
 CNSsolve>    noe class amwa end 
 CNSsolve>    for $atom_id in id ((resn WAT or resn HOH or resn TIP*) and name OH2 and segid $watersegname_$nchain and not store5) loop waterrestraint 
 CNSsolve>   noe 
 CNSsolve>    assi (segid $toppar.prot_segid_$nchain and (resn arg or resn glu or resn lys or resn asp or resn tyr) and ((id $atom_id) around &data.water_restraint_cutoff)) 
 CNSsolve>        (id $atom_id) &data.water_restraint_cutoff &data.water_restraint_cutoff 0.0 
 CNSsolve>   end 
 CNSsolve>  end loop waterrestraint 
 CNSsolve>   end loop nloop1 
 CNSsolve>  end if 
 CNSsolve> end if 
 CNSsolve>end if 
 CNSsolve> end if 
 CNSsolve>         else 
 CNSsolve>          inline @RUN:protocols/db0.cns 
 ASSFIL: file db0.cns opened.
 CNSsolve>! db0.cns 
 CNSsolve>!    Use in the removal of interfacial waters in solvated docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> !store5=1 contains the waters that are to be "removed" 
 CNSsolve> !none at this stage 
 CNSsolve> 
 CNSsolve> do (store5 = 0) (all) 
 CNSsolve> 
 CNSsolve> !"removing" of water: interaction weight 0 
 CNSsolve> igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve> igroup 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) (segid $Toppar.prot_segid_$nchain1) weight * 1.0 end 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) 
 CNSsolve>	           ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) weight * 1.0 end 
 CNSsolve>  interaction (attr store5 = 1) (all) weight * 0.0 end 
 CNSsolve>  interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 CNSsolve> end 
 CNSsolve>         end if 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        evaluate ($cont_scale = $Data.kcont) 
 CNSsolve>        evaluate ($surf_scale = $Data.ksurf) 
 CNSsolve>        noe 
 CNSsolve>          scale contact $cont_scale 
 CNSsolve>          scale surface $surf_scale 
 CNSsolve>        end 
 CNSsolve>        fix sele=(name OO and not resn XAN) end 
 CNSsolve>        minimize rigid 
 CNSsolve>          eval ($nchain1 = 0) 
 CNSsolve>          while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>            eval($nchain1 = $nchain1 + 1) 
 CNSsolve>            if ($Toppar.fix_origin_$nchain1 eq false) then 
 CNSsolve>              group ((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP) 
 CNSsolve>            end if 
 CNSsolve>            translation=false 
 CNSsolve>          end loop nloop1 
 CNSsolve>          nstep 1000 
 CNSsolve>          nprint 10 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        if ($data.solvate_method eq "db") then 
 CNSsolve>          inline @RUN:protocols/db00.cns 
 ASSFIL: file db00.cns opened.
 CNSsolve>! db00.cns 
 CNSsolve>!    Used in the removal of interfacial waters in solvated docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> !store5 is what is to be removed 
 CNSsolve> !store4 is used to determine what is at an interface 
 CNSsolve> eval ($surfcutoff = $data.water_surfcutoff) 
 CNSsolve> do (store4 = 0) (all) 
 CNSsolve> do (store4 = 1) ((resn WAT or resn HOH) and name oh2) 
 CNSsolve> show sum (store4) (all) 
 CNSsolve> display SOLVATED-DOCKING: INITIAL NUMBER OF WATERS IS $result 
 CNSsolve> do (store4 = 0) (all) 
 CNSsolve> 
 CNSsolve> eval($nchain1 = 0) 
 CNSsolve> while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>   eval($nchain1 = $nchain1 + 1) 
 CNSsolve>   do (store4 = store4 + 1) (name oh2 and ((segid $Toppar.prot_segid_$nchain1) around $surfcutoff)) 
 CNSsolve> end loop nloop1 
 CNSsolve> 
 CNSsolve> !an interfacial water should have at least store4=2 
 CNSsolve> do (store4 = 0) (attribute store4 < 2) 
 CNSsolve> do (store4 = 1) (attribute store4 > 0) 
 CNSsolve> show sum (store4) (all) 
 CNSsolve> display SOLVATED-DOCKING: REMAINING NUMBER OF INTERFACIAL WATERS IS $result 
 CNSsolve> 
 CNSsolve> do (store5 = 1) ((attr store5 = 1) or (name oh2 and (attr store4 ne 1))) 
 CNSsolve> do (store5 = 1) (byres (attr store5 = 1)) 
 CNSsolve> 
 CNSsolve>!"removing" of water: interaction weight 0 
 CNSsolve> igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve> igroup 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) (segid $Toppar.prot_segid_$nchain1) weight * 1.0 end 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) 
 CNSsolve>	           ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) weight * 1.0 end 
 CNSsolve>  interaction (attr store5 = 1) (all) weight * 0.0 end 
 CNSsolve>  interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 CNSsolve> end 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        energy end 
 CNSsolve> 
 CNSsolve>        if ($Data.flags.rg eq true) then 
 CNSsolve>          flag include coll end 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        if ($Data.flags.zres eq true) then 
 CNSsolve>          flag incl zhar end 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        fix sele=(name OO and not resn XAN) end 
 CNSsolve>        eval ($ministeps = $SaProtocol.emstepstrans) 
 CNSsolve>        minimize rigid 
 CNSsolve>          eval ($nchain1 = 0) 
 CNSsolve>          while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>            eval($nchain1 = $nchain1 + 1) 
 CNSsolve>            if ($Toppar.fix_origin_$nchain1 eq false) then 
 CNSsolve>              group ((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP) 
 CNSsolve>            end if 
 CNSsolve>            translation=true 
 CNSsolve>          end loop nloop1 
 CNSsolve>          nstep $ministeps 
 CNSsolve>          nprint 10 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        energy end 
 CNSsolve> 
 CNSsolve>        if ($data.waterdock eq true) then 
 CNSsolve>          if ($data.solvate_method eq "db") then 
 CNSsolve>            display MINIMIZATION ENERGY BEFORE: $grad $ener $vdw $elec 
 CNSsolve>            minimize rigid 
 CNSsolve>              eval ($nchain1 = 0) 
 CNSsolve>              while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>                eval($nchain1 = $nchain1 + 1) 
 CNSsolve>                if ($Toppar.fix_origin_$nchain1 eq false) then 
 CNSsolve>                  group (segid $Toppar.prot_segid_$nchain1 and not (resn WAT or resn HOH or resn TIP* or name MAP)) 
 CNSsolve>                end if 
 CNSsolve>                translation=true 
 CNSsolve>              end loop nloop1 
 CNSsolve>              for $id in id ((resn WAT or resn HOH or resn TIP*) and name OH2 and (attr store5 ne 1)) loop miniwater 
 CNSsolve>                group (byres(id $id)) 
 CNSsolve>              end loop miniwater 
 CNSsolve>              translation=$data.transwater 
 CNSsolve>              nstep $ministeps 
 CNSsolve>              nprint 100 
 CNSsolve>            end 
 CNSsolve>            display MINIMIZATION ENERGY AFTER: $grad $ener $vdw $elec 
 CNSsolve>            inline @RUN:protocols/db1.cns 
 ASSFIL: file db1.cns opened.
 CNSsolve>! db1.cns 
 CNSsolve>!    Used in the removal of interfacial waters in solvated docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>eval ($rmultfact=1.0) 
 CNSsolve>eval($testcutoff=3.5) 
 CNSsolve>eval($enercutoff=0.0) 
 CNSsolve> 
 CNSsolve>show sum(1) ((resn WAT or resn HOH) and name OH2 and (attr store5 ne 1) and (not (name P or name O*P* or name "O3'" or name "O5'") around $testcutoff)) 
 CNSsolve>eval ($watercount=$result) 
 CNSsolve>show sum(1) ((resn WAT or resn HOH) and name OH2 and (attr store5 ne 1) and ((name P or name O*P* or name "O3'" or name "O5'") around $testcutoff)) 
 CNSsolve>eval ($dnapwatercount=$result) 
 CNSsolve> 
 CNSsolve>display SOLVATED-DOCKING: info: watercount $watercount 
 CNSsolve> 
 CNSsolve>evaluate ($icount = 1) 
 CNSsolve>do (store4 = 0) (all) 
 CNSsolve> 
 CNSsolve>for $atom_id in id ((resn WAT or resn HOH) and name OH2 and (attr store5 ne 1)) loop count 
 CNSsolve>  do (store4 = $icount) (id $atom_id) 
 CNSsolve>  evaluate ($icount = $icount + 1) 
 CNSsolve>end loop count 
 CNSsolve>display SOLVATED-DOCKING: info: watercount $icount 
 CNSsolve> 
 CNSsolve>show min(store4) ((resn WAT or resn HOH) and name OH2 and (attr store5 ne 1)) 
 CNSsolve>evaluate ($rmin = $result) 
 CNSsolve>show max(store4) ((resn WAT or resn HOH) and name OH2 and (attr store5 ne 1)) 
 CNSsolve>evaluate ($rmax = $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nres = $rmax - $rmin + 1) 
 CNSsolve>display SOLVATED-DOCKING: $nres WATERS SELECTED FOR DATABASE-STATISTICS BASED RANDOM REMOVAL 
 CNSsolve>if ($nres < 1) then 
 CNSsolve>  display SOLVATED-DOCKING: NO WATER IN DEFINED WATERS 
 CNSsolve>  display SOLVATED-DOCKING: DB WATER REMOVAL FAILED 
 CNSsolve>  display SOLVATED-DOCKING: STOPPING... 
 CNSsolve>  stop 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! initialize water-mediated contact probabilities to average 
 CNSsolve>! value of the protein-protein matrix (0.22 for statistical and 0.33 for Kyte-Doolittle) 
 CNSsolve>! and 0.54 for protein-DNA 
 CNSsolve>! 
 CNSsolve>if ($data.db_method eq 'statistical') then 
 CNSsolve>  evaluate ($dbave = 0.22) 
 CNSsolve>else 
 CNSsolve>  eval ($dbave = 0.33) 
 CNSsolve>end if 
 CNSsolve>eval ($dbdave = 0.54) 
 CNSsolve>eval($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  eval($nchain2 = 0) 
 CNSsolve>  while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>    evaluate ($nchain2 = $nchain2 + 1) 
 CNSsolve>    if ($nchain1 ne $nchain2) then 
 CNSsolve>      for $at1_id in id ( tag and segid $Toppar.prot_segid_$nchain1 ) loop atm1 
 CNSsolve>        show (resn) (id $at1_id) 
 CNSsolve>        evaluate ($rsn1 = $result) 
 CNSsolve>        for $at2_id in id ( tag and segid $Toppar.prot_segid_$nchain2 ) loop atm2 
 CNSsolve>           show (resn) (id $at2_id) 
 CNSsolve>           evaluate ($rsn2 = $result) 
 CNSsolve>           evaluate ($db.$rsn1_$rsn2 = $dbave) 
 CNSsolve>           evaluate ($db.DP_$rsn1_$rsn2 = $dbdave) 
 CNSsolve>        end loop atm2 
 CNSsolve>      end loop atm1 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop2 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>if ($data.db_method eq 'statistical') then 
 CNSsolve>  inline @RUN:protocols/db_statistical.dat 
 ASSFIL: file db_statistical.dat opened.
 CNSsolve>! db_statistical.dat 
 CNSsolve>!    PDB-derived probabilities of finding a water molecule 
 CNSsolve>!    between two specific amino acids 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>eval($db.ALA_ALA = 0.190 ) 
 CNSsolve>eval($db.ALA_ARG = 0.220 ) 
 CNSsolve>eval($db.ALA_ASN = 0.290 ) 
 CNSsolve>eval($db.ALA_ASP = 0.330 ) 
 CNSsolve>eval($db.ALA_CYS = 0.150 ) 
 CNSsolve>eval($db.ALA_GLN = 0.170 ) 
 CNSsolve>eval($db.ALA_GLU = 0.260 ) 
 CNSsolve>eval($db.ALA_GLY = 0.290 ) 
 CNSsolve>eval($db.ALA_HIS = 0.240 ) 
 CNSsolve>eval($db.ALA_NEP = 0.240 ) 
 CNSsolve>eval($db.ALA_ILE = 0.170 ) 
 CNSsolve>eval($db.ALA_LEU = 0.110 ) 
 CNSsolve>eval($db.ALA_LYS = 0.210 ) 
 CNSsolve>eval($db.ALA_MET = 0.240 ) 
 CNSsolve>eval($db.ALA_PHE = 0.070 ) 
 CNSsolve>eval($db.ALA_PRO = 0.240 ) 
 CNSsolve>eval($db.ALA_SER = 0.170 ) 
 CNSsolve>eval($db.ALA_THR = 0.060 ) 
 CNSsolve>eval($db.ALA_TRP = 0.150 ) 
 CNSsolve>eval($db.ALA_TYR = 0.150 ) 
 CNSsolve>eval($db.ALA_VAL = 0.080 ) 
 CNSsolve>eval($db.ARG_ALA = 0.220 ) 
 CNSsolve>eval($db.ARG_ARG = 0.660 ) 
 CNSsolve>eval($db.ARG_ASN = 0.260 ) 
 CNSsolve>eval($db.ARG_ASP = 0.390 ) 
 CNSsolve>eval($db.ARG_CYS = 0.200 ) 
 CNSsolve>eval($db.ARG_GLN = 0.310 ) 
 CNSsolve>eval($db.ARG_GLU = 0.340 ) 
 CNSsolve>eval($db.ARG_GLY = 0.270 ) 
 CNSsolve>eval($db.ARG_HIS = 0.340 ) 
 CNSsolve>eval($db.ARG_NEP = 0.340 ) 
 CNSsolve>eval($db.ARG_ILE = 0.240 ) 
 CNSsolve>eval($db.ARG_LEU = 0.240 ) 
 CNSsolve>eval($db.ARG_LYS = 0.350 ) 
 CNSsolve>eval($db.ARG_MET = 0.300 ) 
 CNSsolve>eval($db.ARG_PHE = 0.090 ) 
 CNSsolve>eval($db.ARG_PRO = 0.340 ) 
 CNSsolve>eval($db.ARG_SER = 0.380 ) 
 CNSsolve>eval($db.ARG_THR = 0.120 ) 
 CNSsolve>eval($db.ARG_TRP = 0.180 ) 
 CNSsolve>eval($db.ARG_TYR = 0.280 ) 
 CNSsolve>eval($db.ARG_VAL = 0.280 ) 
 CNSsolve>eval($db.ASN_ALA = 0.290 ) 
 CNSsolve>eval($db.ASN_ARG = 0.260 ) 
 CNSsolve>eval($db.ASN_ASN = 0.460 ) 
 CNSsolve>eval($db.ASN_ASP = 0.350 ) 
 CNSsolve>eval($db.ASN_CYS = 0.220 ) 
 CNSsolve>eval($db.ASN_GLN = 0.260 ) 
 CNSsolve>eval($db.ASN_GLU = 0.230 ) 
 CNSsolve>eval($db.ASN_GLY = 0.280 ) 
 CNSsolve>eval($db.ASN_HIS = 0.230 ) 
 CNSsolve>eval($db.ASN_NEP = 0.230 ) 
 CNSsolve>eval($db.ASN_ILE = 0.070 ) 
 CNSsolve>eval($db.ASN_LEU = 0.100 ) 
 CNSsolve>eval($db.ASN_LYS = 0.270 ) 
 CNSsolve>eval($db.ASN_MET = 0.190 ) 
 CNSsolve>eval($db.ASN_PHE = 0.050 ) 
 CNSsolve>eval($db.ASN_PRO = 0.110 ) 
 CNSsolve>eval($db.ASN_SER = 0.270 ) 
 CNSsolve>eval($db.ASN_THR = 0.250 ) 
 CNSsolve>eval($db.ASN_TRP = 0.000 ) 
 CNSsolve>eval($db.ASN_TYR = 0.170 ) 
 CNSsolve>eval($db.ASN_VAL = 0.260 ) 
 CNSsolve>eval($db.ASP_ALA = 0.330 ) 
 CNSsolve>eval($db.ASP_ARG = 0.390 ) 
 CNSsolve>eval($db.ASP_ASN = 0.350 ) 
 CNSsolve>eval($db.ASP_ASP = 0.420 ) 
 CNSsolve>eval($db.ASP_CYS = 0.230 ) 
 CNSsolve>eval($db.ASP_GLN = 0.300 ) 
 CNSsolve>eval($db.ASP_GLU = 0.450 ) 
 CNSsolve>eval($db.ASP_GLY = 0.120 ) 
 CNSsolve>eval($db.ASP_HIS = 0.700 ) 
 CNSsolve>eval($db.ASP_NEP = 0.700 ) 
 CNSsolve>eval($db.ASP_ILE = 0.100 ) 
 CNSsolve>eval($db.ASP_LEU = 0.140 ) 
 CNSsolve>eval($db.ASP_LYS = 0.460 ) 
 CNSsolve>eval($db.ASP_MET = 0.190 ) 
 CNSsolve>eval($db.ASP_PHE = 0.310 ) 
 CNSsolve>eval($db.ASP_PRO = 0.130 ) 
 CNSsolve>eval($db.ASP_SER = 0.270 ) 
 CNSsolve>eval($db.ASP_THR = 0.250 ) 
 CNSsolve>eval($db.ASP_TRP = 0.140 ) 
 CNSsolve>eval($db.ASP_TYR = 0.280 ) 
 CNSsolve>eval($db.ASP_VAL = 0.310 ) 
 CNSsolve>eval($db.CYS_ALA = 0.150 ) 
 CNSsolve>eval($db.CYS_ARG = 0.200 ) 
 CNSsolve>eval($db.CYS_ASN = 0.220 ) 
 CNSsolve>eval($db.CYS_ASP = 0.230 ) 
 CNSsolve>eval($db.CYS_CYS = 0.120 ) 
 CNSsolve>eval($db.CYS_GLN = 0.000 ) 
 CNSsolve>eval($db.CYS_GLU = 0.180 ) 
 CNSsolve>eval($db.CYS_GLY = 0.400 ) 
 CNSsolve>eval($db.CYS_HIS = 0.000 ) 
 CNSsolve>eval($db.CYS_NEP = 0.000 ) 
 CNSsolve>eval($db.CYS_ILE = 0.090 ) 
 CNSsolve>eval($db.CYS_LEU = 0.050 ) 
 CNSsolve>eval($db.CYS_LYS = 0.330 ) 
 CNSsolve>eval($db.CYS_MET = 0.000 ) 
 CNSsolve>eval($db.CYS_PHE = 0.000 ) 
 CNSsolve>eval($db.CYS_PRO = 0.200 ) 
 CNSsolve>eval($db.CYS_SER = 0.580 ) 
 CNSsolve>eval($db.CYS_THR = 0.000 ) 
 CNSsolve>eval($db.CYS_TRP = 0.250 ) 
 CNSsolve>eval($db.CYS_TYR = 0.060 ) 
 CNSsolve>eval($db.CYS_VAL = 0.140 ) 
 CNSsolve>eval($db.GLN_ALA = 0.170 ) 
 CNSsolve>eval($db.GLN_ARG = 0.310 ) 
 CNSsolve>eval($db.GLN_ASN = 0.260 ) 
 CNSsolve>eval($db.GLN_ASP = 0.300 ) 
 CNSsolve>eval($db.GLN_CYS = 0.000 ) 
 CNSsolve>eval($db.GLN_GLN = 0.270 ) 
 CNSsolve>eval($db.GLN_GLU = 0.370 ) 
 CNSsolve>eval($db.GLN_GLY = 0.240 ) 
 CNSsolve>eval($db.GLN_HIS = 0.240 ) 
 CNSsolve>eval($db.GLN_NEP = 0.240 ) 
 CNSsolve>eval($db.GLN_ILE = 0.150 ) 
 CNSsolve>eval($db.GLN_LEU = 0.190 ) 
 CNSsolve>eval($db.GLN_LYS = 0.350 ) 
 CNSsolve>eval($db.GLN_MET = 0.230 ) 
 CNSsolve>eval($db.GLN_PHE = 0.000 ) 
 CNSsolve>eval($db.GLN_PRO = 0.570 ) 
 CNSsolve>eval($db.GLN_SER = 0.330 ) 
 CNSsolve>eval($db.GLN_THR = 0.130 ) 
 CNSsolve>eval($db.GLN_TRP = 0.000 ) 
 CNSsolve>eval($db.GLN_TYR = 0.470 ) 
 CNSsolve>eval($db.GLN_VAL = 0.230 ) 
 CNSsolve>eval($db.GLU_ALA = 0.260 ) 
 CNSsolve>eval($db.GLU_ARG = 0.340 ) 
 CNSsolve>eval($db.GLU_ASN = 0.230 ) 
 CNSsolve>eval($db.GLU_ASP = 0.450 ) 
 CNSsolve>eval($db.GLU_CYS = 0.180 ) 
 CNSsolve>eval($db.GLU_GLN = 0.370 ) 
 CNSsolve>eval($db.GLU_GLU = 0.310 ) 
 CNSsolve>eval($db.GLU_GLY = 0.270 ) 
 CNSsolve>eval($db.GLU_HIS = 0.730 ) 
 CNSsolve>eval($db.GLU_NEP = 0.730 ) 
 CNSsolve>eval($db.GLU_ILE = 0.260 ) 
 CNSsolve>eval($db.GLU_LEU = 0.230 ) 
 CNSsolve>eval($db.GLU_LYS = 0.390 ) 
 CNSsolve>eval($db.GLU_MET = 0.250 ) 
 CNSsolve>eval($db.GLU_PHE = 0.270 ) 
 CNSsolve>eval($db.GLU_PRO = 0.290 ) 
 CNSsolve>eval($db.GLU_SER = 0.460 ) 
 CNSsolve>eval($db.GLU_THR = 0.270 ) 
 CNSsolve>eval($db.GLU_TRP = 0.170 ) 
 CNSsolve>eval($db.GLU_TYR = 0.310 ) 
 CNSsolve>eval($db.GLU_VAL = 0.270 ) 
 CNSsolve>eval($db.GLY_ALA = 0.290 ) 
 CNSsolve>eval($db.GLY_ARG = 0.270 ) 
 CNSsolve>eval($db.GLY_ASN = 0.280 ) 
 CNSsolve>eval($db.GLY_ASP = 0.120 ) 
 CNSsolve>eval($db.GLY_CYS = 0.400 ) 
 CNSsolve>eval($db.GLY_GLN = 0.240 ) 
 CNSsolve>eval($db.GLY_GLU = 0.270 ) 
 CNSsolve>eval($db.GLY_GLY = 0.190 ) 
 CNSsolve>eval($db.GLY_HIS = 0.240 ) 
 CNSsolve>eval($db.GLY_NEP = 0.240 ) 
 CNSsolve>eval($db.GLY_ILE = 0.090 ) 
 CNSsolve>eval($db.GLY_LEU = 0.190 ) 
 CNSsolve>eval($db.GLY_LYS = 0.520 ) 
 CNSsolve>eval($db.GLY_MET = 0.420 ) 
 CNSsolve>eval($db.GLY_PHE = 0.200 ) 
 CNSsolve>eval($db.GLY_PRO = 0.250 ) 
 CNSsolve>eval($db.GLY_SER = 0.340 ) 
 CNSsolve>eval($db.GLY_THR = 0.240 ) 
 CNSsolve>eval($db.GLY_TRP = 0.110 ) 
 CNSsolve>eval($db.GLY_TYR = 0.370 ) 
 CNSsolve>eval($db.GLY_VAL = 0.250 ) 
 CNSsolve>eval($db.HIS_ALA = 0.240 ) 
 CNSsolve>eval($db.HIS_ARG = 0.340 ) 
 CNSsolve>eval($db.HIS_ASN = 0.230 ) 
 CNSsolve>eval($db.HIS_ASP = 0.700 ) 
 CNSsolve>eval($db.HIS_CYS = 0.000 ) 
 CNSsolve>eval($db.HIS_GLN = 0.240 ) 
 CNSsolve>eval($db.HIS_GLU = 0.730 ) 
 CNSsolve>eval($db.HIS_GLY = 0.240 ) 
 CNSsolve>eval($db.HIS_HIS = 0.570 ) 
 CNSsolve>eval($db.HIS_NEP = 0.570 ) 
 CNSsolve>eval($db.HIS_ILE = 0.190 ) 
 CNSsolve>eval($db.HIS_LEU = 0.100 ) 
 CNSsolve>eval($db.HIS_LYS = 0.280 ) 
 CNSsolve>eval($db.HIS_MET = 0.380 ) 
 CNSsolve>eval($db.HIS_PHE = 0.000 ) 
 CNSsolve>eval($db.HIS_PRO = 0.170 ) 
 CNSsolve>eval($db.HIS_SER = 0.400 ) 
 CNSsolve>eval($db.HIS_THR = 0.430 ) 
 CNSsolve>eval($db.HIS_TRP = 0.400 ) 
 CNSsolve>eval($db.HIS_TYR = 0.160 ) 
 CNSsolve>eval($db.HIS_VAL = 0.000 ) 
 CNSsolve>eval($db.NEP_ALA = 0.240 ) 
 CNSsolve>eval($db.NEP_ARG = 0.340 ) 
 CNSsolve>eval($db.NEP_ASN = 0.230 ) 
 CNSsolve>eval($db.NEP_ASP = 0.700 ) 
 CNSsolve>eval($db.NEP_CYS = 0.000 ) 
 CNSsolve>eval($db.NEP_GLN = 0.240 ) 
 CNSsolve>eval($db.NEP_GLU = 0.730 ) 
 CNSsolve>eval($db.NEP_GLY = 0.240 ) 
 CNSsolve>eval($db.NEP_NEP = 0.570 ) 
 CNSsolve>eval($db.NEP_HIS = 0.570 ) 
 CNSsolve>eval($db.NEP_ILE = 0.190 ) 
 CNSsolve>eval($db.NEP_LEU = 0.100 ) 
 CNSsolve>eval($db.NEP_LYS = 0.280 ) 
 CNSsolve>eval($db.NEP_MET = 0.380 ) 
 CNSsolve>eval($db.NEP_PHE = 0.000 ) 
 CNSsolve>eval($db.NEP_PRO = 0.170 ) 
 CNSsolve>eval($db.NEP_SER = 0.400 ) 
 CNSsolve>eval($db.NEP_THR = 0.430 ) 
 CNSsolve>eval($db.NEP_TRP = 0.400 ) 
 CNSsolve>eval($db.NEP_TYR = 0.160 ) 
 CNSsolve>eval($db.NEP_VAL = 0.000 ) 
 CNSsolve>eval($db.ILE_ALA = 0.170 ) 
 CNSsolve>eval($db.ILE_ARG = 0.240 ) 
 CNSsolve>eval($db.ILE_ASN = 0.070 ) 
 CNSsolve>eval($db.ILE_ASP = 0.100 ) 
 CNSsolve>eval($db.ILE_CYS = 0.090 ) 
 CNSsolve>eval($db.ILE_GLN = 0.150 ) 
 CNSsolve>eval($db.ILE_GLU = 0.260 ) 
 CNSsolve>eval($db.ILE_GLY = 0.090 ) 
 CNSsolve>eval($db.ILE_HIS = 0.190 ) 
 CNSsolve>eval($db.ILE_NEP = 0.190 ) 
 CNSsolve>eval($db.ILE_ILE = 0.090 ) 
 CNSsolve>eval($db.ILE_LEU = 0.110 ) 
 CNSsolve>eval($db.ILE_LYS = 0.240 ) 
 CNSsolve>eval($db.ILE_MET = 0.040 ) 
 CNSsolve>eval($db.ILE_PHE = 0.030 ) 
 CNSsolve>eval($db.ILE_PRO = 0.100 ) 
 CNSsolve>eval($db.ILE_SER = 0.100 ) 
 CNSsolve>eval($db.ILE_THR = 0.060 ) 
 CNSsolve>eval($db.ILE_TRP = 0.000 ) 
 CNSsolve>eval($db.ILE_TYR = 0.020 ) 
 CNSsolve>eval($db.ILE_VAL = 0.080 ) 
 CNSsolve>eval($db.LEU_ALA = 0.110 ) 
 CNSsolve>eval($db.LEU_ARG = 0.240 ) 
 CNSsolve>eval($db.LEU_ASN = 0.100 ) 
 CNSsolve>eval($db.LEU_ASP = 0.140 ) 
 CNSsolve>eval($db.LEU_CYS = 0.050 ) 
 CNSsolve>eval($db.LEU_GLN = 0.190 ) 
 CNSsolve>eval($db.LEU_GLU = 0.230 ) 
 CNSsolve>eval($db.LEU_GLY = 0.190 ) 
 CNSsolve>eval($db.LEU_HIS = 0.100 ) 
 CNSsolve>eval($db.LEU_NEP = 0.100 ) 
 CNSsolve>eval($db.LEU_ILE = 0.110 ) 
 CNSsolve>eval($db.LEU_LEU = 0.110 ) 
 CNSsolve>eval($db.LEU_LYS = 0.180 ) 
 CNSsolve>eval($db.LEU_MET = 0.270 ) 
 CNSsolve>eval($db.LEU_PHE = 0.030 ) 
 CNSsolve>eval($db.LEU_PRO = 0.120 ) 
 CNSsolve>eval($db.LEU_SER = 0.130 ) 
 CNSsolve>eval($db.LEU_THR = 0.130 ) 
 CNSsolve>eval($db.LEU_TRP = 0.110 ) 
 CNSsolve>eval($db.LEU_TYR = 0.090 ) 
 CNSsolve>eval($db.LEU_VAL = 0.100 ) 
 CNSsolve>eval($db.LYS_ALA = 0.210 ) 
 CNSsolve>eval($db.LYS_ARG = 0.350 ) 
 CNSsolve>eval($db.LYS_ASN = 0.270 ) 
 CNSsolve>eval($db.LYS_ASP = 0.460 ) 
 CNSsolve>eval($db.LYS_CYS = 0.330 ) 
 CNSsolve>eval($db.LYS_GLN = 0.350 ) 
 CNSsolve>eval($db.LYS_GLU = 0.390 ) 
 CNSsolve>eval($db.LYS_GLY = 0.520 ) 
 CNSsolve>eval($db.LYS_HIS = 0.280 ) 
 CNSsolve>eval($db.LYS_NEP = 0.280 ) 
 CNSsolve>eval($db.LYS_ILE = 0.240 ) 
 CNSsolve>eval($db.LYS_LEU = 0.180 ) 
 CNSsolve>eval($db.LYS_LYS = 0.580 ) 
 CNSsolve>eval($db.LYS_MET = 0.210 ) 
 CNSsolve>eval($db.LYS_PHE = 0.280 ) 
 CNSsolve>eval($db.LYS_PRO = 0.200 ) 
 CNSsolve>eval($db.LYS_SER = 0.420 ) 
 CNSsolve>eval($db.LYS_THR = 0.320 ) 
 CNSsolve>eval($db.LYS_TRP = 0.220 ) 
 CNSsolve>eval($db.LYS_TYR = 0.240 ) 
 CNSsolve>eval($db.LYS_VAL = 0.260 ) 
 CNSsolve>eval($db.MET_ALA = 0.240 ) 
 CNSsolve>eval($db.MET_ARG = 0.300 ) 
 CNSsolve>eval($db.MET_ASN = 0.190 ) 
 CNSsolve>eval($db.MET_ASP = 0.190 ) 
 CNSsolve>eval($db.MET_CYS = 0.000 ) 
 CNSsolve>eval($db.MET_GLN = 0.230 ) 
 CNSsolve>eval($db.MET_GLU = 0.250 ) 
 CNSsolve>eval($db.MET_GLY = 0.420 ) 
 CNSsolve>eval($db.MET_HIS = 0.380 ) 
 CNSsolve>eval($db.MET_NEP = 0.380 ) 
 CNSsolve>eval($db.MET_ILE = 0.040 ) 
 CNSsolve>eval($db.MET_LEU = 0.270 ) 
 CNSsolve>eval($db.MET_LYS = 0.210 ) 
 CNSsolve>eval($db.MET_MET = 0.400 ) 
 CNSsolve>eval($db.MET_PHE = 0.000 ) 
 CNSsolve>eval($db.MET_PRO = 0.000 ) 
 CNSsolve>eval($db.MET_SER = 0.120 ) 
 CNSsolve>eval($db.MET_THR = 0.350 ) 
 CNSsolve>eval($db.MET_TRP = 0.240 ) 
 CNSsolve>eval($db.MET_TYR = 0.230 ) 
 CNSsolve>eval($db.MET_VAL = 0.170 ) 
 CNSsolve>eval($db.PHE_ALA = 0.070 ) 
 CNSsolve>eval($db.PHE_ARG = 0.090 ) 
 CNSsolve>eval($db.PHE_ASN = 0.050 ) 
 CNSsolve>eval($db.PHE_ASP = 0.310 ) 
 CNSsolve>eval($db.PHE_CYS = 0.000 ) 
 CNSsolve>eval($db.PHE_GLN = 0.000 ) 
 CNSsolve>eval($db.PHE_GLU = 0.270 ) 
 CNSsolve>eval($db.PHE_GLY = 0.200 ) 
 CNSsolve>eval($db.PHE_HIS = 0.000 ) 
 CNSsolve>eval($db.PHE_NEP = 0.000 ) 
 CNSsolve>eval($db.PHE_ILE = 0.030 ) 
 CNSsolve>eval($db.PHE_LEU = 0.030 ) 
 CNSsolve>eval($db.PHE_LYS = 0.280 ) 
 CNSsolve>eval($db.PHE_MET = 0.000 ) 
 CNSsolve>eval($db.PHE_PHE = 0.000 ) 
 CNSsolve>eval($db.PHE_PRO = 0.000 ) 
 CNSsolve>eval($db.PHE_SER = 0.070 ) 
 CNSsolve>eval($db.PHE_THR = 0.030 ) 
 CNSsolve>eval($db.PHE_TRP = 0.000 ) 
 CNSsolve>eval($db.PHE_TYR = 0.120 ) 
 CNSsolve>eval($db.PHE_VAL = 0.110 ) 
 CNSsolve>eval($db.PRO_ALA = 0.240 ) 
 CNSsolve>eval($db.PRO_ARG = 0.340 ) 
 CNSsolve>eval($db.PRO_ASN = 0.110 ) 
 CNSsolve>eval($db.PRO_ASP = 0.130 ) 
 CNSsolve>eval($db.PRO_CYS = 0.200 ) 
 CNSsolve>eval($db.PRO_GLN = 0.570 ) 
 CNSsolve>eval($db.PRO_GLU = 0.290 ) 
 CNSsolve>eval($db.PRO_GLY = 0.250 ) 
 CNSsolve>eval($db.PRO_HIS = 0.170 ) 
 CNSsolve>eval($db.PRO_NEP = 0.170 ) 
 CNSsolve>eval($db.PRO_ILE = 0.100 ) 
 CNSsolve>eval($db.PRO_LEU = 0.120 ) 
 CNSsolve>eval($db.PRO_LYS = 0.200 ) 
 CNSsolve>eval($db.PRO_MET = 0.000 ) 
 CNSsolve>eval($db.PRO_PHE = 0.000 ) 
 CNSsolve>eval($db.PRO_PRO = 0.300 ) 
 CNSsolve>eval($db.PRO_SER = 0.190 ) 
 CNSsolve>eval($db.PRO_THR = 0.240 ) 
 CNSsolve>eval($db.PRO_TRP = 0.140 ) 
 CNSsolve>eval($db.PRO_TYR = 0.550 ) 
 CNSsolve>eval($db.PRO_VAL = 0.200 ) 
 CNSsolve>eval($db.SER_ALA = 0.170 ) 
 CNSsolve>eval($db.SER_ARG = 0.380 ) 
 CNSsolve>eval($db.SER_ASN = 0.270 ) 
 CNSsolve>eval($db.SER_ASP = 0.270 ) 
 CNSsolve>eval($db.SER_CYS = 0.580 ) 
 CNSsolve>eval($db.SER_GLN = 0.330 ) 
 CNSsolve>eval($db.SER_GLU = 0.460 ) 
 CNSsolve>eval($db.SER_GLY = 0.340 ) 
 CNSsolve>eval($db.SER_HIS = 0.400 ) 
 CNSsolve>eval($db.SER_NEP = 0.400 ) 
 CNSsolve>eval($db.SER_ILE = 0.100 ) 
 CNSsolve>eval($db.SER_LEU = 0.130 ) 
 CNSsolve>eval($db.SER_LYS = 0.420 ) 
 CNSsolve>eval($db.SER_MET = 0.120 ) 
 CNSsolve>eval($db.SER_PHE = 0.070 ) 
 CNSsolve>eval($db.SER_PRO = 0.190 ) 
 CNSsolve>eval($db.SER_SER = 0.130 ) 
 CNSsolve>eval($db.SER_THR = 0.340 ) 
 CNSsolve>eval($db.SER_TRP = 0.000 ) 
 CNSsolve>eval($db.SER_TYR = 0.140 ) 
 CNSsolve>eval($db.SER_VAL = 0.220 ) 
 CNSsolve>eval($db.THR_ALA = 0.060 ) 
 CNSsolve>eval($db.THR_ARG = 0.120 ) 
 CNSsolve>eval($db.THR_ASN = 0.250 ) 
 CNSsolve>eval($db.THR_ASP = 0.250 ) 
 CNSsolve>eval($db.THR_CYS = 0.000 ) 
 CNSsolve>eval($db.THR_GLN = 0.130 ) 
 CNSsolve>eval($db.THR_GLU = 0.270 ) 
 CNSsolve>eval($db.THR_GLY = 0.240 ) 
 CNSsolve>eval($db.THR_HIS = 0.430 ) 
 CNSsolve>eval($db.THR_NEP = 0.430 ) 
 CNSsolve>eval($db.THR_ILE = 0.060 ) 
 CNSsolve>eval($db.THR_LEU = 0.130 ) 
 CNSsolve>eval($db.THR_LYS = 0.320 ) 
 CNSsolve>eval($db.THR_MET = 0.350 ) 
 CNSsolve>eval($db.THR_PHE = 0.030 ) 
 CNSsolve>eval($db.THR_PRO = 0.240 ) 
 CNSsolve>eval($db.THR_SER = 0.340 ) 
 CNSsolve>eval($db.THR_THR = 0.090 ) 
 CNSsolve>eval($db.THR_TRP = 0.000 ) 
 CNSsolve>eval($db.THR_TYR = 0.200 ) 
 CNSsolve>eval($db.THR_VAL = 0.140 ) 
 CNSsolve>eval($db.TRP_ALA = 0.150 ) 
 CNSsolve>eval($db.TRP_ARG = 0.180 ) 
 CNSsolve>eval($db.TRP_ASN = 0.000 ) 
 CNSsolve>eval($db.TRP_ASP = 0.140 ) 
 CNSsolve>eval($db.TRP_CYS = 0.250 ) 
 CNSsolve>eval($db.TRP_GLN = 0.000 ) 
 CNSsolve>eval($db.TRP_GLU = 0.170 ) 
 CNSsolve>eval($db.TRP_GLY = 0.110 ) 
 CNSsolve>eval($db.TRP_HIS = 0.400 ) 
 CNSsolve>eval($db.TRP_NEP = 0.400 ) 
 CNSsolve>eval($db.TRP_ILE = 0.000 ) 
 CNSsolve>eval($db.TRP_LEU = 0.110 ) 
 CNSsolve>eval($db.TRP_LYS = 0.220 ) 
 CNSsolve>eval($db.TRP_MET = 0.240 ) 
 CNSsolve>eval($db.TRP_PHE = 0.000 ) 
 CNSsolve>eval($db.TRP_PRO = 0.140 ) 
 CNSsolve>eval($db.TRP_SER = 0.000 ) 
 CNSsolve>eval($db.TRP_THR = 0.000 ) 
 CNSsolve>eval($db.TRP_TRP = 0.000 ) 
 CNSsolve>eval($db.TRP_TYR = 0.250 ) 
 CNSsolve>eval($db.TRP_VAL = 0.140 ) 
 CNSsolve>eval($db.TYR_ALA = 0.150 ) 
 CNSsolve>eval($db.TYR_ARG = 0.280 ) 
 CNSsolve>eval($db.TYR_ASN = 0.170 ) 
 CNSsolve>eval($db.TYR_ASP = 0.280 ) 
 CNSsolve>eval($db.TYR_CYS = 0.060 ) 
 CNSsolve>eval($db.TYR_GLN = 0.470 ) 
 CNSsolve>eval($db.TYR_GLU = 0.310 ) 
 CNSsolve>eval($db.TYR_GLY = 0.370 ) 
 CNSsolve>eval($db.TYR_HIS = 0.160 ) 
 CNSsolve>eval($db.TYR_NEP = 0.160 ) 
 CNSsolve>eval($db.TYR_ILE = 0.020 ) 
 CNSsolve>eval($db.TYR_LEU = 0.090 ) 
 CNSsolve>eval($db.TYR_LYS = 0.240 ) 
 CNSsolve>eval($db.TYR_MET = 0.230 ) 
 CNSsolve>eval($db.TYR_PHE = 0.120 ) 
 CNSsolve>eval($db.TYR_PRO = 0.550 ) 
 CNSsolve>eval($db.TYR_SER = 0.140 ) 
 CNSsolve>eval($db.TYR_THR = 0.200 ) 
 CNSsolve>eval($db.TYR_TRP = 0.250 ) 
 CNSsolve>eval($db.TYR_TYR = 0.270 ) 
 CNSsolve>eval($db.TYR_VAL = 0.220 ) 
 CNSsolve>eval($db.VAL_ALA = 0.080 ) 
 CNSsolve>eval($db.VAL_ARG = 0.280 ) 
 CNSsolve>eval($db.VAL_ASN = 0.260 ) 
 CNSsolve>eval($db.VAL_ASP = 0.310 ) 
 CNSsolve>eval($db.VAL_CYS = 0.140 ) 
 CNSsolve>eval($db.VAL_GLN = 0.230 ) 
 CNSsolve>eval($db.VAL_GLU = 0.270 ) 
 CNSsolve>eval($db.VAL_GLY = 0.250 ) 
 CNSsolve>eval($db.VAL_HIS = 0.000 ) 
 CNSsolve>eval($db.VAL_NEP = 0.000 ) 
 CNSsolve>eval($db.VAL_ILE = 0.080 ) 
 CNSsolve>eval($db.VAL_LEU = 0.100 ) 
 CNSsolve>eval($db.VAL_LYS = 0.260 ) 
 CNSsolve>eval($db.VAL_MET = 0.170 ) 
 CNSsolve>eval($db.VAL_PHE = 0.110 ) 
 CNSsolve>eval($db.VAL_PRO = 0.200 ) 
 CNSsolve>eval($db.VAL_SER = 0.220 ) 
 CNSsolve>eval($db.VAL_THR = 0.140 ) 
 CNSsolve>eval($db.VAL_TRP = 0.140 ) 
 CNSsolve>eval($db.VAL_TYR = 0.220 ) 
 CNSsolve>eval($db.VAL_VAL = 0.170 ) 
 CNSsolve> 
 CNSsolve>eval($db.ALA_DA = 0.00 ) 
 CNSsolve>eval($db.ALA_DC = 0.00 ) 
 CNSsolve>eval($db.ALA_DG = 0.00 ) 
 CNSsolve>eval($db.ALA_DT = 0.00 ) 
 CNSsolve>eval($db.ARG_DA = 0.14 ) 
 CNSsolve>eval($db.ARG_DC = 0.07 ) 
 CNSsolve>eval($db.ARG_DG = 0.14 ) 
 CNSsolve>eval($db.ARG_DT = 0.08 ) 
 CNSsolve>eval($db.ASN_DA = 0.19 ) 
 CNSsolve>eval($db.ASN_DC = 0.09 ) 
 CNSsolve>eval($db.ASN_DG = 0.22 ) 
 CNSsolve>eval($db.ASN_DT = 0.10 ) 
 CNSsolve>eval($db.ASP_DA = 0.44 ) 
 CNSsolve>eval($db.ASP_DC = 0.16 ) 
 CNSsolve>eval($db.ASP_DG = 0.10 ) 
 CNSsolve>eval($db.ASP_DT = 0.05 ) 
 CNSsolve>eval($db.CYS_DA = 0.00 ) 
 CNSsolve>eval($db.CYS_DC = 0.00 ) 
 CNSsolve>eval($db.CYS_DG = 0.00 ) 
 CNSsolve>eval($db.CYS_DT = 0.00 ) 
 CNSsolve>eval($db.GLN_DA = 0.15 ) 
 CNSsolve>eval($db.GLN_DC = 0.19 ) 
 CNSsolve>eval($db.GLN_DG = 0.15 ) 
 CNSsolve>eval($db.GLN_DT = 0.13 ) 
 CNSsolve>eval($db.GLU_DA = 0.11 ) 
 CNSsolve>eval($db.GLU_DC = 0.15 ) 
 CNSsolve>eval($db.GLU_DG = 0.13 ) 
 CNSsolve>eval($db.GLU_DT = 0.00 ) 
 CNSsolve>eval($db.GLY_DA = 0.00 ) 
 CNSsolve>eval($db.GLY_DC = 0.00 ) 
 CNSsolve>eval($db.GLY_DG = 0.00 ) 
 CNSsolve>eval($db.GLY_DT = 0.00 ) 
 CNSsolve>eval($db.HIS_DA = 0.10 ) 
 CNSsolve>eval($db.HIS_DC = 0.14 ) 
 CNSsolve>eval($db.HIS_DG = 0.18 ) 
 CNSsolve>eval($db.HIS_DT = 0.06 ) 
 CNSsolve>eval($db.ILE_DA = 0.00 ) 
 CNSsolve>eval($db.ILE_DC = 0.00 ) 
 CNSsolve>eval($db.ILE_DG = 0.00 ) 
 CNSsolve>eval($db.ILE_DT = 0.00 ) 
 CNSsolve>eval($db.LEU_DA = 0.00 ) 
 CNSsolve>eval($db.LEU_DC = 0.00 ) 
 CNSsolve>eval($db.LEU_DG = 0.00 ) 
 CNSsolve>eval($db.LEU_DT = 0.00 ) 
 CNSsolve>eval($db.LYS_DA = 0.31 ) 
 CNSsolve>eval($db.LYS_DC = 0.15 ) 
 CNSsolve>eval($db.LYS_DG = 0.29 ) 
 CNSsolve>eval($db.LYS_DT = 0.18 ) 
 CNSsolve>eval($db.MET_DA = 0.00 ) 
 CNSsolve>eval($db.MET_DC = 0.00 ) 
 CNSsolve>eval($db.MET_DG = 0.00 ) 
 CNSsolve>eval($db.MET_DT = 0.00 ) 
 CNSsolve>eval($db.PHE_DA = 0.00 ) 
 CNSsolve>eval($db.PHE_DC = 0.00 ) 
 CNSsolve>eval($db.PHE_DG = 0.00 ) 
 CNSsolve>eval($db.PHE_DT = 0.00 ) 
 CNSsolve>eval($db.PRO_DA = 0.00 ) 
 CNSsolve>eval($db.PRO_DC = 0.00 ) 
 CNSsolve>eval($db.PRO_DG = 0.00 ) 
 CNSsolve>eval($db.PRO_DT = 0.00 ) 
 CNSsolve>eval($db.SER_DA = 0.30 ) 
 CNSsolve>eval($db.SER_DC = 0.03 ) 
 CNSsolve>eval($db.SER_DG = 0.09 ) 
 CNSsolve>eval($db.SER_DT = 0.03 ) 
 CNSsolve>eval($db.THR_DA = 0.16 ) 
 CNSsolve>eval($db.THR_DC = 0.16 ) 
 CNSsolve>eval($db.THR_DG = 0.03 ) 
 CNSsolve>eval($db.THR_DT = 0.05 ) 
 CNSsolve>eval($db.TRP_DA = 0.00 ) 
 CNSsolve>eval($db.TRP_DC = 0.00 ) 
 CNSsolve>eval($db.TRP_DG = 0.00 ) 
 CNSsolve>eval($db.TRP_DT = 0.00 ) 
 CNSsolve>eval($db.TYR_DA = 0.13 ) 
 CNSsolve>eval($db.TYR_DC = 0.10 ) 
 CNSsolve>eval($db.TYR_DG = 0.10 ) 
 CNSsolve>eval($db.TYR_DT = 0.02 ) 
 CNSsolve>eval($db.VAL_DA = 0.00 ) 
 CNSsolve>eval($db.VAL_DC = 0.00 ) 
 CNSsolve>eval($db.VAL_DG = 0.00 ) 
 CNSsolve>eval($db.VAL_DT = 0.00 ) 
 CNSsolve>eval($db.DA_ALA = 0.00 ) 
 CNSsolve>eval($db.DC_ALA = 0.00 ) 
 CNSsolve>eval($db.DG_ALA = 0.00 ) 
 CNSsolve>eval($db.DT_ALA = 0.00 ) 
 CNSsolve>eval($db.DA_ARG = 0.14 ) 
 CNSsolve>eval($db.DC_ARG = 0.07 ) 
 CNSsolve>eval($db.DG_ARG = 0.14 ) 
 CNSsolve>eval($db.DT_ARG = 0.08 ) 
 CNSsolve>eval($db.DA_ASN = 0.19 ) 
 CNSsolve>eval($db.DC_ASN = 0.09 ) 
 CNSsolve>eval($db.DG_ASN = 0.22 ) 
 CNSsolve>eval($db.DT_ASN = 0.10 ) 
 CNSsolve>eval($db.DA_ASP = 0.44 ) 
 CNSsolve>eval($db.DC_ASP = 0.16 ) 
 CNSsolve>eval($db.DG_ASP = 0.10 ) 
 CNSsolve>eval($db.DT_ASP = 0.05 ) 
 CNSsolve>eval($db.DA_CYS = 0.00 ) 
 CNSsolve>eval($db.DC_CYS = 0.00 ) 
 CNSsolve>eval($db.DG_CYS = 0.00 ) 
 CNSsolve>eval($db.DT_CYS = 0.00 ) 
 CNSsolve>eval($db.DA_GLN = 0.15 ) 
 CNSsolve>eval($db.DC_GLN = 0.19 ) 
 CNSsolve>eval($db.DG_GLN = 0.15 ) 
 CNSsolve>eval($db.DT_GLN = 0.13 ) 
 CNSsolve>eval($db.DA_GLU = 0.11 ) 
 CNSsolve>eval($db.DC_GLU = 0.15 ) 
 CNSsolve>eval($db.DG_GLU = 0.13 ) 
 CNSsolve>eval($db.DT_GLU = 0.00 ) 
 CNSsolve>eval($db.DA_GLY = 0.00 ) 
 CNSsolve>eval($db.DC_GLY = 0.00 ) 
 CNSsolve>eval($db.DG_GLY = 0.00 ) 
 CNSsolve>eval($db.DT_GLY = 0.00 ) 
 CNSsolve>eval($db.DA_HIS = 0.10 ) 
 CNSsolve>eval($db.DC_HIS = 0.14 ) 
 CNSsolve>eval($db.DG_HIS = 0.18 ) 
 CNSsolve>eval($db.DT_HIS = 0.06 ) 
 CNSsolve>eval($db.DA_ILE = 0.00 ) 
 CNSsolve>eval($db.DC_ILE = 0.00 ) 
 CNSsolve>eval($db.DG_ILE = 0.00 ) 
 CNSsolve>eval($db.DT_ILE = 0.00 ) 
 CNSsolve>eval($db.DA_LEU = 0.00 ) 
 CNSsolve>eval($db.DC_LEU = 0.00 ) 
 CNSsolve>eval($db.DG_LEU = 0.00 ) 
 CNSsolve>eval($db.DT_LEU = 0.00 ) 
 CNSsolve>eval($db.DA_LYS = 0.31 ) 
 CNSsolve>eval($db.DC_LYS = 0.15 ) 
 CNSsolve>eval($db.DG_LYS = 0.29 ) 
 CNSsolve>eval($db.DT_LYS = 0.18 ) 
 CNSsolve>eval($db.DA_MET = 0.00 ) 
 CNSsolve>eval($db.DC_MET = 0.00 ) 
 CNSsolve>eval($db.DG_MET = 0.00 ) 
 CNSsolve>eval($db.DT_MET = 0.00 ) 
 CNSsolve>eval($db.DA_PHE = 0.00 ) 
 CNSsolve>eval($db.DC_PHE = 0.00 ) 
 CNSsolve>eval($db.DG_PHE = 0.00 ) 
 CNSsolve>eval($db.DT_PHE = 0.00 ) 
 CNSsolve>eval($db.DA_PRO = 0.00 ) 
 CNSsolve>eval($db.DC_PRO = 0.00 ) 
 CNSsolve>eval($db.DG_PRO = 0.00 ) 
 CNSsolve>eval($db.DT_PRO = 0.00 ) 
 CNSsolve>eval($db.DA_SER = 0.30 ) 
 CNSsolve>eval($db.DC_SER = 0.03 ) 
 CNSsolve>eval($db.DG_SER = 0.09 ) 
 CNSsolve>eval($db.DT_SER = 0.03 ) 
 CNSsolve>eval($db.DA_THR = 0.16 ) 
 CNSsolve>eval($db.DC_THR = 0.16 ) 
 CNSsolve>eval($db.DG_THR = 0.03 ) 
 CNSsolve>eval($db.DT_THR = 0.05 ) 
 CNSsolve>eval($db.DA_TRP = 0.00 ) 
 CNSsolve>eval($db.DC_TRP = 0.00 ) 
 CNSsolve>eval($db.DG_TRP = 0.00 ) 
 CNSsolve>eval($db.DT_TRP = 0.00 ) 
 CNSsolve>eval($db.DA_TYR = 0.13 ) 
 CNSsolve>eval($db.DC_TYR = 0.10 ) 
 CNSsolve>eval($db.DG_TYR = 0.10 ) 
 CNSsolve>eval($db.DT_TYR = 0.02 ) 
 CNSsolve>eval($db.DA_VAL = 0.00 ) 
 CNSsolve>eval($db.DC_VAL = 0.00 ) 
 CNSsolve>eval($db.DG_VAL = 0.00 ) 
 CNSsolve>eval($db.DT_VAL = 0.00 ) 
 CNSsolve> 
 CNSsolve>eval($db.ALA_A = 0.00 ) 
 CNSsolve>eval($db.ALA_C = 0.00 ) 
 CNSsolve>eval($db.ALA_G = 0.00 ) 
 CNSsolve>eval($db.ALA_T = 0.00 ) 
 CNSsolve>eval($db.ARG_A = 0.14 ) 
 CNSsolve>eval($db.ARG_C = 0.07 ) 
 CNSsolve>eval($db.ARG_G = 0.14 ) 
 CNSsolve>eval($db.ARG_T = 0.08 ) 
 CNSsolve>eval($db.ASN_A = 0.19 ) 
 CNSsolve>eval($db.ASN_C = 0.09 ) 
 CNSsolve>eval($db.ASN_G = 0.22 ) 
 CNSsolve>eval($db.ASN_T = 0.10 ) 
 CNSsolve>eval($db.ASP_A = 0.44 ) 
 CNSsolve>eval($db.ASP_C = 0.16 ) 
 CNSsolve>eval($db.ASP_G = 0.10 ) 
 CNSsolve>eval($db.ASP_T = 0.05 ) 
 CNSsolve>eval($db.CYS_A = 0.00 ) 
 CNSsolve>eval($db.CYS_C = 0.00 ) 
 CNSsolve>eval($db.CYS_G = 0.00 ) 
 CNSsolve>eval($db.CYS_T = 0.00 ) 
 CNSsolve>eval($db.GLN_A = 0.15 ) 
 CNSsolve>eval($db.GLN_C = 0.19 ) 
 CNSsolve>eval($db.GLN_G = 0.15 ) 
 CNSsolve>eval($db.GLN_T = 0.13 ) 
 CNSsolve>eval($db.GLU_A = 0.11 ) 
 CNSsolve>eval($db.GLU_C = 0.15 ) 
 CNSsolve>eval($db.GLU_G = 0.13 ) 
 CNSsolve>eval($db.GLU_T = 0.00 ) 
 CNSsolve>eval($db.GLY_A = 0.00 ) 
 CNSsolve>eval($db.GLY_C = 0.00 ) 
 CNSsolve>eval($db.GLY_G = 0.00 ) 
 CNSsolve>eval($db.GLY_T = 0.00 ) 
 CNSsolve>eval($db.HIS_A = 0.10 ) 
 CNSsolve>eval($db.HIS_C = 0.14 ) 
 CNSsolve>eval($db.HIS_G = 0.18 ) 
 CNSsolve>eval($db.HIS_T = 0.06 ) 
 CNSsolve>eval($db.ILE_A = 0.00 ) 
 CNSsolve>eval($db.ILE_C = 0.00 ) 
 CNSsolve>eval($db.ILE_G = 0.00 ) 
 CNSsolve>eval($db.ILE_T = 0.00 ) 
 CNSsolve>eval($db.LEU_A = 0.00 ) 
 CNSsolve>eval($db.LEU_C = 0.00 ) 
 CNSsolve>eval($db.LEU_G = 0.00 ) 
 CNSsolve>eval($db.LEU_T = 0.00 ) 
 CNSsolve>eval($db.LYS_A = 0.31 ) 
 CNSsolve>eval($db.LYS_C = 0.15 ) 
 CNSsolve>eval($db.LYS_G = 0.29 ) 
 CNSsolve>eval($db.LYS_T = 0.18 ) 
 CNSsolve>eval($db.MET_A = 0.00 ) 
 CNSsolve>eval($db.MET_C = 0.00 ) 
 CNSsolve>eval($db.MET_G = 0.00 ) 
 CNSsolve>eval($db.MET_T = 0.00 ) 
 CNSsolve>eval($db.PHE_A = 0.00 ) 
 CNSsolve>eval($db.PHE_C = 0.00 ) 
 CNSsolve>eval($db.PHE_G = 0.00 ) 
 CNSsolve>eval($db.PHE_T = 0.00 ) 
 CNSsolve>eval($db.PRO_A = 0.00 ) 
 CNSsolve>eval($db.PRO_C = 0.00 ) 
 CNSsolve>eval($db.PRO_G = 0.00 ) 
 CNSsolve>eval($db.PRO_T = 0.00 ) 
 CNSsolve>eval($db.SER_A = 0.30 ) 
 CNSsolve>eval($db.SER_C = 0.03 ) 
 CNSsolve>eval($db.SER_G = 0.09 ) 
 CNSsolve>eval($db.SER_T = 0.03 ) 
 CNSsolve>eval($db.THR_A = 0.16 ) 
 CNSsolve>eval($db.THR_C = 0.16 ) 
 CNSsolve>eval($db.THR_G = 0.03 ) 
 CNSsolve>eval($db.THR_T = 0.05 ) 
 CNSsolve>eval($db.TRP_A = 0.00 ) 
 CNSsolve>eval($db.TRP_C = 0.00 ) 
 CNSsolve>eval($db.TRP_G = 0.00 ) 
 CNSsolve>eval($db.TRP_T = 0.00 ) 
 CNSsolve>eval($db.TYR_A = 0.13 ) 
 CNSsolve>eval($db.TYR_C = 0.10 ) 
 CNSsolve>eval($db.TYR_G = 0.10 ) 
 CNSsolve>eval($db.TYR_T = 0.02 ) 
 CNSsolve>eval($db.VAL_A = 0.00 ) 
 CNSsolve>eval($db.VAL_C = 0.00 ) 
 CNSsolve>eval($db.VAL_G = 0.00 ) 
 CNSsolve>eval($db.VAL_T = 0.00 ) 
 CNSsolve>eval($db.A_ALA = 0.00 ) 
 CNSsolve>eval($db.C_ALA = 0.00 ) 
 CNSsolve>eval($db.G_ALA = 0.00 ) 
 CNSsolve>eval($db.T_ALA = 0.00 ) 
 CNSsolve>eval($db.A_ARG = 0.14 ) 
 CNSsolve>eval($db.C_ARG = 0.07 ) 
 CNSsolve>eval($db.G_ARG = 0.14 ) 
 CNSsolve>eval($db.T_ARG = 0.08 ) 
 CNSsolve>eval($db.A_ASN = 0.19 ) 
 CNSsolve>eval($db.C_ASN = 0.09 ) 
 CNSsolve>eval($db.G_ASN = 0.22 ) 
 CNSsolve>eval($db.T_ASN = 0.10 ) 
 CNSsolve>eval($db.A_ASP = 0.44 ) 
 CNSsolve>eval($db.C_ASP = 0.16 ) 
 CNSsolve>eval($db.G_ASP = 0.10 ) 
 CNSsolve>eval($db.T_ASP = 0.05 ) 
 CNSsolve>eval($db.A_CYS = 0.00 ) 
 CNSsolve>eval($db.C_CYS = 0.00 ) 
 CNSsolve>eval($db.G_CYS = 0.00 ) 
 CNSsolve>eval($db.T_CYS = 0.00 ) 
 CNSsolve>eval($db.A_GLN = 0.15 ) 
 CNSsolve>eval($db.C_GLN = 0.19 ) 
 CNSsolve>eval($db.G_GLN = 0.15 ) 
 CNSsolve>eval($db.T_GLN = 0.13 ) 
 CNSsolve>eval($db.A_GLU = 0.11 ) 
 CNSsolve>eval($db.C_GLU = 0.15 ) 
 CNSsolve>eval($db.G_GLU = 0.13 ) 
 CNSsolve>eval($db.T_GLU = 0.00 ) 
 CNSsolve>eval($db.A_GLY = 0.00 ) 
 CNSsolve>eval($db.C_GLY = 0.00 ) 
 CNSsolve>eval($db.G_GLY = 0.00 ) 
 CNSsolve>eval($db.T_GLY = 0.00 ) 
 CNSsolve>eval($db.A_HIS = 0.10 ) 
 CNSsolve>eval($db.C_HIS = 0.14 ) 
 CNSsolve>eval($db.G_HIS = 0.18 ) 
 CNSsolve>eval($db.T_HIS = 0.06 ) 
 CNSsolve>eval($db.A_ILE = 0.00 ) 
 CNSsolve>eval($db.C_ILE = 0.00 ) 
 CNSsolve>eval($db.G_ILE = 0.00 ) 
 CNSsolve>eval($db.T_ILE = 0.00 ) 
 CNSsolve>eval($db.A_LEU = 0.00 ) 
 CNSsolve>eval($db.C_LEU = 0.00 ) 
 CNSsolve>eval($db.G_LEU = 0.00 ) 
 CNSsolve>eval($db.T_LEU = 0.00 ) 
 CNSsolve>eval($db.A_LYS = 0.31 ) 
 CNSsolve>eval($db.C_LYS = 0.15 ) 
 CNSsolve>eval($db.G_LYS = 0.29 ) 
 CNSsolve>eval($db.T_LYS = 0.18 ) 
 CNSsolve>eval($db.A_MET = 0.00 ) 
 CNSsolve>eval($db.C_MET = 0.00 ) 
 CNSsolve>eval($db.G_MET = 0.00 ) 
 CNSsolve>eval($db.T_MET = 0.00 ) 
 CNSsolve>eval($db.A_PHE = 0.00 ) 
 CNSsolve>eval($db.C_PHE = 0.00 ) 
 CNSsolve>eval($db.G_PHE = 0.00 ) 
 CNSsolve>eval($db.T_PHE = 0.00 ) 
 CNSsolve>eval($db.A_PRO = 0.00 ) 
 CNSsolve>eval($db.C_PRO = 0.00 ) 
 CNSsolve>eval($db.G_PRO = 0.00 ) 
 CNSsolve>eval($db.T_PRO = 0.00 ) 
 CNSsolve>eval($db.A_SER = 0.30 ) 
 CNSsolve>eval($db.C_SER = 0.03 ) 
 CNSsolve>eval($db.G_SER = 0.09 ) 
 CNSsolve>eval($db.T_SER = 0.03 ) 
 CNSsolve>eval($db.A_THR = 0.16 ) 
 CNSsolve>eval($db.C_THR = 0.16 ) 
 CNSsolve>eval($db.G_THR = 0.03 ) 
 CNSsolve>eval($db.T_THR = 0.05 ) 
 CNSsolve>eval($db.A_TRP = 0.00 ) 
 CNSsolve>eval($db.C_TRP = 0.00 ) 
 CNSsolve>eval($db.G_TRP = 0.00 ) 
 CNSsolve>eval($db.T_TRP = 0.00 ) 
 CNSsolve>eval($db.A_TYR = 0.13 ) 
 CNSsolve>eval($db.C_TYR = 0.10 ) 
 CNSsolve>eval($db.G_TYR = 0.10 ) 
 CNSsolve>eval($db.T_TYR = 0.02 ) 
 CNSsolve>eval($db.A_VAL = 0.00 ) 
 CNSsolve>eval($db.C_VAL = 0.00 ) 
 CNSsolve>eval($db.G_VAL = 0.00 ) 
 CNSsolve>eval($db.T_VAL = 0.00 ) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>eval($db.DP_ALA_A = 0.51 ) 
 CNSsolve>eval($db.DP_ALA_C = 0.51 ) 
 CNSsolve>eval($db.DP_ALA_G = 0.51 ) 
 CNSsolve>eval($db.DP_ALA_T = 0.51 ) 
 CNSsolve>eval($db.DP_ARG_A = 0.34 ) 
 CNSsolve>eval($db.DP_ARG_C = 0.34 ) 
 CNSsolve>eval($db.DP_ARG_G = 0.34 ) 
 CNSsolve>eval($db.DP_ARG_T = 0.34 ) 
 CNSsolve>eval($db.DP_ASN_A = 0.52 ) 
 CNSsolve>eval($db.DP_ASN_C = 0.52 ) 
 CNSsolve>eval($db.DP_ASN_G = 0.52 ) 
 CNSsolve>eval($db.DP_ASN_T = 0.52 ) 
 CNSsolve>eval($db.DP_ASP_A = 0.93 ) 
 CNSsolve>eval($db.DP_ASP_C = 0.93 ) 
 CNSsolve>eval($db.DP_ASP_G = 0.93 ) 
 CNSsolve>eval($db.DP_ASP_T = 0.93 ) 
 CNSsolve>eval($db.DP_CYS_A = 0.43 ) 
 CNSsolve>eval($db.DP_CYS_C = 0.43 ) 
 CNSsolve>eval($db.DP_CYS_G = 0.43 ) 
 CNSsolve>eval($db.DP_CYS_T = 0.43 ) 
 CNSsolve>eval($db.DP_GLN_A = 0.47 ) 
 CNSsolve>eval($db.DP_GLN_C = 0.47 ) 
 CNSsolve>eval($db.DP_GLN_G = 0.47 ) 
 CNSsolve>eval($db.DP_GLN_T = 0.47 ) 
 CNSsolve>eval($db.DP_GLU_A = 0.83 ) 
 CNSsolve>eval($db.DP_GLU_C = 0.83 ) 
 CNSsolve>eval($db.DP_GLU_G = 0.83 ) 
 CNSsolve>eval($db.DP_GLU_T = 0.83 ) 
 CNSsolve>eval($db.DP_GLY_A = 0.38 ) 
 CNSsolve>eval($db.DP_GLY_C = 0.38 ) 
 CNSsolve>eval($db.DP_GLY_G = 0.38 ) 
 CNSsolve>eval($db.DP_GLY_T = 0.38 ) 
 CNSsolve>eval($db.DP_HIS_A = 0.40 ) 
 CNSsolve>eval($db.DP_HIS_C = 0.40 ) 
 CNSsolve>eval($db.DP_HIS_G = 0.40 ) 
 CNSsolve>eval($db.DP_HIS_T = 0.40 ) 
 CNSsolve>eval($db.DP_ILE_A = 0.54 ) 
 CNSsolve>eval($db.DP_ILE_C = 0.54 ) 
 CNSsolve>eval($db.DP_ILE_G = 0.54 ) 
 CNSsolve>eval($db.DP_ILE_T = 0.54 ) 
 CNSsolve>eval($db.DP_LEU_A = 0.38 ) 
 CNSsolve>eval($db.DP_LEU_C = 0.38 ) 
 CNSsolve>eval($db.DP_LEU_G = 0.38 ) 
 CNSsolve>eval($db.DP_LEU_T = 0.38 ) 
 CNSsolve>eval($db.DP_LYS_A = 0.35 ) 
 CNSsolve>eval($db.DP_LYS_C = 0.35 ) 
 CNSsolve>eval($db.DP_LYS_G = 0.35 ) 
 CNSsolve>eval($db.DP_LYS_T = 0.35 ) 
 CNSsolve>eval($db.DP_MET_A = 0.50 ) 
 CNSsolve>eval($db.DP_MET_C = 0.50 ) 
 CNSsolve>eval($db.DP_MET_G = 0.50 ) 
 CNSsolve>eval($db.DP_MET_T = 0.50 ) 
 CNSsolve>eval($db.DP_PHE_A = 0.75 ) 
 CNSsolve>eval($db.DP_PHE_C = 0.75 ) 
 CNSsolve>eval($db.DP_PHE_G = 0.75 ) 
 CNSsolve>eval($db.DP_PHE_T = 0.75 ) 
 CNSsolve>eval($db.DP_PRO_A = 1.00 ) 
 CNSsolve>eval($db.DP_PRO_C = 1.00 ) 
 CNSsolve>eval($db.DP_PRO_G = 1.00 ) 
 CNSsolve>eval($db.DP_PRO_T = 1.00 ) 
 CNSsolve>eval($db.DP_SER_A = 0.38 ) 
 CNSsolve>eval($db.DP_SER_C = 0.38 ) 
 CNSsolve>eval($db.DP_SER_G = 0.38 ) 
 CNSsolve>eval($db.DP_SER_T = 0.38 ) 
 CNSsolve>eval($db.DP_THR_A = 0.40 ) 
 CNSsolve>eval($db.DP_THR_C = 0.40 ) 
 CNSsolve>eval($db.DP_THR_G = 0.40 ) 
 CNSsolve>eval($db.DP_THR_T = 0.40 ) 
 CNSsolve>eval($db.DP_TRP_A = 0.67 ) 
 CNSsolve>eval($db.DP_TRP_C = 0.67 ) 
 CNSsolve>eval($db.DP_TRP_G = 0.67 ) 
 CNSsolve>eval($db.DP_TRP_T = 0.67 ) 
 CNSsolve>eval($db.DP_TYR_A = 0.43 ) 
 CNSsolve>eval($db.DP_TYR_C = 0.43 ) 
 CNSsolve>eval($db.DP_TYR_G = 0.43 ) 
 CNSsolve>eval($db.DP_TYR_T = 0.43 ) 
 CNSsolve>eval($db.DP_VAL_A = 0.50 ) 
 CNSsolve>eval($db.DP_VAL_C = 0.50 ) 
 CNSsolve>eval($db.DP_VAL_G = 0.50 ) 
 CNSsolve>eval($db.DP_VAL_T = 0.50 ) 
 CNSsolve>eval($db.DP_A_ALA = 0.51 ) 
 CNSsolve>eval($db.DP_C_ALA = 0.51 ) 
 CNSsolve>eval($db.DP_G_ALA = 0.51 ) 
 CNSsolve>eval($db.DP_T_ALA = 0.51 ) 
 CNSsolve>eval($db.DP_A_ARG = 0.34 ) 
 CNSsolve>eval($db.DP_C_ARG = 0.34 ) 
 CNSsolve>eval($db.DP_G_ARG = 0.34 ) 
 CNSsolve>eval($db.DP_T_ARG = 0.34 ) 
 CNSsolve>eval($db.DP_A_ASN = 0.52 ) 
 CNSsolve>eval($db.DP_C_ASN = 0.52 ) 
 CNSsolve>eval($db.DP_G_ASN = 0.52 ) 
 CNSsolve>eval($db.DP_T_ASN = 0.52 ) 
 CNSsolve>eval($db.DP_A_ASP = 0.93 ) 
 CNSsolve>eval($db.DP_C_ASP = 0.93 ) 
 CNSsolve>eval($db.DP_G_ASP = 0.93 ) 
 CNSsolve>eval($db.DP_T_ASP = 0.93 ) 
 CNSsolve>eval($db.DP_A_CYS = 0.43 ) 
 CNSsolve>eval($db.DP_C_CYS = 0.43 ) 
 CNSsolve>eval($db.DP_G_CYS = 0.43 ) 
 CNSsolve>eval($db.DP_T_CYS = 0.43 ) 
 CNSsolve>eval($db.DP_A_GLN = 0.47 ) 
 CNSsolve>eval($db.DP_C_GLN = 0.47 ) 
 CNSsolve>eval($db.DP_G_GLN = 0.47 ) 
 CNSsolve>eval($db.DP_T_GLN = 0.47 ) 
 CNSsolve>eval($db.DP_A_GLU = 0.83 ) 
 CNSsolve>eval($db.DP_C_GLU = 0.83 ) 
 CNSsolve>eval($db.DP_G_GLU = 0.83 ) 
 CNSsolve>eval($db.DP_T_GLU = 0.83 ) 
 CNSsolve>eval($db.DP_A_GLY = 0.38 ) 
 CNSsolve>eval($db.DP_C_GLY = 0.38 ) 
 CNSsolve>eval($db.DP_G_GLY = 0.38 ) 
 CNSsolve>eval($db.DP_T_GLY = 0.38 ) 
 CNSsolve>eval($db.DP_A_HIS = 0.40 ) 
 CNSsolve>eval($db.DP_C_HIS = 0.40 ) 
 CNSsolve>eval($db.DP_G_HIS = 0.40 ) 
 CNSsolve>eval($db.DP_T_HIS = 0.40 ) 
 CNSsolve>eval($db.DP_A_ILE = 0.54 ) 
 CNSsolve>eval($db.DP_C_ILE = 0.54 ) 
 CNSsolve>eval($db.DP_G_ILE = 0.54 ) 
 CNSsolve>eval($db.DP_T_ILE = 0.54 ) 
 CNSsolve>eval($db.DP_A_LEU = 0.38 ) 
 CNSsolve>eval($db.DP_C_LEU = 0.38 ) 
 CNSsolve>eval($db.DP_G_LEU = 0.38 ) 
 CNSsolve>eval($db.DP_T_LEU = 0.38 ) 
 CNSsolve>eval($db.DP_A_LYS = 0.35 ) 
 CNSsolve>eval($db.DP_C_LYS = 0.35 ) 
 CNSsolve>eval($db.DP_G_LYS = 0.35 ) 
 CNSsolve>eval($db.DP_T_LYS = 0.35 ) 
 CNSsolve>eval($db.DP_A_MET = 0.50 ) 
 CNSsolve>eval($db.DP_C_MET = 0.50 ) 
 CNSsolve>eval($db.DP_G_MET = 0.50 ) 
 CNSsolve>eval($db.DP_T_MET = 0.50 ) 
 CNSsolve>eval($db.DP_A_PHE = 0.75 ) 
 CNSsolve>eval($db.DP_C_PHE = 0.75 ) 
 CNSsolve>eval($db.DP_G_PHE = 0.75 ) 
 CNSsolve>eval($db.DP_T_PHE = 0.75 ) 
 CNSsolve>eval($db.DP_A_PRO = 1.00 ) 
 CNSsolve>eval($db.DP_C_PRO = 1.00 ) 
 CNSsolve>eval($db.DP_G_PRO = 1.00 ) 
 CNSsolve>eval($db.DP_T_PRO = 1.00 ) 
 CNSsolve>eval($db.DP_A_SER = 0.38 ) 
 CNSsolve>eval($db.DP_C_SER = 0.38 ) 
 CNSsolve>eval($db.DP_G_SER = 0.38 ) 
 CNSsolve>eval($db.DP_T_SER = 0.38 ) 
 CNSsolve>eval($db.DP_A_THR = 0.40 ) 
 CNSsolve>eval($db.DP_C_THR = 0.40 ) 
 CNSsolve>eval($db.DP_G_THR = 0.40 ) 
 CNSsolve>eval($db.DP_T_THR = 0.40 ) 
 CNSsolve>eval($db.DP_A_TRP = 0.67 ) 
 CNSsolve>eval($db.DP_C_TRP = 0.67 ) 
 CNSsolve>eval($db.DP_G_TRP = 0.67 ) 
 CNSsolve>eval($db.DP_T_TRP = 0.67 ) 
 CNSsolve>eval($db.DP_A_TYR = 0.43 ) 
 CNSsolve>eval($db.DP_C_TYR = 0.43 ) 
 CNSsolve>eval($db.DP_G_TYR = 0.43 ) 
 CNSsolve>eval($db.DP_T_TYR = 0.43 ) 
 CNSsolve>eval($db.DP_A_VAL = 0.50 ) 
 CNSsolve>eval($db.DP_C_VAL = 0.50 ) 
 CNSsolve>eval($db.DP_G_VAL = 0.50 ) 
 CNSsolve>eval($db.DP_T_VAL = 0.50 ) 
 CNSsolve> 
 CNSsolve>eval($db.DP_ALA_DA = 0.51 ) 
 CNSsolve>eval($db.DP_ALA_DC = 0.51 ) 
 CNSsolve>eval($db.DP_ALA_DG = 0.51 ) 
 CNSsolve>eval($db.DP_ALA_DT = 0.51 ) 
 CNSsolve>eval($db.DP_ARG_DA = 0.34 ) 
 CNSsolve>eval($db.DP_ARG_DC = 0.34 ) 
 CNSsolve>eval($db.DP_ARG_DG = 0.34 ) 
 CNSsolve>eval($db.DP_ARG_DT = 0.34 ) 
 CNSsolve>eval($db.DP_ASN_DA = 0.52 ) 
 CNSsolve>eval($db.DP_ASN_DC = 0.52 ) 
 CNSsolve>eval($db.DP_ASN_DG = 0.52 ) 
 CNSsolve>eval($db.DP_ASN_DT = 0.52 ) 
 CNSsolve>eval($db.DP_ASP_DA = 0.93 ) 
 CNSsolve>eval($db.DP_ASP_DC = 0.93 ) 
 CNSsolve>eval($db.DP_ASP_DG = 0.93 ) 
 CNSsolve>eval($db.DP_ASP_DT = 0.93 ) 
 CNSsolve>eval($db.DP_CYS_DA = 0.43 ) 
 CNSsolve>eval($db.DP_CYS_DC = 0.43 ) 
 CNSsolve>eval($db.DP_CYS_DG = 0.43 ) 
 CNSsolve>eval($db.DP_CYS_DT = 0.43 ) 
 CNSsolve>eval($db.DP_GLN_DA = 0.47 ) 
 CNSsolve>eval($db.DP_GLN_DC = 0.47 ) 
 CNSsolve>eval($db.DP_GLN_DG = 0.47 ) 
 CNSsolve>eval($db.DP_GLN_DT = 0.47 ) 
 CNSsolve>eval($db.DP_GLU_DA = 0.83 ) 
 CNSsolve>eval($db.DP_GLU_DC = 0.83 ) 
 CNSsolve>eval($db.DP_GLU_DG = 0.83 ) 
 CNSsolve>eval($db.DP_GLU_DT = 0.83 ) 
 CNSsolve>eval($db.DP_GLY_DA = 0.38 ) 
 CNSsolve>eval($db.DP_GLY_DC = 0.38 ) 
 CNSsolve>eval($db.DP_GLY_DG = 0.38 ) 
 CNSsolve>eval($db.DP_GLY_DT = 0.38 ) 
 CNSsolve>eval($db.DP_HIS_DA = 0.40 ) 
 CNSsolve>eval($db.DP_HIS_DC = 0.40 ) 
 CNSsolve>eval($db.DP_HIS_DG = 0.40 ) 
 CNSsolve>eval($db.DP_HIS_DT = 0.40 ) 
 CNSsolve>eval($db.DP_ILE_DA = 0.54 ) 
 CNSsolve>eval($db.DP_ILE_DC = 0.54 ) 
 CNSsolve>eval($db.DP_ILE_DG = 0.54 ) 
 CNSsolve>eval($db.DP_ILE_DT = 0.54 ) 
 CNSsolve>eval($db.DP_LEU_DA = 0.38 ) 
 CNSsolve>eval($db.DP_LEU_DC = 0.38 ) 
 CNSsolve>eval($db.DP_LEU_DG = 0.38 ) 
 CNSsolve>eval($db.DP_LEU_DT = 0.38 ) 
 CNSsolve>eval($db.DP_LYS_DA = 0.35 ) 
 CNSsolve>eval($db.DP_LYS_DC = 0.35 ) 
 CNSsolve>eval($db.DP_LYS_DG = 0.35 ) 
 CNSsolve>eval($db.DP_LYS_DT = 0.35 ) 
 CNSsolve>eval($db.DP_MET_DA = 0.50 ) 
 CNSsolve>eval($db.DP_MET_DC = 0.50 ) 
 CNSsolve>eval($db.DP_MET_DG = 0.50 ) 
 CNSsolve>eval($db.DP_MET_DT = 0.50 ) 
 CNSsolve>eval($db.DP_PHE_DA = 0.75 ) 
 CNSsolve>eval($db.DP_PHE_DC = 0.75 ) 
 CNSsolve>eval($db.DP_PHE_DG = 0.75 ) 
 CNSsolve>eval($db.DP_PHE_DT = 0.75 ) 
 CNSsolve>eval($db.DP_PRO_DA = 1.00 ) 
 CNSsolve>eval($db.DP_PRO_DC = 1.00 ) 
 CNSsolve>eval($db.DP_PRO_DG = 1.00 ) 
 CNSsolve>eval($db.DP_PRO_DT = 1.00 ) 
 CNSsolve>eval($db.DP_SER_DA = 0.38 ) 
 CNSsolve>eval($db.DP_SER_DC = 0.38 ) 
 CNSsolve>eval($db.DP_SER_DG = 0.38 ) 
 CNSsolve>eval($db.DP_SER_DT = 0.38 ) 
 CNSsolve>eval($db.DP_THR_DA = 0.40 ) 
 CNSsolve>eval($db.DP_THR_DC = 0.40 ) 
 CNSsolve>eval($db.DP_THR_DG = 0.40 ) 
 CNSsolve>eval($db.DP_THR_DT = 0.40 ) 
 CNSsolve>eval($db.DP_TRP_DA = 0.67 ) 
 CNSsolve>eval($db.DP_TRP_DC = 0.67 ) 
 CNSsolve>eval($db.DP_TRP_DG = 0.67 ) 
 CNSsolve>eval($db.DP_TRP_DT = 0.67 ) 
 CNSsolve>eval($db.DP_TYR_DA = 0.43 ) 
 CNSsolve>eval($db.DP_TYR_DC = 0.43 ) 
 CNSsolve>eval($db.DP_TYR_DG = 0.43 ) 
 CNSsolve>eval($db.DP_TYR_DT = 0.43 ) 
 CNSsolve>eval($db.DP_VAL_DA = 0.50 ) 
 CNSsolve>eval($db.DP_VAL_DC = 0.50 ) 
 CNSsolve>eval($db.DP_VAL_DG = 0.50 ) 
 CNSsolve>eval($db.DP_VAL_DT = 0.50 ) 
 CNSsolve>eval($db.DP_DA_ALA = 0.51 ) 
 CNSsolve>eval($db.DP_DC_ALA = 0.51 ) 
 CNSsolve>eval($db.DP_DG_ALA = 0.51 ) 
 CNSsolve>eval($db.DP_DT_ALA = 0.51 ) 
 CNSsolve>eval($db.DP_DA_ARG = 0.34 ) 
 CNSsolve>eval($db.DP_DC_ARG = 0.34 ) 
 CNSsolve>eval($db.DP_DG_ARG = 0.34 ) 
 CNSsolve>eval($db.DP_DT_ARG = 0.34 ) 
 CNSsolve>eval($db.DP_DA_ASN = 0.52 ) 
 CNSsolve>eval($db.DP_DC_ASN = 0.52 ) 
 CNSsolve>eval($db.DP_DG_ASN = 0.52 ) 
 CNSsolve>eval($db.DP_DT_ASN = 0.52 ) 
 CNSsolve>eval($db.DP_DA_ASP = 0.93 ) 
 CNSsolve>eval($db.DP_DC_ASP = 0.93 ) 
 CNSsolve>eval($db.DP_DG_ASP = 0.93 ) 
 CNSsolve>eval($db.DP_DT_ASP = 0.93 ) 
 CNSsolve>eval($db.DP_DA_CYS = 0.43 ) 
 CNSsolve>eval($db.DP_DC_CYS = 0.43 ) 
 CNSsolve>eval($db.DP_DG_CYS = 0.43 ) 
 CNSsolve>eval($db.DP_DT_CYS = 0.43 ) 
 CNSsolve>eval($db.DP_DA_GLN = 0.47 ) 
 CNSsolve>eval($db.DP_DC_GLN = 0.47 ) 
 CNSsolve>eval($db.DP_DG_GLN = 0.47 ) 
 CNSsolve>eval($db.DP_DT_GLN = 0.47 ) 
 CNSsolve>eval($db.DP_DA_GLU = 0.83 ) 
 CNSsolve>eval($db.DP_DC_GLU = 0.83 ) 
 CNSsolve>eval($db.DP_DG_GLU = 0.83 ) 
 CNSsolve>eval($db.DP_DT_GLU = 0.83 ) 
 CNSsolve>eval($db.DP_DA_GLY = 0.38 ) 
 CNSsolve>eval($db.DP_DC_GLY = 0.38 ) 
 CNSsolve>eval($db.DP_DG_GLY = 0.38 ) 
 CNSsolve>eval($db.DP_DT_GLY = 0.38 ) 
 CNSsolve>eval($db.DP_DA_HIS = 0.40 ) 
 CNSsolve>eval($db.DP_DC_HIS = 0.40 ) 
 CNSsolve>eval($db.DP_DG_HIS = 0.40 ) 
 CNSsolve>eval($db.DP_DT_HIS = 0.40 ) 
 CNSsolve>eval($db.DP_DA_ILE = 0.54 ) 
 CNSsolve>eval($db.DP_DC_ILE = 0.54 ) 
 CNSsolve>eval($db.DP_DG_ILE = 0.54 ) 
 CNSsolve>eval($db.DP_DT_ILE = 0.54 ) 
 CNSsolve>eval($db.DP_DA_LEU = 0.38 ) 
 CNSsolve>eval($db.DP_DC_LEU = 0.38 ) 
 CNSsolve>eval($db.DP_DG_LEU = 0.38 ) 
 CNSsolve>eval($db.DP_DT_LEU = 0.38 ) 
 CNSsolve>eval($db.DP_DA_LYS = 0.35 ) 
 CNSsolve>eval($db.DP_DC_LYS = 0.35 ) 
 CNSsolve>eval($db.DP_DG_LYS = 0.35 ) 
 CNSsolve>eval($db.DP_DT_LYS = 0.35 ) 
 CNSsolve>eval($db.DP_DA_MET = 0.50 ) 
 CNSsolve>eval($db.DP_DC_MET = 0.50 ) 
 CNSsolve>eval($db.DP_DG_MET = 0.50 ) 
 CNSsolve>eval($db.DP_DT_MET = 0.50 ) 
 CNSsolve>eval($db.DP_DA_PHE = 0.75 ) 
 CNSsolve>eval($db.DP_DC_PHE = 0.75 ) 
 CNSsolve>eval($db.DP_DG_PHE = 0.75 ) 
 CNSsolve>eval($db.DP_DT_PHE = 0.75 ) 
 CNSsolve>eval($db.DP_DA_PRO = 1.00 ) 
 CNSsolve>eval($db.DP_DC_PRO = 1.00 ) 
 CNSsolve>eval($db.DP_DG_PRO = 1.00 ) 
 CNSsolve>eval($db.DP_DT_PRO = 1.00 ) 
 CNSsolve>eval($db.DP_DA_SER = 0.38 ) 
 CNSsolve>eval($db.DP_DC_SER = 0.38 ) 
 CNSsolve>eval($db.DP_DG_SER = 0.38 ) 
 CNSsolve>eval($db.DP_DT_SER = 0.38 ) 
 CNSsolve>eval($db.DP_DA_THR = 0.40 ) 
 CNSsolve>eval($db.DP_DC_THR = 0.40 ) 
 CNSsolve>eval($db.DP_DG_THR = 0.40 ) 
 CNSsolve>eval($db.DP_DT_THR = 0.40 ) 
 CNSsolve>eval($db.DP_DA_TRP = 0.67 ) 
 CNSsolve>eval($db.DP_DC_TRP = 0.67 ) 
 CNSsolve>eval($db.DP_DG_TRP = 0.67 ) 
 CNSsolve>eval($db.DP_DT_TRP = 0.67 ) 
 CNSsolve>eval($db.DP_DA_TYR = 0.43 ) 
 CNSsolve>eval($db.DP_DC_TYR = 0.43 ) 
 CNSsolve>eval($db.DP_DG_TYR = 0.43 ) 
 CNSsolve>eval($db.DP_DT_TYR = 0.43 ) 
 CNSsolve>eval($db.DP_DA_VAL = 0.50 ) 
 CNSsolve>eval($db.DP_DC_VAL = 0.50 ) 
 CNSsolve>eval($db.DP_DG_VAL = 0.50 ) 
 CNSsolve>eval($db.DP_DT_VAL = 0.50 ) 
 CNSsolve>else 
 CNSsolve>  inline @RUN:protocols/db_kyte-doolittle.dat 
 ASSFIL: file db_kyte-doolittle.dat opened.
 CNSsolve>! db_kyte-doolittle.dat 
 CNSsolve>!    Kyte-Doolittle derived probabilities of finding a water molecule 
 CNSsolve>!    between two specific amino acids 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>eval ($db.ALA_ALA = 0.1096) 
 CNSsolve>eval ($db.ALA_ARG = 0.3288) 
 CNSsolve>eval ($db.ALA_ASN = 0.3014) 
 CNSsolve>eval ($db.ALA_ASP = 0.3014) 
 CNSsolve>eval ($db.ALA_CYS = 0.0822) 
 CNSsolve>eval ($db.ALA_GLN = 0.3014) 
 CNSsolve>eval ($db.ALA_GLU = 0.3014) 
 CNSsolve>eval ($db.ALA_GLY = 0.1918) 
 CNSsolve>eval ($db.ALA_HIS = 0.2877) 
 CNSsolve>eval ($db.ALA_ILE = 0.0137) 
 CNSsolve>eval ($db.ALA_LEU = 0.0411) 
 CNSsolve>eval ($db.ALA_LYS = 0.3151) 
 CNSsolve>eval ($db.ALA_MET = 0.1096) 
 CNSsolve>eval ($db.ALA_PHE = 0.0822) 
 CNSsolve>eval ($db.ALA_PRO = 0.2329) 
 CNSsolve>eval ($db.ALA_SER = 0.2055) 
 CNSsolve>eval ($db.ALA_THR = 0.2055) 
 CNSsolve>eval ($db.ALA_TRP = 0.2055) 
 CNSsolve>eval ($db.ALA_TYR = 0.2192) 
 CNSsolve>eval ($db.ALA_VAL = 0.0274) 
 CNSsolve>eval ($db.ALA_NEP = 0.1918) 
 CNSsolve>eval ($db.ARG_ALA = 0.3288) 
 CNSsolve>eval ($db.ARG_ARG = 1.0001) 
 CNSsolve>eval ($db.ARG_ASN = 0.8905) 
 CNSsolve>eval ($db.ARG_ASP = 0.8905) 
 CNSsolve>eval ($db.ARG_CYS = 0.2603) 
 CNSsolve>eval ($db.ARG_GLN = 0.8905) 
 CNSsolve>eval ($db.ARG_GLU = 0.8905) 
 CNSsolve>eval ($db.ARG_GLY = 0.5617) 
 CNSsolve>eval ($db.ARG_HIS = 0.8631) 
 CNSsolve>eval ($db.ARG_ILE = 0.0548) 
 CNSsolve>eval ($db.ARG_LEU = 0.1233) 
 CNSsolve>eval ($db.ARG_LYS = 0.9316) 
 CNSsolve>eval ($db.ARG_MET = 0.3288) 
 CNSsolve>eval ($db.ARG_PHE = 0.2329) 
 CNSsolve>eval ($db.ARG_PRO = 0.685) 
 CNSsolve>eval ($db.ARG_SER = 0.6028) 
 CNSsolve>eval ($db.ARG_THR = 0.6028) 
 CNSsolve>eval ($db.ARG_TRP = 0.6165) 
 CNSsolve>eval ($db.ARG_TYR = 0.6576) 
 CNSsolve>eval ($db.ARG_VAL = 0.0822) 
 CNSsolve>eval ($db.ARG_NEP = 0.5754) 
 CNSsolve>eval ($db.ASN_ALA = 0.3014) 
 CNSsolve>eval ($db.ASN_ARG = 0.8905) 
 CNSsolve>eval ($db.ASN_ASN = 0.7946) 
 CNSsolve>eval ($db.ASN_ASP = 0.7946) 
 CNSsolve>eval ($db.ASN_CYS = 0.2329) 
 CNSsolve>eval ($db.ASN_GLN = 0.7946) 
 CNSsolve>eval ($db.ASN_GLU = 0.7946) 
 CNSsolve>eval ($db.ASN_GLY = 0.5069) 
 CNSsolve>eval ($db.ASN_HIS = 0.7672) 
 CNSsolve>eval ($db.ASN_ILE = 0.0411) 
 CNSsolve>eval ($db.ASN_LEU = 0.1096) 
 CNSsolve>eval ($db.ASN_LYS = 0.8357) 
 CNSsolve>eval ($db.ASN_MET = 0.2877) 
 CNSsolve>eval ($db.ASN_PHE = 0.2055) 
 CNSsolve>eval ($db.ASN_PRO = 0.6165) 
 CNSsolve>eval ($db.ASN_SER = 0.548) 
 CNSsolve>eval ($db.ASN_THR = 0.5343) 
 CNSsolve>eval ($db.ASN_TRP = 0.548) 
 CNSsolve>eval ($db.ASN_TYR = 0.5891) 
 CNSsolve>eval ($db.ASN_VAL = 0.0685) 
 CNSsolve>eval ($db.ASN_NEP = 0.5069) 
 CNSsolve>eval ($db.ASP_ALA = 0.3014) 
 CNSsolve>eval ($db.ASP_ARG = 0.8905) 
 CNSsolve>eval ($db.ASP_ASN = 0.7946) 
 CNSsolve>eval ($db.ASP_ASP = 0.7946) 
 CNSsolve>eval ($db.ASP_CYS = 0.2329) 
 CNSsolve>eval ($db.ASP_GLN = 0.7946) 
 CNSsolve>eval ($db.ASP_GLU = 0.7946) 
 CNSsolve>eval ($db.ASP_GLY = 0.5069) 
 CNSsolve>eval ($db.ASP_HIS = 0.7672) 
 CNSsolve>eval ($db.ASP_ILE = 0.0411) 
 CNSsolve>eval ($db.ASP_LEU = 0.1096) 
 CNSsolve>eval ($db.ASP_LYS = 0.8357) 
 CNSsolve>eval ($db.ASP_MET = 0.2877) 
 CNSsolve>eval ($db.ASP_PHE = 0.2055) 
 CNSsolve>eval ($db.ASP_PRO = 0.6165) 
 CNSsolve>eval ($db.ASP_SER = 0.548) 
 CNSsolve>eval ($db.ASP_THR = 0.5343) 
 CNSsolve>eval ($db.ASP_TRP = 0.548) 
 CNSsolve>eval ($db.ASP_TYR = 0.5891) 
 CNSsolve>eval ($db.ASP_VAL = 0.0685) 
 CNSsolve>eval ($db.ASP_NEP = 0.5069) 
 CNSsolve>eval ($db.CYS_ALA = 0.0822) 
 CNSsolve>eval ($db.CYS_ARG = 0.2603) 
 CNSsolve>eval ($db.CYS_ASN = 0.2329) 
 CNSsolve>eval ($db.CYS_ASP = 0.2329) 
 CNSsolve>eval ($db.CYS_CYS = 0.0685) 
 CNSsolve>eval ($db.CYS_GLN = 0.2329) 
 CNSsolve>eval ($db.CYS_GLU = 0.2329) 
 CNSsolve>eval ($db.CYS_GLY = 0.1507) 
 CNSsolve>eval ($db.CYS_HIS = 0.2192) 
 CNSsolve>eval ($db.CYS_ILE = 0.0137) 
 CNSsolve>eval ($db.CYS_LEU = 0.0274) 
 CNSsolve>eval ($db.CYS_LYS = 0.2466) 
 CNSsolve>eval ($db.CYS_MET = 0.0822) 
 CNSsolve>eval ($db.CYS_PHE = 0.0548) 
 CNSsolve>eval ($db.CYS_PRO = 0.1781) 
 CNSsolve>eval ($db.CYS_SER = 0.1644) 
 CNSsolve>eval ($db.CYS_THR = 0.1507) 
 CNSsolve>eval ($db.CYS_TRP = 0.1644) 
 CNSsolve>eval ($db.CYS_TYR = 0.1781) 
 CNSsolve>eval ($db.CYS_VAL = 0.0274) 
 CNSsolve>eval ($db.CYS_NEP = 0.1507) 
 CNSsolve>eval ($db.GLN_ALA = 0.3014) 
 CNSsolve>eval ($db.GLN_ARG = 0.8905) 
 CNSsolve>eval ($db.GLN_ASN = 0.7946) 
 CNSsolve>eval ($db.GLN_ASP = 0.7946) 
 CNSsolve>eval ($db.GLN_CYS = 0.2329) 
 CNSsolve>eval ($db.GLN_GLN = 0.7946) 
 CNSsolve>eval ($db.GLN_GLU = 0.7946) 
 CNSsolve>eval ($db.GLN_GLY = 0.5069) 
 CNSsolve>eval ($db.GLN_HIS = 0.7672) 
 CNSsolve>eval ($db.GLN_ILE = 0.0411) 
 CNSsolve>eval ($db.GLN_LEU = 0.1096) 
 CNSsolve>eval ($db.GLN_LYS = 0.8357) 
 CNSsolve>eval ($db.GLN_MET = 0.2877) 
 CNSsolve>eval ($db.GLN_PHE = 0.2055) 
 CNSsolve>eval ($db.GLN_PRO = 0.6165) 
 CNSsolve>eval ($db.GLN_SER = 0.548) 
 CNSsolve>eval ($db.GLN_THR = 0.5343) 
 CNSsolve>eval ($db.GLN_TRP = 0.548) 
 CNSsolve>eval ($db.GLN_TYR = 0.5891) 
 CNSsolve>eval ($db.GLN_VAL = 0.0685) 
 CNSsolve>eval ($db.GLN_NEP = 0.5069) 
 CNSsolve>eval ($db.GLU_ALA = 0.3014) 
 CNSsolve>eval ($db.GLU_ARG = 0.8905) 
 CNSsolve>eval ($db.GLU_ASN = 0.7946) 
 CNSsolve>eval ($db.GLU_ASP = 0.7946) 
 CNSsolve>eval ($db.GLU_CYS = 0.2329) 
 CNSsolve>eval ($db.GLU_GLN = 0.7946) 
 CNSsolve>eval ($db.GLU_GLU = 0.7946) 
 CNSsolve>eval ($db.GLU_GLY = 0.5069) 
 CNSsolve>eval ($db.GLU_HIS = 0.7672) 
 CNSsolve>eval ($db.GLU_ILE = 0.0411) 
 CNSsolve>eval ($db.GLU_LEU = 0.1096) 
 CNSsolve>eval ($db.GLU_LYS = 0.8357) 
 CNSsolve>eval ($db.GLU_MET = 0.2877) 
 CNSsolve>eval ($db.GLU_PHE = 0.2055) 
 CNSsolve>eval ($db.GLU_PRO = 0.6165) 
 CNSsolve>eval ($db.GLU_SER = 0.548) 
 CNSsolve>eval ($db.GLU_THR = 0.5343) 
 CNSsolve>eval ($db.GLU_TRP = 0.548) 
 CNSsolve>eval ($db.GLU_TYR = 0.5891) 
 CNSsolve>eval ($db.GLU_VAL = 0.0685) 
 CNSsolve>eval ($db.GLU_NEP = 0.5069) 
 CNSsolve>eval ($db.GLY_ALA = 0.1918) 
 CNSsolve>eval ($db.GLY_ARG = 0.5617) 
 CNSsolve>eval ($db.GLY_ASN = 0.5069) 
 CNSsolve>eval ($db.GLY_ASP = 0.5069) 
 CNSsolve>eval ($db.GLY_CYS = 0.1507) 
 CNSsolve>eval ($db.GLY_GLN = 0.5069) 
 CNSsolve>eval ($db.GLY_GLU = 0.5069) 
 CNSsolve>eval ($db.GLY_GLY = 0.3151) 
 CNSsolve>eval ($db.GLY_HIS = 0.4932) 
 CNSsolve>eval ($db.GLY_ILE = 0.0274) 
 CNSsolve>eval ($db.GLY_LEU = 0.0685) 
 CNSsolve>eval ($db.GLY_LYS = 0.5343) 
 CNSsolve>eval ($db.GLY_MET = 0.1781) 
 CNSsolve>eval ($db.GLY_PHE = 0.137) 
 CNSsolve>eval ($db.GLY_PRO = 0.3973) 
 CNSsolve>eval ($db.GLY_SER = 0.3425) 
 CNSsolve>eval ($db.GLY_THR = 0.3425) 
 CNSsolve>eval ($db.GLY_TRP = 0.3562) 
 CNSsolve>eval ($db.GLY_TYR = 0.3699) 
 CNSsolve>eval ($db.GLY_VAL = 0.0411) 
 CNSsolve>eval ($db.GLY_NEP = 0.3288) 
 CNSsolve>eval ($db.HIS_ALA = 0.2877) 
 CNSsolve>eval ($db.HIS_ARG = 0.8631) 
 CNSsolve>eval ($db.HIS_ASN = 0.7672) 
 CNSsolve>eval ($db.HIS_ASP = 0.7672) 
 CNSsolve>eval ($db.HIS_CYS = 0.2192) 
 CNSsolve>eval ($db.HIS_GLN = 0.7672) 
 CNSsolve>eval ($db.HIS_GLU = 0.7672) 
 CNSsolve>eval ($db.HIS_GLY = 0.4932) 
 CNSsolve>eval ($db.HIS_HIS = 0.7398) 
 CNSsolve>eval ($db.HIS_ILE = 0.0411) 
 CNSsolve>eval ($db.HIS_LEU = 0.1096) 
 CNSsolve>eval ($db.HIS_LYS = 0.8083) 
 CNSsolve>eval ($db.HIS_MET = 0.274) 
 CNSsolve>eval ($db.HIS_PHE = 0.2055) 
 CNSsolve>eval ($db.HIS_PRO = 0.6028) 
 CNSsolve>eval ($db.HIS_SER = 0.5206) 
 CNSsolve>eval ($db.HIS_THR = 0.5206) 
 CNSsolve>eval ($db.HIS_TRP = 0.5343) 
 CNSsolve>eval ($db.HIS_TYR = 0.5754) 
 CNSsolve>eval ($db.HIS_VAL = 0.0685) 
 CNSsolve>eval ($db.HIS_NEP = 0.4932) 
 CNSsolve>eval ($db.ILE_ALA = 0.0137) 
 CNSsolve>eval ($db.ILE_ARG = 0.0548) 
 CNSsolve>eval ($db.ILE_ASN = 0.0411) 
 CNSsolve>eval ($db.ILE_ASP = 0.0411) 
 CNSsolve>eval ($db.ILE_CYS = 0.0137) 
 CNSsolve>eval ($db.ILE_GLN = 0.0411) 
 CNSsolve>eval ($db.ILE_GLU = 0.0411) 
 CNSsolve>eval ($db.ILE_GLY = 0.0274) 
 CNSsolve>eval ($db.ILE_HIS = 0.0411) 
 CNSsolve>eval ($db.ILE_ILE = 0) 
 CNSsolve>eval ($db.ILE_LEU = 0) 
 CNSsolve>eval ($db.ILE_LYS = 0.0548) 
 CNSsolve>eval ($db.ILE_MET = 0.0137) 
 CNSsolve>eval ($db.ILE_PHE = 0.0137) 
 CNSsolve>eval ($db.ILE_PRO = 0.0411) 
 CNSsolve>eval ($db.ILE_SER = 0.0274) 
 CNSsolve>eval ($db.ILE_THR = 0.0274) 
 CNSsolve>eval ($db.ILE_TRP = 0.0274) 
 CNSsolve>eval ($db.ILE_TYR = 0.0411) 
 CNSsolve>eval ($db.ILE_VAL = 0) 
 CNSsolve>eval ($db.ILE_NEP = 0.0274) 
 CNSsolve>eval ($db.LEU_ALA = 0.0411) 
 CNSsolve>eval ($db.LEU_ARG = 0.1233) 
 CNSsolve>eval ($db.LEU_ASN = 0.1096) 
 CNSsolve>eval ($db.LEU_ASP = 0.1096) 
 CNSsolve>eval ($db.LEU_CYS = 0.0274) 
 CNSsolve>eval ($db.LEU_GLN = 0.1096) 
 CNSsolve>eval ($db.LEU_GLU = 0.1096) 
 CNSsolve>eval ($db.LEU_GLY = 0.0685) 
 CNSsolve>eval ($db.LEU_HIS = 0.1096) 
 CNSsolve>eval ($db.LEU_ILE = 0) 
 CNSsolve>eval ($db.LEU_LEU = 0.0137) 
 CNSsolve>eval ($db.LEU_LYS = 0.1233) 
 CNSsolve>eval ($db.LEU_MET = 0.0411) 
 CNSsolve>eval ($db.LEU_PHE = 0.0274) 
 CNSsolve>eval ($db.LEU_PRO = 0.0822) 
 CNSsolve>eval ($db.LEU_SER = 0.0822) 
 CNSsolve>eval ($db.LEU_THR = 0.0822) 
 CNSsolve>eval ($db.LEU_TRP = 0.0822) 
 CNSsolve>eval ($db.LEU_TYR = 0.0822) 
 CNSsolve>eval ($db.LEU_VAL = 0.0137) 
 CNSsolve>eval ($db.LEU_NEP = 0.0685) 
 CNSsolve>eval ($db.LYS_ALA = 0.3151) 
 CNSsolve>eval ($db.LYS_ARG = 0.9316) 
 CNSsolve>eval ($db.LYS_ASN = 0.8357) 
 CNSsolve>eval ($db.LYS_ASP = 0.8357) 
 CNSsolve>eval ($db.LYS_CYS = 0.2466) 
 CNSsolve>eval ($db.LYS_GLN = 0.8357) 
 CNSsolve>eval ($db.LYS_GLU = 0.8357) 
 CNSsolve>eval ($db.LYS_GLY = 0.5343) 
 CNSsolve>eval ($db.LYS_HIS = 0.8083) 
 CNSsolve>eval ($db.LYS_ILE = 0.0548) 
 CNSsolve>eval ($db.LYS_LEU = 0.1233) 
 CNSsolve>eval ($db.LYS_LYS = 0.8768) 
 CNSsolve>eval ($db.LYS_MET = 0.3014) 
 CNSsolve>eval ($db.LYS_PHE = 0.2192) 
 CNSsolve>eval ($db.LYS_PRO = 0.6439) 
 CNSsolve>eval ($db.LYS_SER = 0.5754) 
 CNSsolve>eval ($db.LYS_THR = 0.5617) 
 CNSsolve>eval ($db.LYS_TRP = 0.5754) 
 CNSsolve>eval ($db.LYS_TYR = 0.6165) 
 CNSsolve>eval ($db.LYS_VAL = 0.0822) 
 CNSsolve>eval ($db.LYS_NEP = 0.5343) 
 CNSsolve>eval ($db.MET_ALA = 0.1096) 
 CNSsolve>eval ($db.MET_ARG = 0.3288) 
 CNSsolve>eval ($db.MET_ASN = 0.2877) 
 CNSsolve>eval ($db.MET_ASP = 0.2877) 
 CNSsolve>eval ($db.MET_CYS = 0.0822) 
 CNSsolve>eval ($db.MET_GLN = 0.2877) 
 CNSsolve>eval ($db.MET_GLU = 0.2877) 
 CNSsolve>eval ($db.MET_GLY = 0.1781) 
 CNSsolve>eval ($db.MET_HIS = 0.274) 
 CNSsolve>eval ($db.MET_ILE = 0.0137) 
 CNSsolve>eval ($db.MET_LEU = 0.0411) 
 CNSsolve>eval ($db.MET_LYS = 0.3014) 
 CNSsolve>eval ($db.MET_MET = 0.1096) 
 CNSsolve>eval ($db.MET_PHE = 0.0685) 
 CNSsolve>eval ($db.MET_PRO = 0.2192) 
 CNSsolve>eval ($db.MET_SER = 0.1918) 
 CNSsolve>eval ($db.MET_THR = 0.1918) 
 CNSsolve>eval ($db.MET_TRP = 0.2055) 
 CNSsolve>eval ($db.MET_TYR = 0.2192) 
 CNSsolve>eval ($db.MET_VAL = 0.0274) 
 CNSsolve>eval ($db.MET_NEP = 0.1918) 
 CNSsolve>eval ($db.PHE_ALA = 0.0822) 
 CNSsolve>eval ($db.PHE_ARG = 0.2329) 
 CNSsolve>eval ($db.PHE_ASN = 0.2055) 
 CNSsolve>eval ($db.PHE_ASP = 0.2055) 
 CNSsolve>eval ($db.PHE_CYS = 0.0548) 
 CNSsolve>eval ($db.PHE_GLN = 0.2055) 
 CNSsolve>eval ($db.PHE_GLU = 0.2055) 
 CNSsolve>eval ($db.PHE_GLY = 0.137) 
 CNSsolve>eval ($db.PHE_HIS = 0.2055) 
 CNSsolve>eval ($db.PHE_ILE = 0.0137) 
 CNSsolve>eval ($db.PHE_LEU = 0.0274) 
 CNSsolve>eval ($db.PHE_LYS = 0.2192) 
 CNSsolve>eval ($db.PHE_MET = 0.0685) 
 CNSsolve>eval ($db.PHE_PHE = 0.0548) 
 CNSsolve>eval ($db.PHE_PRO = 0.1644) 
 CNSsolve>eval ($db.PHE_SER = 0.137) 
 CNSsolve>eval ($db.PHE_THR = 0.137) 
 CNSsolve>eval ($db.PHE_TRP = 0.137) 
 CNSsolve>eval ($db.PHE_TYR = 0.1507) 
 CNSsolve>eval ($db.PHE_VAL = 0.0137) 
 CNSsolve>eval ($db.PHE_NEP = 0.137) 
 CNSsolve>eval ($db.PRO_ALA = 0.2329) 
 CNSsolve>eval ($db.PRO_ARG = 0.685) 
 CNSsolve>eval ($db.PRO_ASN = 0.6165) 
 CNSsolve>eval ($db.PRO_ASP = 0.6165) 
 CNSsolve>eval ($db.PRO_CYS = 0.1781) 
 CNSsolve>eval ($db.PRO_GLN = 0.6165) 
 CNSsolve>eval ($db.PRO_GLU = 0.6165) 
 CNSsolve>eval ($db.PRO_GLY = 0.3973) 
 CNSsolve>eval ($db.PRO_HIS = 0.6028) 
 CNSsolve>eval ($db.PRO_ILE = 0.0411) 
 CNSsolve>eval ($db.PRO_LEU = 0.0822) 
 CNSsolve>eval ($db.PRO_LYS = 0.6439) 
 CNSsolve>eval ($db.PRO_MET = 0.2192) 
 CNSsolve>eval ($db.PRO_PHE = 0.1644) 
 CNSsolve>eval ($db.PRO_PRO = 0.4795) 
 CNSsolve>eval ($db.PRO_SER = 0.4247) 
 CNSsolve>eval ($db.PRO_THR = 0.411) 
 CNSsolve>eval ($db.PRO_TRP = 0.4247) 
 CNSsolve>eval ($db.PRO_TYR = 0.4521) 
 CNSsolve>eval ($db.PRO_VAL = 0.0548) 
 CNSsolve>eval ($db.PRO_NEP = 0.3973) 
 CNSsolve>eval ($db.SER_ALA = 0.2055) 
 CNSsolve>eval ($db.SER_ARG = 0.6028) 
 CNSsolve>eval ($db.SER_ASN = 0.548) 
 CNSsolve>eval ($db.SER_ASP = 0.548) 
 CNSsolve>eval ($db.SER_CYS = 0.1644) 
 CNSsolve>eval ($db.SER_GLN = 0.548) 
 CNSsolve>eval ($db.SER_GLU = 0.548) 
 CNSsolve>eval ($db.SER_GLY = 0.3425) 
 CNSsolve>eval ($db.SER_HIS = 0.5206) 
 CNSsolve>eval ($db.SER_ILE = 0.0274) 
 CNSsolve>eval ($db.SER_LEU = 0.0822) 
 CNSsolve>eval ($db.SER_LYS = 0.5754) 
 CNSsolve>eval ($db.SER_MET = 0.1918) 
 CNSsolve>eval ($db.SER_PHE = 0.137) 
 CNSsolve>eval ($db.SER_PRO = 0.4247) 
 CNSsolve>eval ($db.SER_SER = 0.3699) 
 CNSsolve>eval ($db.SER_THR = 0.3699) 
 CNSsolve>eval ($db.SER_TRP = 0.3836) 
 CNSsolve>eval ($db.SER_TYR = 0.3973) 
 CNSsolve>eval ($db.SER_VAL = 0.0548) 
 CNSsolve>eval ($db.SER_NEP = 0.3562) 
 CNSsolve>eval ($db.THR_ALA = 0.2055) 
 CNSsolve>eval ($db.THR_ARG = 0.6028) 
 CNSsolve>eval ($db.THR_ASN = 0.5343) 
 CNSsolve>eval ($db.THR_ASP = 0.5343) 
 CNSsolve>eval ($db.THR_CYS = 0.1507) 
 CNSsolve>eval ($db.THR_GLN = 0.5343) 
 CNSsolve>eval ($db.THR_GLU = 0.5343) 
 CNSsolve>eval ($db.THR_GLY = 0.3425) 
 CNSsolve>eval ($db.THR_HIS = 0.5206) 
 CNSsolve>eval ($db.THR_ILE = 0.0274) 
 CNSsolve>eval ($db.THR_LEU = 0.0822) 
 CNSsolve>eval ($db.THR_LYS = 0.5617) 
 CNSsolve>eval ($db.THR_MET = 0.1918) 
 CNSsolve>eval ($db.THR_PHE = 0.137) 
 CNSsolve>eval ($db.THR_PRO = 0.411) 
 CNSsolve>eval ($db.THR_SER = 0.3699) 
 CNSsolve>eval ($db.THR_THR = 0.3562) 
 CNSsolve>eval ($db.THR_TRP = 0.3699) 
 CNSsolve>eval ($db.THR_TYR = 0.3973) 
 CNSsolve>eval ($db.THR_VAL = 0.0548) 
 CNSsolve>eval ($db.THR_NEP = 0.3425) 
 CNSsolve>eval ($db.TRP_ALA = 0.2055) 
 CNSsolve>eval ($db.TRP_ARG = 0.6165) 
 CNSsolve>eval ($db.TRP_ASN = 0.548) 
 CNSsolve>eval ($db.TRP_ASP = 0.548) 
 CNSsolve>eval ($db.TRP_CYS = 0.1644) 
 CNSsolve>eval ($db.TRP_GLN = 0.548) 
 CNSsolve>eval ($db.TRP_GLU = 0.548) 
 CNSsolve>eval ($db.TRP_GLY = 0.3562) 
 CNSsolve>eval ($db.TRP_HIS = 0.5343) 
 CNSsolve>eval ($db.TRP_ILE = 0.0274) 
 CNSsolve>eval ($db.TRP_LEU = 0.0822) 
 CNSsolve>eval ($db.TRP_LYS = 0.5754) 
 CNSsolve>eval ($db.TRP_MET = 0.2055) 
 CNSsolve>eval ($db.TRP_PHE = 0.137) 
 CNSsolve>eval ($db.TRP_PRO = 0.4247) 
 CNSsolve>eval ($db.TRP_SER = 0.3836) 
 CNSsolve>eval ($db.TRP_THR = 0.3699) 
 CNSsolve>eval ($db.TRP_TRP = 0.3836) 
 CNSsolve>eval ($db.TRP_TYR = 0.411) 
 CNSsolve>eval ($db.TRP_VAL = 0.0548) 
 CNSsolve>eval ($db.TRP_NEP = 0.3562) 
 CNSsolve>eval ($db.TYR_ALA = 0.2192) 
 CNSsolve>eval ($db.TYR_ARG = 0.6576) 
 CNSsolve>eval ($db.TYR_ASN = 0.5891) 
 CNSsolve>eval ($db.TYR_ASP = 0.5891) 
 CNSsolve>eval ($db.TYR_CYS = 0.1781) 
 CNSsolve>eval ($db.TYR_GLN = 0.5891) 
 CNSsolve>eval ($db.TYR_GLU = 0.5891) 
 CNSsolve>eval ($db.TYR_GLY = 0.3699) 
 CNSsolve>eval ($db.TYR_HIS = 0.5754) 
 CNSsolve>eval ($db.TYR_ILE = 0.0411) 
 CNSsolve>eval ($db.TYR_LEU = 0.0822) 
 CNSsolve>eval ($db.TYR_LYS = 0.6165) 
 CNSsolve>eval ($db.TYR_MET = 0.2192) 
 CNSsolve>eval ($db.TYR_PHE = 0.1507) 
 CNSsolve>eval ($db.TYR_PRO = 0.4521) 
 CNSsolve>eval ($db.TYR_SER = 0.3973) 
 CNSsolve>eval ($db.TYR_THR = 0.3973) 
 CNSsolve>eval ($db.TYR_TRP = 0.411) 
 CNSsolve>eval ($db.TYR_TYR = 0.4384) 
 CNSsolve>eval ($db.TYR_VAL = 0.0548) 
 CNSsolve>eval ($db.TYR_NEP = 0.3836) 
 CNSsolve>eval ($db.VAL_ALA = 0.0274) 
 CNSsolve>eval ($db.VAL_ARG = 0.0822) 
 CNSsolve>eval ($db.VAL_ASN = 0.0685) 
 CNSsolve>eval ($db.VAL_ASP = 0.0685) 
 CNSsolve>eval ($db.VAL_CYS = 0.0274) 
 CNSsolve>eval ($db.VAL_GLN = 0.0685) 
 CNSsolve>eval ($db.VAL_GLU = 0.0685) 
 CNSsolve>eval ($db.VAL_GLY = 0.0411) 
 CNSsolve>eval ($db.VAL_HIS = 0.0685) 
 CNSsolve>eval ($db.VAL_ILE = 0) 
 CNSsolve>eval ($db.VAL_LEU = 0.0137) 
 CNSsolve>eval ($db.VAL_LYS = 0.0822) 
 CNSsolve>eval ($db.VAL_MET = 0.0274) 
 CNSsolve>eval ($db.VAL_PHE = 0.0137) 
 CNSsolve>eval ($db.VAL_PRO = 0.0548) 
 CNSsolve>eval ($db.VAL_SER = 0.0548) 
 CNSsolve>eval ($db.VAL_THR = 0.0548) 
 CNSsolve>eval ($db.VAL_TRP = 0.0548) 
 CNSsolve>eval ($db.VAL_TYR = 0.0548) 
 CNSsolve>eval ($db.VAL_VAL = 0.0137) 
 CNSsolve>eval ($db.VAL_NEP = 0.0411) 
 CNSsolve>eval ($db.NEP_ALA = 0.1918) 
 CNSsolve>eval ($db.NEP_ARG = 0.5754) 
 CNSsolve>eval ($db.NEP_ASN = 0.5069) 
 CNSsolve>eval ($db.NEP_ASP = 0.5069) 
 CNSsolve>eval ($db.NEP_CYS = 0.1507) 
 CNSsolve>eval ($db.NEP_GLN = 0.5069) 
 CNSsolve>eval ($db.NEP_GLU = 0.5069) 
 CNSsolve>eval ($db.NEP_GLY = 0.3288) 
 CNSsolve>eval ($db.NEP_HIS = 0.4932) 
 CNSsolve>eval ($db.NEP_ILE = 0.0274) 
 CNSsolve>eval ($db.NEP_LEU = 0.0685) 
 CNSsolve>eval ($db.NEP_LYS = 0.5343) 
 CNSsolve>eval ($db.NEP_MET = 0.1918) 
 CNSsolve>eval ($db.NEP_PHE = 0.137) 
 CNSsolve>eval ($db.NEP_PRO = 0.3973) 
 CNSsolve>eval ($db.NEP_SER = 0.3562) 
 CNSsolve>eval ($db.NEP_THR = 0.3425) 
 CNSsolve>eval ($db.NEP_TRP = 0.3562) 
 CNSsolve>eval ($db.NEP_TYR = 0.3836) 
 CNSsolve>eval ($db.NEP_VAL = 0.0411) 
 CNSsolve>eval ($db.NEP_NEP = 0.3288) 
 CNSsolve> 
 CNSsolve>eval ($db.ALA_DA = 0.00 ) 
 CNSsolve>eval ($db.ALA_DC = 0.00 ) 
 CNSsolve>eval ($db.ALA_DG = 0.00 ) 
 CNSsolve>eval ($db.ALA_DT = 0.00 ) 
 CNSsolve>eval ($db.ARG_DA = 0.14 ) 
 CNSsolve>eval ($db.ARG_DC = 0.07 ) 
 CNSsolve>eval ($db.ARG_DG = 0.14 ) 
 CNSsolve>eval ($db.ARG_DT = 0.08 ) 
 CNSsolve>eval ($db.ASN_DA = 0.19 ) 
 CNSsolve>eval ($db.ASN_DC = 0.09 ) 
 CNSsolve>eval ($db.ASN_DG = 0.22 ) 
 CNSsolve>eval ($db.ASN_DT = 0.10 ) 
 CNSsolve>eval ($db.ASP_DA = 0.44 ) 
 CNSsolve>eval ($db.ASP_DC = 0.16 ) 
 CNSsolve>eval ($db.ASP_DG = 0.10 ) 
 CNSsolve>eval ($db.ASP_DT = 0.05 ) 
 CNSsolve>eval ($db.CYS_DA = 0.00 ) 
 CNSsolve>eval ($db.CYS_DC = 0.00 ) 
 CNSsolve>eval ($db.CYS_DG = 0.00 ) 
 CNSsolve>eval ($db.CYS_DT = 0.00 ) 
 CNSsolve>eval ($db.GLN_DA = 0.15 ) 
 CNSsolve>eval ($db.GLN_DC = 0.19 ) 
 CNSsolve>eval ($db.GLN_DG = 0.15 ) 
 CNSsolve>eval ($db.GLN_DT = 0.13 ) 
 CNSsolve>eval ($db.GLU_DA = 0.11 ) 
 CNSsolve>eval ($db.GLU_DC = 0.15 ) 
 CNSsolve>eval ($db.GLU_DG = 0.13 ) 
 CNSsolve>eval ($db.GLU_DT = 0.00 ) 
 CNSsolve>eval ($db.GLY_DA = 0.00 ) 
 CNSsolve>eval ($db.GLY_DC = 0.00 ) 
 CNSsolve>eval ($db.GLY_DG = 0.00 ) 
 CNSsolve>eval ($db.GLY_DT = 0.00 ) 
 CNSsolve>eval ($db.HIS_DA = 0.10 ) 
 CNSsolve>eval ($db.HIS_DC = 0.14 ) 
 CNSsolve>eval ($db.HIS_DG = 0.18 ) 
 CNSsolve>eval ($db.HIS_DT = 0.06 ) 
 CNSsolve>eval ($db.ILE_DA = 0.00 ) 
 CNSsolve>eval ($db.ILE_DC = 0.00 ) 
 CNSsolve>eval ($db.ILE_DG = 0.00 ) 
 CNSsolve>eval ($db.ILE_DT = 0.00 ) 
 CNSsolve>eval ($db.LEU_DA = 0.00 ) 
 CNSsolve>eval ($db.LEU_DC = 0.00 ) 
 CNSsolve>eval ($db.LEU_DG = 0.00 ) 
 CNSsolve>eval ($db.LEU_DT = 0.00 ) 
 CNSsolve>eval ($db.LYS_DA = 0.31 ) 
 CNSsolve>eval ($db.LYS_DC = 0.15 ) 
 CNSsolve>eval ($db.LYS_DG = 0.29 ) 
 CNSsolve>eval ($db.LYS_DT = 0.18 ) 
 CNSsolve>eval ($db.MET_DA = 0.00 ) 
 CNSsolve>eval ($db.MET_DC = 0.00 ) 
 CNSsolve>eval ($db.MET_DG = 0.00 ) 
 CNSsolve>eval ($db.MET_DT = 0.00 ) 
 CNSsolve>eval ($db.PHE_DA = 0.00 ) 
 CNSsolve>eval ($db.PHE_DC = 0.00 ) 
 CNSsolve>eval ($db.PHE_DG = 0.00 ) 
 CNSsolve>eval ($db.PHE_DT = 0.00 ) 
 CNSsolve>eval ($db.PRO_DA = 0.00 ) 
 CNSsolve>eval ($db.PRO_DC = 0.00 ) 
 CNSsolve>eval ($db.PRO_DG = 0.00 ) 
 CNSsolve>eval ($db.PRO_DT = 0.00 ) 
 CNSsolve>eval ($db.SER_DA = 0.30 ) 
 CNSsolve>eval ($db.SER_DC = 0.03 ) 
 CNSsolve>eval ($db.SER_DG = 0.09 ) 
 CNSsolve>eval ($db.SER_DT = 0.03 ) 
 CNSsolve>eval ($db.THR_DA = 0.16 ) 
 CNSsolve>eval ($db.THR_DC = 0.16 ) 
 CNSsolve>eval ($db.THR_DG = 0.03 ) 
 CNSsolve>eval ($db.THR_DT = 0.05 ) 
 CNSsolve>eval ($db.TRP_DA = 0.00 ) 
 CNSsolve>eval ($db.TRP_DC = 0.00 ) 
 CNSsolve>eval ($db.TRP_DG = 0.00 ) 
 CNSsolve>eval ($db.TRP_DT = 0.00 ) 
 CNSsolve>eval ($db.TYR_DA = 0.13 ) 
 CNSsolve>eval ($db.TYR_DC = 0.10 ) 
 CNSsolve>eval ($db.TYR_DG = 0.10 ) 
 CNSsolve>eval ($db.TYR_DT = 0.02 ) 
 CNSsolve>eval ($db.VAL_DA = 0.00 ) 
 CNSsolve>eval ($db.VAL_DC = 0.00 ) 
 CNSsolve>eval ($db.VAL_DG = 0.00 ) 
 CNSsolve>eval ($db.VAL_DT = 0.00 ) 
 CNSsolve>eval ($db.DA_ALA = 0.00 ) 
 CNSsolve>eval ($db.DC_ALA = 0.00 ) 
 CNSsolve>eval ($db.DG_ALA = 0.00 ) 
 CNSsolve>eval ($db.DT_ALA = 0.00 ) 
 CNSsolve>eval ($db.DA_ARG = 0.14 ) 
 CNSsolve>eval ($db.DC_ARG = 0.07 ) 
 CNSsolve>eval ($db.DG_ARG = 0.14 ) 
 CNSsolve>eval ($db.DT_ARG = 0.08 ) 
 CNSsolve>eval ($db.DA_ASN = 0.19 ) 
 CNSsolve>eval ($db.DC_ASN = 0.09 ) 
 CNSsolve>eval ($db.DG_ASN = 0.22 ) 
 CNSsolve>eval ($db.DT_ASN = 0.10 ) 
 CNSsolve>eval ($db.DA_ASP = 0.44 ) 
 CNSsolve>eval ($db.DC_ASP = 0.16 ) 
 CNSsolve>eval ($db.DG_ASP = 0.10 ) 
 CNSsolve>eval ($db.DT_ASP = 0.05 ) 
 CNSsolve>eval ($db.DA_CYS = 0.00 ) 
 CNSsolve>eval ($db.DC_CYS = 0.00 ) 
 CNSsolve>eval ($db.DG_CYS = 0.00 ) 
 CNSsolve>eval ($db.DT_CYS = 0.00 ) 
 CNSsolve>eval ($db.DA_GLN = 0.15 ) 
 CNSsolve>eval ($db.DC_GLN = 0.19 ) 
 CNSsolve>eval ($db.DG_GLN = 0.15 ) 
 CNSsolve>eval ($db.DT_GLN = 0.13 ) 
 CNSsolve>eval ($db.DA_GLU = 0.11 ) 
 CNSsolve>eval ($db.DC_GLU = 0.15 ) 
 CNSsolve>eval ($db.DG_GLU = 0.13 ) 
 CNSsolve>eval ($db.DT_GLU = 0.00 ) 
 CNSsolve>eval ($db.DA_GLY = 0.00 ) 
 CNSsolve>eval ($db.DC_GLY = 0.00 ) 
 CNSsolve>eval ($db.DG_GLY = 0.00 ) 
 CNSsolve>eval ($db.DT_GLY = 0.00 ) 
 CNSsolve>eval ($db.DA_HIS = 0.10 ) 
 CNSsolve>eval ($db.DC_HIS = 0.14 ) 
 CNSsolve>eval ($db.DG_HIS = 0.18 ) 
 CNSsolve>eval ($db.DT_HIS = 0.06 ) 
 CNSsolve>eval ($db.DA_ILE = 0.00 ) 
 CNSsolve>eval ($db.DC_ILE = 0.00 ) 
 CNSsolve>eval ($db.DG_ILE = 0.00 ) 
 CNSsolve>eval ($db.DT_ILE = 0.00 ) 
 CNSsolve>eval ($db.DA_LEU = 0.00 ) 
 CNSsolve>eval ($db.DC_LEU = 0.00 ) 
 CNSsolve>eval ($db.DG_LEU = 0.00 ) 
 CNSsolve>eval ($db.DT_LEU = 0.00 ) 
 CNSsolve>eval ($db.DA_LYS = 0.31 ) 
 CNSsolve>eval ($db.DC_LYS = 0.15 ) 
 CNSsolve>eval ($db.DG_LYS = 0.29 ) 
 CNSsolve>eval ($db.DT_LYS = 0.18 ) 
 CNSsolve>eval ($db.DA_MET = 0.00 ) 
 CNSsolve>eval ($db.DC_MET = 0.00 ) 
 CNSsolve>eval ($db.DG_MET = 0.00 ) 
 CNSsolve>eval ($db.DT_MET = 0.00 ) 
 CNSsolve>eval ($db.DA_PHE = 0.00 ) 
 CNSsolve>eval ($db.DC_PHE = 0.00 ) 
 CNSsolve>eval ($db.DG_PHE = 0.00 ) 
 CNSsolve>eval ($db.DT_PHE = 0.00 ) 
 CNSsolve>eval ($db.DA_PRO = 0.00 ) 
 CNSsolve>eval ($db.DC_PRO = 0.00 ) 
 CNSsolve>eval ($db.DG_PRO = 0.00 ) 
 CNSsolve>eval ($db.DT_PRO = 0.00 ) 
 CNSsolve>eval ($db.DA_SER = 0.30 ) 
 CNSsolve>eval ($db.DC_SER = 0.03 ) 
 CNSsolve>eval ($db.DG_SER = 0.09 ) 
 CNSsolve>eval ($db.DT_SER = 0.03 ) 
 CNSsolve>eval ($db.DA_THR = 0.16 ) 
 CNSsolve>eval ($db.DC_THR = 0.16 ) 
 CNSsolve>eval ($db.DG_THR = 0.03 ) 
 CNSsolve>eval ($db.DT_THR = 0.05 ) 
 CNSsolve>eval ($db.DA_TRP = 0.00 ) 
 CNSsolve>eval ($db.DC_TRP = 0.00 ) 
 CNSsolve>eval ($db.DG_TRP = 0.00 ) 
 CNSsolve>eval ($db.DT_TRP = 0.00 ) 
 CNSsolve>eval ($db.DA_TYR = 0.13 ) 
 CNSsolve>eval ($db.DC_TYR = 0.10 ) 
 CNSsolve>eval ($db.DG_TYR = 0.10 ) 
 CNSsolve>eval ($db.DT_TYR = 0.02 ) 
 CNSsolve>eval ($db.DA_VAL = 0.00 ) 
 CNSsolve>eval ($db.DC_VAL = 0.00 ) 
 CNSsolve>eval ($db.DG_VAL = 0.00 ) 
 CNSsolve>eval ($db.DT_VAL = 0.00 ) 
 CNSsolve> 
 CNSsolve>eval ($db.DP_ALA_DA = 0.51 ) 
 CNSsolve>eval ($db.DP_ALA_DC = 0.51 ) 
 CNSsolve>eval ($db.DP_ALA_DG = 0.51 ) 
 CNSsolve>eval ($db.DP_ALA_DT = 0.51 ) 
 CNSsolve>eval ($db.DP_ARG_DA = 0.34 ) 
 CNSsolve>eval ($db.DP_ARG_DC = 0.34 ) 
 CNSsolve>eval ($db.DP_ARG_DG = 0.34 ) 
 CNSsolve>eval ($db.DP_ARG_DT = 0.34 ) 
 CNSsolve>eval ($db.DP_ASN_DA = 0.52 ) 
 CNSsolve>eval ($db.DP_ASN_DC = 0.52 ) 
 CNSsolve>eval ($db.DP_ASN_DG = 0.52 ) 
 CNSsolve>eval ($db.DP_ASN_DT = 0.52 ) 
 CNSsolve>eval ($db.DP_ASP_DA = 0.93 ) 
 CNSsolve>eval ($db.DP_ASP_DC = 0.93 ) 
 CNSsolve>eval ($db.DP_ASP_DG = 0.93 ) 
 CNSsolve>eval ($db.DP_ASP_DT = 0.93 ) 
 CNSsolve>eval ($db.DP_CYS_DA = 0.43 ) 
 CNSsolve>eval ($db.DP_CYS_DC = 0.43 ) 
 CNSsolve>eval ($db.DP_CYS_DG = 0.43 ) 
 CNSsolve>eval ($db.DP_CYS_DT = 0.43 ) 
 CNSsolve>eval ($db.DP_GLN_DA = 0.47 ) 
 CNSsolve>eval ($db.DP_GLN_DC = 0.47 ) 
 CNSsolve>eval ($db.DP_GLN_DG = 0.47 ) 
 CNSsolve>eval ($db.DP_GLN_DT = 0.47 ) 
 CNSsolve>eval ($db.DP_GLU_DA = 0.83 ) 
 CNSsolve>eval ($db.DP_GLU_DC = 0.83 ) 
 CNSsolve>eval ($db.DP_GLU_DG = 0.83 ) 
 CNSsolve>eval ($db.DP_GLU_DT = 0.83 ) 
 CNSsolve>eval ($db.DP_GLY_DA = 0.38 ) 
 CNSsolve>eval ($db.DP_GLY_DC = 0.38 ) 
 CNSsolve>eval ($db.DP_GLY_DG = 0.38 ) 
 CNSsolve>eval ($db.DP_GLY_DT = 0.38 ) 
 CNSsolve>eval ($db.DP_HIS_DA = 0.40 ) 
 CNSsolve>eval ($db.DP_HIS_DC = 0.40 ) 
 CNSsolve>eval ($db.DP_HIS_DG = 0.40 ) 
 CNSsolve>eval ($db.DP_HIS_DT = 0.40 ) 
 CNSsolve>eval ($db.DP_ILE_DA = 0.54 ) 
 CNSsolve>eval ($db.DP_ILE_DC = 0.54 ) 
 CNSsolve>eval ($db.DP_ILE_DG = 0.54 ) 
 CNSsolve>eval ($db.DP_ILE_DT = 0.54 ) 
 CNSsolve>eval ($db.DP_LEU_DA = 0.38 ) 
 CNSsolve>eval ($db.DP_LEU_DC = 0.38 ) 
 CNSsolve>eval ($db.DP_LEU_DG = 0.38 ) 
 CNSsolve>eval ($db.DP_LEU_DT = 0.38 ) 
 CNSsolve>eval ($db.DP_LYS_DA = 0.35 ) 
 CNSsolve>eval ($db.DP_LYS_DC = 0.35 ) 
 CNSsolve>eval ($db.DP_LYS_DG = 0.35 ) 
 CNSsolve>eval ($db.DP_LYS_DT = 0.35 ) 
 CNSsolve>eval ($db.DP_MET_DA = 0.50 ) 
 CNSsolve>eval ($db.DP_MET_DC = 0.50 ) 
 CNSsolve>eval ($db.DP_MET_DG = 0.50 ) 
 CNSsolve>eval ($db.DP_MET_DT = 0.50 ) 
 CNSsolve>eval ($db.DP_PHE_DA = 0.75 ) 
 CNSsolve>eval ($db.DP_PHE_DC = 0.75 ) 
 CNSsolve>eval ($db.DP_PHE_DG = 0.75 ) 
 CNSsolve>eval ($db.DP_PHE_DT = 0.75 ) 
 CNSsolve>eval ($db.DP_PRO_DA = 1.00 ) 
 CNSsolve>eval ($db.DP_PRO_DC = 1.00 ) 
 CNSsolve>eval ($db.DP_PRO_DG = 1.00 ) 
 CNSsolve>eval ($db.DP_PRO_DT = 1.00 ) 
 CNSsolve>eval ($db.DP_SER_DA = 0.38 ) 
 CNSsolve>eval ($db.DP_SER_DC = 0.38 ) 
 CNSsolve>eval ($db.DP_SER_DG = 0.38 ) 
 CNSsolve>eval ($db.DP_SER_DT = 0.38 ) 
 CNSsolve>eval ($db.DP_THR_DA = 0.40 ) 
 CNSsolve>eval ($db.DP_THR_DC = 0.40 ) 
 CNSsolve>eval ($db.DP_THR_DG = 0.40 ) 
 CNSsolve>eval ($db.DP_THR_DT = 0.40 ) 
 CNSsolve>eval ($db.DP_TRP_DA = 0.67 ) 
 CNSsolve>eval ($db.DP_TRP_DC = 0.67 ) 
 CNSsolve>eval ($db.DP_TRP_DG = 0.67 ) 
 CNSsolve>eval ($db.DP_TRP_DT = 0.67 ) 
 CNSsolve>eval ($db.DP_TYR_DA = 0.43 ) 
 CNSsolve>eval ($db.DP_TYR_DC = 0.43 ) 
 CNSsolve>eval ($db.DP_TYR_DG = 0.43 ) 
 CNSsolve>eval ($db.DP_TYR_DT = 0.43 ) 
 CNSsolve>eval ($db.DP_VAL_DA = 0.50 ) 
 CNSsolve>eval ($db.DP_VAL_DC = 0.50 ) 
 CNSsolve>eval ($db.DP_VAL_DG = 0.50 ) 
 CNSsolve>eval ($db.DP_VAL_DT = 0.50 ) 
 CNSsolve>eval ($db.DP_DA_ALA = 0.51 ) 
 CNSsolve>eval ($db.DP_DC_ALA = 0.51 ) 
 CNSsolve>eval ($db.DP_DG_ALA = 0.51 ) 
 CNSsolve>eval ($db.DP_DT_ALA = 0.51 ) 
 CNSsolve>eval ($db.DP_DA_ARG = 0.34 ) 
 CNSsolve>eval ($db.DP_DC_ARG = 0.34 ) 
 CNSsolve>eval ($db.DP_DG_ARG = 0.34 ) 
 CNSsolve>eval ($db.DP_DT_ARG = 0.34 ) 
 CNSsolve>eval ($db.DP_DA_ASN = 0.52 ) 
 CNSsolve>eval ($db.DP_DC_ASN = 0.52 ) 
 CNSsolve>eval ($db.DP_DG_ASN = 0.52 ) 
 CNSsolve>eval ($db.DP_DT_ASN = 0.52 ) 
 CNSsolve>eval ($db.DP_DA_ASP = 0.93 ) 
 CNSsolve>eval ($db.DP_DC_ASP = 0.93 ) 
 CNSsolve>eval ($db.DP_DG_ASP = 0.93 ) 
 CNSsolve>eval ($db.DP_DT_ASP = 0.93 ) 
 CNSsolve>eval ($db.DP_DA_CYS = 0.43 ) 
 CNSsolve>eval ($db.DP_DC_CYS = 0.43 ) 
 CNSsolve>eval ($db.DP_DG_CYS = 0.43 ) 
 CNSsolve>eval ($db.DP_DT_CYS = 0.43 ) 
 CNSsolve>eval ($db.DP_DA_GLN = 0.47 ) 
 CNSsolve>eval ($db.DP_DC_GLN = 0.47 ) 
 CNSsolve>eval ($db.DP_DG_GLN = 0.47 ) 
 CNSsolve>eval ($db.DP_DT_GLN = 0.47 ) 
 CNSsolve>eval ($db.DP_DA_GLU = 0.83 ) 
 CNSsolve>eval ($db.DP_DC_GLU = 0.83 ) 
 CNSsolve>eval ($db.DP_DG_GLU = 0.83 ) 
 CNSsolve>eval ($db.DP_DT_GLU = 0.83 ) 
 CNSsolve>eval ($db.DP_DA_GLY = 0.38 ) 
 CNSsolve>eval ($db.DP_DC_GLY = 0.38 ) 
 CNSsolve>eval ($db.DP_DG_GLY = 0.38 ) 
 CNSsolve>eval ($db.DP_DT_GLY = 0.38 ) 
 CNSsolve>eval ($db.DP_DA_HIS = 0.40 ) 
 CNSsolve>eval ($db.DP_DC_HIS = 0.40 ) 
 CNSsolve>eval ($db.DP_DG_HIS = 0.40 ) 
 CNSsolve>eval ($db.DP_DT_HIS = 0.40 ) 
 CNSsolve>eval ($db.DP_DA_ILE = 0.54 ) 
 CNSsolve>eval ($db.DP_DC_ILE = 0.54 ) 
 CNSsolve>eval ($db.DP_DG_ILE = 0.54 ) 
 CNSsolve>eval ($db.DP_DT_ILE = 0.54 ) 
 CNSsolve>eval ($db.DP_DA_LEU = 0.38 ) 
 CNSsolve>eval ($db.DP_DC_LEU = 0.38 ) 
 CNSsolve>eval ($db.DP_DG_LEU = 0.38 ) 
 CNSsolve>eval ($db.DP_DT_LEU = 0.38 ) 
 CNSsolve>eval ($db.DP_DA_LYS = 0.35 ) 
 CNSsolve>eval ($db.DP_DC_LYS = 0.35 ) 
 CNSsolve>eval ($db.DP_DG_LYS = 0.35 ) 
 CNSsolve>eval ($db.DP_DT_LYS = 0.35 ) 
 CNSsolve>eval ($db.DP_DA_MET = 0.50 ) 
 CNSsolve>eval ($db.DP_DC_MET = 0.50 ) 
 CNSsolve>eval ($db.DP_DG_MET = 0.50 ) 
 CNSsolve>eval ($db.DP_DT_MET = 0.50 ) 
 CNSsolve>eval ($db.DP_DA_PHE = 0.75 ) 
 CNSsolve>eval ($db.DP_DC_PHE = 0.75 ) 
 CNSsolve>eval ($db.DP_DG_PHE = 0.75 ) 
 CNSsolve>eval ($db.DP_DT_PHE = 0.75 ) 
 CNSsolve>eval ($db.DP_DA_PRO = 1.00 ) 
 CNSsolve>eval ($db.DP_DC_PRO = 1.00 ) 
 CNSsolve>eval ($db.DP_DG_PRO = 1.00 ) 
 CNSsolve>eval ($db.DP_DT_PRO = 1.00 ) 
 CNSsolve>eval ($db.DP_DA_SER = 0.38 ) 
 CNSsolve>eval ($db.DP_DC_SER = 0.38 ) 
 CNSsolve>eval ($db.DP_DG_SER = 0.38 ) 
 CNSsolve>eval ($db.DP_DT_SER = 0.38 ) 
 CNSsolve>eval ($db.DP_DA_THR = 0.40 ) 
 CNSsolve>eval ($db.DP_DC_THR = 0.40 ) 
 CNSsolve>eval ($db.DP_DG_THR = 0.40 ) 
 CNSsolve>eval ($db.DP_DT_THR = 0.40 ) 
 CNSsolve>eval ($db.DP_DA_TRP = 0.67 ) 
 CNSsolve>eval ($db.DP_DC_TRP = 0.67 ) 
 CNSsolve>eval ($db.DP_DG_TRP = 0.67 ) 
 CNSsolve>eval ($db.DP_DT_TRP = 0.67 ) 
 CNSsolve>eval ($db.DP_DA_TYR = 0.43 ) 
 CNSsolve>eval ($db.DP_DC_TYR = 0.43 ) 
 CNSsolve>eval ($db.DP_DG_TYR = 0.43 ) 
 CNSsolve>eval ($db.DP_DT_TYR = 0.43 ) 
 CNSsolve>eval ($db.DP_DA_VAL = 0.50 ) 
 CNSsolve>eval ($db.DP_DC_VAL = 0.50 ) 
 CNSsolve>eval ($db.DP_DG_VAL = 0.50 ) 
 CNSsolve>eval ($db.DP_DT_VAL = 0.50 ) 
 CNSsolve> 
 CNSsolve>eval ($db.ALA_A = 0.00 ) 
 CNSsolve>eval ($db.ALA_C = 0.00 ) 
 CNSsolve>eval ($db.ALA_G = 0.00 ) 
 CNSsolve>eval ($db.ALA_T = 0.00 ) 
 CNSsolve>eval ($db.ARG_A = 0.14 ) 
 CNSsolve>eval ($db.ARG_C = 0.07 ) 
 CNSsolve>eval ($db.ARG_G = 0.14 ) 
 CNSsolve>eval ($db.ARG_T = 0.08 ) 
 CNSsolve>eval ($db.ASN_A = 0.19 ) 
 CNSsolve>eval ($db.ASN_C = 0.09 ) 
 CNSsolve>eval ($db.ASN_G = 0.22 ) 
 CNSsolve>eval ($db.ASN_T = 0.10 ) 
 CNSsolve>eval ($db.ASP_A = 0.44 ) 
 CNSsolve>eval ($db.ASP_C = 0.16 ) 
 CNSsolve>eval ($db.ASP_G = 0.10 ) 
 CNSsolve>eval ($db.ASP_T = 0.05 ) 
 CNSsolve>eval ($db.CYS_A = 0.00 ) 
 CNSsolve>eval ($db.CYS_C = 0.00 ) 
 CNSsolve>eval ($db.CYS_G = 0.00 ) 
 CNSsolve>eval ($db.CYS_T = 0.00 ) 
 CNSsolve>eval ($db.GLN_A = 0.15 ) 
 CNSsolve>eval ($db.GLN_C = 0.19 ) 
 CNSsolve>eval ($db.GLN_G = 0.15 ) 
 CNSsolve>eval ($db.GLN_T = 0.13 ) 
 CNSsolve>eval ($db.GLU_A = 0.11 ) 
 CNSsolve>eval ($db.GLU_C = 0.15 ) 
 CNSsolve>eval ($db.GLU_G = 0.13 ) 
 CNSsolve>eval ($db.GLU_T = 0.00 ) 
 CNSsolve>eval ($db.GLY_A = 0.00 ) 
 CNSsolve>eval ($db.GLY_C = 0.00 ) 
 CNSsolve>eval ($db.GLY_G = 0.00 ) 
 CNSsolve>eval ($db.GLY_T = 0.00 ) 
 CNSsolve>eval ($db.HIS_A = 0.10 ) 
 CNSsolve>eval ($db.HIS_C = 0.14 ) 
 CNSsolve>eval ($db.HIS_G = 0.18 ) 
 CNSsolve>eval ($db.HIS_T = 0.06 ) 
 CNSsolve>eval ($db.ILE_A = 0.00 ) 
 CNSsolve>eval ($db.ILE_C = 0.00 ) 
 CNSsolve>eval ($db.ILE_G = 0.00 ) 
 CNSsolve>eval ($db.ILE_T = 0.00 ) 
 CNSsolve>eval ($db.LEU_A = 0.00 ) 
 CNSsolve>eval ($db.LEU_C = 0.00 ) 
 CNSsolve>eval ($db.LEU_G = 0.00 ) 
 CNSsolve>eval ($db.LEU_T = 0.00 ) 
 CNSsolve>eval ($db.LYS_A = 0.31 ) 
 CNSsolve>eval ($db.LYS_C = 0.15 ) 
 CNSsolve>eval ($db.LYS_G = 0.29 ) 
 CNSsolve>eval ($db.LYS_T = 0.18 ) 
 CNSsolve>eval ($db.MET_A = 0.00 ) 
 CNSsolve>eval ($db.MET_C = 0.00 ) 
 CNSsolve>eval ($db.MET_G = 0.00 ) 
 CNSsolve>eval ($db.MET_T = 0.00 ) 
 CNSsolve>eval ($db.PHE_A = 0.00 ) 
 CNSsolve>eval ($db.PHE_C = 0.00 ) 
 CNSsolve>eval ($db.PHE_G = 0.00 ) 
 CNSsolve>eval ($db.PHE_T = 0.00 ) 
 CNSsolve>eval ($db.PRO_A = 0.00 ) 
 CNSsolve>eval ($db.PRO_C = 0.00 ) 
 CNSsolve>eval ($db.PRO_G = 0.00 ) 
 CNSsolve>eval ($db.PRO_T = 0.00 ) 
 CNSsolve>eval ($db.SER_A = 0.30 ) 
 CNSsolve>eval ($db.SER_C = 0.03 ) 
 CNSsolve>eval ($db.SER_G = 0.09 ) 
 CNSsolve>eval ($db.SER_T = 0.03 ) 
 CNSsolve>eval ($db.THR_A = 0.16 ) 
 CNSsolve>eval ($db.THR_C = 0.16 ) 
 CNSsolve>eval ($db.THR_G = 0.03 ) 
 CNSsolve>eval ($db.THR_T = 0.05 ) 
 CNSsolve>eval ($db.TRP_A = 0.00 ) 
 CNSsolve>eval ($db.TRP_C = 0.00 ) 
 CNSsolve>eval ($db.TRP_G = 0.00 ) 
 CNSsolve>eval ($db.TRP_T = 0.00 ) 
 CNSsolve>eval ($db.TYR_A = 0.13 ) 
 CNSsolve>eval ($db.TYR_C = 0.10 ) 
 CNSsolve>eval ($db.TYR_G = 0.10 ) 
 CNSsolve>eval ($db.TYR_T = 0.02 ) 
 CNSsolve>eval ($db.VAL_A = 0.00 ) 
 CNSsolve>eval ($db.VAL_C = 0.00 ) 
 CNSsolve>eval ($db.VAL_G = 0.00 ) 
 CNSsolve>eval ($db.VAL_T = 0.00 ) 
 CNSsolve>eval ($db.A_ALA = 0.00 ) 
 CNSsolve>eval ($db.C_ALA = 0.00 ) 
 CNSsolve>eval ($db.G_ALA = 0.00 ) 
 CNSsolve>eval ($db.T_ALA = 0.00 ) 
 CNSsolve>eval ($db.A_ARG = 0.14 ) 
 CNSsolve>eval ($db.C_ARG = 0.07 ) 
 CNSsolve>eval ($db.G_ARG = 0.14 ) 
 CNSsolve>eval ($db.T_ARG = 0.08 ) 
 CNSsolve>eval ($db.A_ASN = 0.19 ) 
 CNSsolve>eval ($db.C_ASN = 0.09 ) 
 CNSsolve>eval ($db.G_ASN = 0.22 ) 
 CNSsolve>eval ($db.T_ASN = 0.10 ) 
 CNSsolve>eval ($db.A_ASP = 0.44 ) 
 CNSsolve>eval ($db.C_ASP = 0.16 ) 
 CNSsolve>eval ($db.G_ASP = 0.10 ) 
 CNSsolve>eval ($db.T_ASP = 0.05 ) 
 CNSsolve>eval ($db.A_CYS = 0.00 ) 
 CNSsolve>eval ($db.C_CYS = 0.00 ) 
 CNSsolve>eval ($db.G_CYS = 0.00 ) 
 CNSsolve>eval ($db.T_CYS = 0.00 ) 
 CNSsolve>eval ($db.A_GLN = 0.15 ) 
 CNSsolve>eval ($db.C_GLN = 0.19 ) 
 CNSsolve>eval ($db.G_GLN = 0.15 ) 
 CNSsolve>eval ($db.T_GLN = 0.13 ) 
 CNSsolve>eval ($db.A_GLU = 0.11 ) 
 CNSsolve>eval ($db.C_GLU = 0.15 ) 
 CNSsolve>eval ($db.G_GLU = 0.13 ) 
 CNSsolve>eval ($db.T_GLU = 0.00 ) 
 CNSsolve>eval ($db.A_GLY = 0.00 ) 
 CNSsolve>eval ($db.C_GLY = 0.00 ) 
 CNSsolve>eval ($db.G_GLY = 0.00 ) 
 CNSsolve>eval ($db.T_GLY = 0.00 ) 
 CNSsolve>eval ($db.A_HIS = 0.10 ) 
 CNSsolve>eval ($db.C_HIS = 0.14 ) 
 CNSsolve>eval ($db.G_HIS = 0.18 ) 
 CNSsolve>eval ($db.T_HIS = 0.06 ) 
 CNSsolve>eval ($db.A_ILE = 0.00 ) 
 CNSsolve>eval ($db.C_ILE = 0.00 ) 
 CNSsolve>eval ($db.G_ILE = 0.00 ) 
 CNSsolve>eval ($db.T_ILE = 0.00 ) 
 CNSsolve>eval ($db.A_LEU = 0.00 ) 
 CNSsolve>eval ($db.C_LEU = 0.00 ) 
 CNSsolve>eval ($db.G_LEU = 0.00 ) 
 CNSsolve>eval ($db.T_LEU = 0.00 ) 
 CNSsolve>eval ($db.A_LYS = 0.31 ) 
 CNSsolve>eval ($db.C_LYS = 0.15 ) 
 CNSsolve>eval ($db.G_LYS = 0.29 ) 
 CNSsolve>eval ($db.T_LYS = 0.18 ) 
 CNSsolve>eval ($db.A_MET = 0.00 ) 
 CNSsolve>eval ($db.C_MET = 0.00 ) 
 CNSsolve>eval ($db.G_MET = 0.00 ) 
 CNSsolve>eval ($db.T_MET = 0.00 ) 
 CNSsolve>eval ($db.A_PHE = 0.00 ) 
 CNSsolve>eval ($db.C_PHE = 0.00 ) 
 CNSsolve>eval ($db.G_PHE = 0.00 ) 
 CNSsolve>eval ($db.T_PHE = 0.00 ) 
 CNSsolve>eval ($db.A_PRO = 0.00 ) 
 CNSsolve>eval ($db.C_PRO = 0.00 ) 
 CNSsolve>eval ($db.G_PRO = 0.00 ) 
 CNSsolve>eval ($db.T_PRO = 0.00 ) 
 CNSsolve>eval ($db.A_SER = 0.30 ) 
 CNSsolve>eval ($db.C_SER = 0.03 ) 
 CNSsolve>eval ($db.G_SER = 0.09 ) 
 CNSsolve>eval ($db.T_SER = 0.03 ) 
 CNSsolve>eval ($db.A_THR = 0.16 ) 
 CNSsolve>eval ($db.C_THR = 0.16 ) 
 CNSsolve>eval ($db.G_THR = 0.03 ) 
 CNSsolve>eval ($db.T_THR = 0.05 ) 
 CNSsolve>eval ($db.A_TRP = 0.00 ) 
 CNSsolve>eval ($db.C_TRP = 0.00 ) 
 CNSsolve>eval ($db.G_TRP = 0.00 ) 
 CNSsolve>eval ($db.T_TRP = 0.00 ) 
 CNSsolve>eval ($db.A_TYR = 0.13 ) 
 CNSsolve>eval ($db.C_TYR = 0.10 ) 
 CNSsolve>eval ($db.G_TYR = 0.10 ) 
 CNSsolve>eval ($db.T_TYR = 0.02 ) 
 CNSsolve>eval ($db.A_VAL = 0.00 ) 
 CNSsolve>eval ($db.C_VAL = 0.00 ) 
 CNSsolve>eval ($db.G_VAL = 0.00 ) 
 CNSsolve>eval ($db.T_VAL = 0.00 ) 
 CNSsolve> 
 CNSsolve>eval ($db.DP_ALA_A = 0.51 ) 
 CNSsolve>eval ($db.DP_ALA_C = 0.51 ) 
 CNSsolve>eval ($db.DP_ALA_G = 0.51 ) 
 CNSsolve>eval ($db.DP_ALA_T = 0.51 ) 
 CNSsolve>eval ($db.DP_ARG_A = 0.34 ) 
 CNSsolve>eval ($db.DP_ARG_C = 0.34 ) 
 CNSsolve>eval ($db.DP_ARG_G = 0.34 ) 
 CNSsolve>eval ($db.DP_ARG_T = 0.34 ) 
 CNSsolve>eval ($db.DP_ASN_A = 0.52 ) 
 CNSsolve>eval ($db.DP_ASN_C = 0.52 ) 
 CNSsolve>eval ($db.DP_ASN_G = 0.52 ) 
 CNSsolve>eval ($db.DP_ASN_T = 0.52 ) 
 CNSsolve>eval ($db.DP_ASP_A = 0.93 ) 
 CNSsolve>eval ($db.DP_ASP_C = 0.93 ) 
 CNSsolve>eval ($db.DP_ASP_G = 0.93 ) 
 CNSsolve>eval ($db.DP_ASP_T = 0.93 ) 
 CNSsolve>eval ($db.DP_CYS_A = 0.43 ) 
 CNSsolve>eval ($db.DP_CYS_C = 0.43 ) 
 CNSsolve>eval ($db.DP_CYS_G = 0.43 ) 
 CNSsolve>eval ($db.DP_CYS_T = 0.43 ) 
 CNSsolve>eval ($db.DP_GLN_A = 0.47 ) 
 CNSsolve>eval ($db.DP_GLN_C = 0.47 ) 
 CNSsolve>eval ($db.DP_GLN_G = 0.47 ) 
 CNSsolve>eval ($db.DP_GLN_T = 0.47 ) 
 CNSsolve>eval ($db.DP_GLU_A = 0.83 ) 
 CNSsolve>eval ($db.DP_GLU_C = 0.83 ) 
 CNSsolve>eval ($db.DP_GLU_G = 0.83 ) 
 CNSsolve>eval ($db.DP_GLU_T = 0.83 ) 
 CNSsolve>eval ($db.DP_GLY_A = 0.38 ) 
 CNSsolve>eval ($db.DP_GLY_C = 0.38 ) 
 CNSsolve>eval ($db.DP_GLY_G = 0.38 ) 
 CNSsolve>eval ($db.DP_GLY_T = 0.38 ) 
 CNSsolve>eval ($db.DP_HIS_A = 0.40 ) 
 CNSsolve>eval ($db.DP_HIS_C = 0.40 ) 
 CNSsolve>eval ($db.DP_HIS_G = 0.40 ) 
 CNSsolve>eval ($db.DP_HIS_T = 0.40 ) 
 CNSsolve>eval ($db.DP_ILE_A = 0.54 ) 
 CNSsolve>eval ($db.DP_ILE_C = 0.54 ) 
 CNSsolve>eval ($db.DP_ILE_G = 0.54 ) 
 CNSsolve>eval ($db.DP_ILE_T = 0.54 ) 
 CNSsolve>eval ($db.DP_LEU_A = 0.38 ) 
 CNSsolve>eval ($db.DP_LEU_C = 0.38 ) 
 CNSsolve>eval ($db.DP_LEU_G = 0.38 ) 
 CNSsolve>eval ($db.DP_LEU_T = 0.38 ) 
 CNSsolve>eval ($db.DP_LYS_A = 0.35 ) 
 CNSsolve>eval ($db.DP_LYS_C = 0.35 ) 
 CNSsolve>eval ($db.DP_LYS_G = 0.35 ) 
 CNSsolve>eval ($db.DP_LYS_T = 0.35 ) 
 CNSsolve>eval ($db.DP_MET_A = 0.50 ) 
 CNSsolve>eval ($db.DP_MET_C = 0.50 ) 
 CNSsolve>eval ($db.DP_MET_G = 0.50 ) 
 CNSsolve>eval ($db.DP_MET_T = 0.50 ) 
 CNSsolve>eval ($db.DP_PHE_A = 0.75 ) 
 CNSsolve>eval ($db.DP_PHE_C = 0.75 ) 
 CNSsolve>eval ($db.DP_PHE_G = 0.75 ) 
 CNSsolve>eval ($db.DP_PHE_T = 0.75 ) 
 CNSsolve>eval ($db.DP_PRO_A = 1.00 ) 
 CNSsolve>eval ($db.DP_PRO_C = 1.00 ) 
 CNSsolve>eval ($db.DP_PRO_G = 1.00 ) 
 CNSsolve>eval ($db.DP_PRO_T = 1.00 ) 
 CNSsolve>eval ($db.DP_SER_A = 0.38 ) 
 CNSsolve>eval ($db.DP_SER_C = 0.38 ) 
 CNSsolve>eval ($db.DP_SER_G = 0.38 ) 
 CNSsolve>eval ($db.DP_SER_T = 0.38 ) 
 CNSsolve>eval ($db.DP_THR_A = 0.40 ) 
 CNSsolve>eval ($db.DP_THR_C = 0.40 ) 
 CNSsolve>eval ($db.DP_THR_G = 0.40 ) 
 CNSsolve>eval ($db.DP_THR_T = 0.40 ) 
 CNSsolve>eval ($db.DP_TRP_A = 0.67 ) 
 CNSsolve>eval ($db.DP_TRP_C = 0.67 ) 
 CNSsolve>eval ($db.DP_TRP_G = 0.67 ) 
 CNSsolve>eval ($db.DP_TRP_T = 0.67 ) 
 CNSsolve>eval ($db.DP_TYR_A = 0.43 ) 
 CNSsolve>eval ($db.DP_TYR_C = 0.43 ) 
 CNSsolve>eval ($db.DP_TYR_G = 0.43 ) 
 CNSsolve>eval ($db.DP_TYR_T = 0.43 ) 
 CNSsolve>eval ($db.DP_VAL_A = 0.50 ) 
 CNSsolve>eval ($db.DP_VAL_C = 0.50 ) 
 CNSsolve>eval ($db.DP_VAL_G = 0.50 ) 
 CNSsolve>eval ($db.DP_VAL_T = 0.50 ) 
 CNSsolve>eval ($db.DP_A_ALA = 0.51 ) 
 CNSsolve>eval ($db.DP_C_ALA = 0.51 ) 
 CNSsolve>eval ($db.DP_G_ALA = 0.51 ) 
 CNSsolve>eval ($db.DP_T_ALA = 0.51 ) 
 CNSsolve>eval ($db.DP_A_ARG = 0.34 ) 
 CNSsolve>eval ($db.DP_C_ARG = 0.34 ) 
 CNSsolve>eval ($db.DP_G_ARG = 0.34 ) 
 CNSsolve>eval ($db.DP_T_ARG = 0.34 ) 
 CNSsolve>eval ($db.DP_A_ASN = 0.52 ) 
 CNSsolve>eval ($db.DP_C_ASN = 0.52 ) 
 CNSsolve>eval ($db.DP_G_ASN = 0.52 ) 
 CNSsolve>eval ($db.DP_T_ASN = 0.52 ) 
 CNSsolve>eval ($db.DP_A_ASP = 0.93 ) 
 CNSsolve>eval ($db.DP_C_ASP = 0.93 ) 
 CNSsolve>eval ($db.DP_G_ASP = 0.93 ) 
 CNSsolve>eval ($db.DP_T_ASP = 0.93 ) 
 CNSsolve>eval ($db.DP_A_CYS = 0.43 ) 
 CNSsolve>eval ($db.DP_C_CYS = 0.43 ) 
 CNSsolve>eval ($db.DP_G_CYS = 0.43 ) 
 CNSsolve>eval ($db.DP_T_CYS = 0.43 ) 
 CNSsolve>eval ($db.DP_A_GLN = 0.47 ) 
 CNSsolve>eval ($db.DP_C_GLN = 0.47 ) 
 CNSsolve>eval ($db.DP_G_GLN = 0.47 ) 
 CNSsolve>eval ($db.DP_T_GLN = 0.47 ) 
 CNSsolve>eval ($db.DP_A_GLU = 0.83 ) 
 CNSsolve>eval ($db.DP_C_GLU = 0.83 ) 
 CNSsolve>eval ($db.DP_G_GLU = 0.83 ) 
 CNSsolve>eval ($db.DP_T_GLU = 0.83 ) 
 CNSsolve>eval ($db.DP_A_GLY = 0.38 ) 
 CNSsolve>eval ($db.DP_C_GLY = 0.38 ) 
 CNSsolve>eval ($db.DP_G_GLY = 0.38 ) 
 CNSsolve>eval ($db.DP_T_GLY = 0.38 ) 
 CNSsolve>eval ($db.DP_A_HIS = 0.40 ) 
 CNSsolve>eval ($db.DP_C_HIS = 0.40 ) 
 CNSsolve>eval ($db.DP_G_HIS = 0.40 ) 
 CNSsolve>eval ($db.DP_T_HIS = 0.40 ) 
 CNSsolve>eval ($db.DP_A_ILE = 0.54 ) 
 CNSsolve>eval ($db.DP_C_ILE = 0.54 ) 
 CNSsolve>eval ($db.DP_G_ILE = 0.54 ) 
 CNSsolve>eval ($db.DP_T_ILE = 0.54 ) 
 CNSsolve>eval ($db.DP_A_LEU = 0.38 ) 
 CNSsolve>eval ($db.DP_C_LEU = 0.38 ) 
 CNSsolve>eval ($db.DP_G_LEU = 0.38 ) 
 CNSsolve>eval ($db.DP_T_LEU = 0.38 ) 
 CNSsolve>eval ($db.DP_A_LYS = 0.35 ) 
 CNSsolve>eval ($db.DP_C_LYS = 0.35 ) 
 CNSsolve>eval ($db.DP_G_LYS = 0.35 ) 
 CNSsolve>eval ($db.DP_T_LYS = 0.35 ) 
 CNSsolve>eval ($db.DP_A_MET = 0.50 ) 
 CNSsolve>eval ($db.DP_C_MET = 0.50 ) 
 CNSsolve>eval ($db.DP_G_MET = 0.50 ) 
 CNSsolve>eval ($db.DP_T_MET = 0.50 ) 
 CNSsolve>eval ($db.DP_A_PHE = 0.75 ) 
 CNSsolve>eval ($db.DP_C_PHE = 0.75 ) 
 CNSsolve>eval ($db.DP_G_PHE = 0.75 ) 
 CNSsolve>eval ($db.DP_T_PHE = 0.75 ) 
 CNSsolve>eval ($db.DP_A_PRO = 1.00 ) 
 CNSsolve>eval ($db.DP_C_PRO = 1.00 ) 
 CNSsolve>eval ($db.DP_G_PRO = 1.00 ) 
 CNSsolve>eval ($db.DP_T_PRO = 1.00 ) 
 CNSsolve>eval ($db.DP_A_SER = 0.38 ) 
 CNSsolve>eval ($db.DP_C_SER = 0.38 ) 
 CNSsolve>eval ($db.DP_G_SER = 0.38 ) 
 CNSsolve>eval ($db.DP_T_SER = 0.38 ) 
 CNSsolve>eval ($db.DP_A_THR = 0.40 ) 
 CNSsolve>eval ($db.DP_C_THR = 0.40 ) 
 CNSsolve>eval ($db.DP_G_THR = 0.40 ) 
 CNSsolve>eval ($db.DP_T_THR = 0.40 ) 
 CNSsolve>eval ($db.DP_A_TRP = 0.67 ) 
 CNSsolve>eval ($db.DP_C_TRP = 0.67 ) 
 CNSsolve>eval ($db.DP_G_TRP = 0.67 ) 
 CNSsolve>eval ($db.DP_T_TRP = 0.67 ) 
 CNSsolve>eval ($db.DP_A_TYR = 0.43 ) 
 CNSsolve>eval ($db.DP_C_TYR = 0.43 ) 
 CNSsolve>eval ($db.DP_G_TYR = 0.43 ) 
 CNSsolve>eval ($db.DP_T_TYR = 0.43 ) 
 CNSsolve>eval ($db.DP_A_VAL = 0.50 ) 
 CNSsolve>eval ($db.DP_C_VAL = 0.50 ) 
 CNSsolve>eval ($db.DP_G_VAL = 0.50 ) 
 CNSsolve>eval ($db.DP_T_VAL = 0.50 ) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! First pass, all interactions except those with DNA/RNA Phosphate groups 
 CNSsolve>evaluate ($done = 0) 
 CNSsolve>evaluate ($counttrial = 0) 
 CNSsolve>evaluate ($maxcounttrial = 1000) 
 CNSsolve>while ($done = 0)  loop trial 
 CNSsolve>  eval($counttrial = $counttrial+1) 
 CNSsolve>  if ($counttrial > $maxcounttrial) then 
 CNSsolve>   eval($done = 1) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($iselres1 = 0) 
 CNSsolve>  evaluate ($iselres1 = int(ran() * $rmax) + 1) 
 CNSsolve> 
 CNSsolve>  eval($founda=0) 
 CNSsolve>  eval($foundb=0) 
 CNSsolve>  eval($closesta=1000) 
 CNSsolve>  eval($closestb=1000) 
 CNSsolve> 
 CNSsolve>  !find first closest residue of all chains 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve>  eval($closechain = 0) 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    for $atom_ida in id (segid $Toppar.prot_segid_$nchain1 and (not (name P or name O*P* or name "O3'" or name "O5'")) and (attr store4 = $iselres1) around $testcutoff) loop seg1loop 
 CNSsolve>      pick bond (attr store4 = $iselres1) (id $atom_ida) geometry 
 CNSsolve>      eval ($dist=$result) 
 CNSsolve>      if ($dist<$closesta) then 
 CNSsolve>        eval($founda=$founda+1) 
 CNSsolve>        eval($closesta=$dist) 
 CNSsolve>        show element (resn) (id $atom_ida) 
 CNSsolve>        eval($restypea=$result) 
 CNSsolve>        eval($closechain=$nchain1) 
 CNSsolve>      end if 
 CNSsolve>    end loop seg1loop 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  ! do not consider if close to a phosphate group 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    for $atom_ida in id (segid $Toppar.prot_segid_$nchain1 and (name P or name O*P* or name "O3'" or name "O5'") and (attr store4 = $iselres1) around $testcutoff) loop seg1loop 
 CNSsolve>      eval($founda=0) 
 CNSsolve>    end loop seg1loop 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve>  !find second closest residue from all other chains than the closest residue selected above 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    if ($nchain1 ne $closechain) then 
 CNSsolve>      for $atom_idb in id (segid $Toppar.prot_segid_$nchain1 and (not (name P or name O*P* or name "O3'" or name "O5'")) and (attr store4 = $iselres1) around $testcutoff) loop seg2loop 
 CNSsolve>        pick bond (attr store4 = $iselres1) (id $atom_idb) geometry 
 CNSsolve>        eval ($dist=$result) 
 CNSsolve>        if ($dist<$closestb) then 
 CNSsolve>          eval($foundb=$foundb+1) 
 CNSsolve>          eval($closestb=$dist) 
 CNSsolve>          show element (resn) (id $atom_idb) 
 CNSsolve>          eval($restypeb=$result) 
 CNSsolve>        end if 
 CNSsolve>      end loop seg2loop 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop2 
 CNSsolve> 
 CNSsolve>  if ($founda > 0) then 
 CNSsolve>   if($foundb > 0) then 
 CNSsolve>    display SOLVATED-DOCKING: $iselres1 $closesta $restypea $closestb $restypeb $db.$restypea_$restypeb 
 CNSsolve>    eval ($r = random(1.0)) 
 CNSsolve>!    display SOLVATED-DOCKING: info: r-value $r 
 CNSsolve>    eval ($r = $r*$rmultfact) 
 CNSsolve>    if ($r > $db.$restypea_$restypeb) then 
 CNSsolve>!     display SOLVATED-DOCKING: $r bigger than $db.$restypea_$restypeb for $iselres1 with $restypea - $restypeb 
 CNSsolve>     !so this one is 'deleted' 
 CNSsolve>     do (store5=1) (attr store4 = $iselres1) 
 CNSsolve>    else 
 CNSsolve>!     display SOLVATED-DOCKING: $r smaller than $db.$restypea_$restypeb for $iselres1 with $restypea - $restypeb 
 CNSsolve>    end if 
 CNSsolve>   else 
 CNSsolve>!    display SOLVATED-DOCKING: nothing found for $iselres1 
 CNSsolve>    do (store5=1) (attr store4 = $iselres1) 
 CNSsolve>   end if 
 CNSsolve>  else 
 CNSsolve>!   display SOLVATED-DOCKING: nothing found for $iselres1 
 CNSsolve>   do (store5=1) (attr store4 = $iselres1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  show sum(1) ((resn WAT or resn HOH) and name OH2 and (attr store5 ne 1)) 
 CNSsolve>  if ($watercount > 0) then 
 CNSsolve>    eval($fractionleft = $result/$watercount) 
 CNSsolve>  else 
 CNSsolve>   eval($fractionleft = 0.0) 
 CNSsolve>  end if 
 CNSsolve>  display SOLVATED-DOCKING: FRACTION LEFT $fractionleft 
 CNSsolve>  if ($fractionleft < $data.water_tokeep) then 
 CNSsolve>    evaluate ($done = 1) 
 CNSsolve>  end if 
 CNSsolve>end loop trial 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Second pass, all interactions with DNA/RNA Phosphate groups 
 CNSsolve>evaluate ($done = 0) 
 CNSsolve>evaluate ($counttrial = 0) 
 CNSsolve>evaluate ($maxcounttrial = 1000) 
 CNSsolve>while ($done = 0)  loop ptrial 
 CNSsolve>  eval($counttrial = $counttrial+1) 
 CNSsolve>  if ($counttrial > $maxcounttrial) then 
 CNSsolve>   eval($done = 1) 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($iselres1 = 0) 
 CNSsolve>  evaluate ($iselres1 = int(ran() * $rmax) + 1) 
 CNSsolve> 
 CNSsolve>  eval($founda=0) 
 CNSsolve>  eval($foundb=0) 
 CNSsolve>  eval($closesta=1000) 
 CNSsolve>  eval($closestb=1000) 
 CNSsolve> 
 CNSsolve>  !find first closest residue of all chains 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve>  eval($closechain = 0) 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    for $atom_ida in id (segid $Toppar.prot_segid_$nchain1 and (name P or name O*P* or name "O3'" or name "O5'") and (attr store4 = $iselres1) around $testcutoff) loop seg1loop 
 CNSsolve>      pick bond (attr store4 = $iselres1) (id $atom_ida) geometry 
 CNSsolve>      eval ($dist=$result) 
 CNSsolve>      if ($dist<$closesta) then 
 CNSsolve>        eval($founda=$founda+1) 
 CNSsolve>        eval($closesta=$dist) 
 CNSsolve>        show element (resn) (id $atom_ida) 
 CNSsolve>        eval($restypea=$result) 
 CNSsolve>        eval($closechain=$nchain1) 
 CNSsolve>      end if 
 CNSsolve>    end loop seg1loop 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve>  !find second closest residue from all other chains than the closest residue selected above 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    if ($nchain1 ne $closechain) then 
 CNSsolve>      for $atom_idb in id (segid $Toppar.prot_segid_$nchain1 and (attr store4 = $iselres1) around $testcutoff) loop seg2loop 
 CNSsolve>        pick bond (attr store4 = $iselres1) (id $atom_idb) geometry 
 CNSsolve>        eval ($dist=$result) 
 CNSsolve>        if ($dist<$closestb) then 
 CNSsolve>          eval($foundb=$foundb+1) 
 CNSsolve>          eval($closestb=$dist) 
 CNSsolve>          show element (resn) (id $atom_idb) 
 CNSsolve>          eval($restypeb=$result) 
 CNSsolve>        end if 
 CNSsolve>      end loop seg2loop 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop2 
 CNSsolve> 
 CNSsolve>  if ($founda > 0) then 
 CNSsolve>   if($foundb > 0) then 
 CNSsolve>    display SOLVATED-DOCKING DNA PHOSPHATE: $iselres1 $closesta $restypea $closestb $restypeb $db.$restypea_$restypeb 
 CNSsolve>    eval ($r = random(1.0)) 
 CNSsolve>!    display SOLVATED-DOCKING: info: r-value $r 
 CNSsolve>    eval ($r = $r*$rmultfact) 
 CNSsolve>    if ($r > $db.DP_$restypea_$restypeb) then 
 CNSsolve>!     display SOLVATED-DOCKING: $r bigger than $db.DP_$restypea_$restypeb for $iselres1 with $restypea - $restypeb 
 CNSsolve>     !so this one is 'deleted' 
 CNSsolve>     do (store5=1) (attr store4 = $iselres1) 
 CNSsolve>    else 
 CNSsolve>!     display SOLVATED-DOCKING: $r smaller than $db.DP_$restypea_$restypeb for $iselres1 with $restypea - $restypeb 
 CNSsolve>    end if 
 CNSsolve>   else 
 CNSsolve>!    display SOLVATED-DOCKING: nothing found for $iselres1 
 CNSsolve>    do (store5=1) (attr store4 = $iselres1) 
 CNSsolve>   end if 
 CNSsolve>  else 
 CNSsolve>!   display SOLVATED-DOCKING: nothing found for $iselres1 
 CNSsolve>   do (store5=1) (attr store4 = $iselres1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  show sum(1) ((resn WAT or resn HOH) and name OH2 and (attr store5 ne 1)) 
 CNSsolve>  if ($dnapwatercount > 0) then 
 CNSsolve>    eval($fractionleft = $result/$dnapwatercount) 
 CNSsolve>  else 
 CNSsolve>   eval($fractionleft = 0.0) 
 CNSsolve>  end if 
 CNSsolve>  display SOLVATED-DOCKING: FRACTION LEFT AROUND DNA PHOSPHATE $fractionleft 
 CNSsolve>  if ($fractionleft < $data.dnap_water_tokeep) then 
 CNSsolve>    evaluate ($done = 1) 
 CNSsolve>  end if 
 CNSsolve>end loop ptrial 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>show sum(1) ((resn WAT or resn HOH) and name OH2 and (attr store5 ne 1)) 
 CNSsolve>if ($watercount > 0) then 
 CNSsolve>  eval($fractionleft = $result/$watercount) 
 CNSsolve>else 
 CNSsolve>  eval($fractionleft = 0.0) 
 CNSsolve>end if 
 CNSsolve>display SOLVATED-DOCKING: FINAL FRACTION LEFT BEFORE ENERGY FILTER $fractionleft ($result WATERS) 
 CNSsolve> 
 CNSsolve>for $wat_id in id ((resn WAT or resn HOH) and name OH2 and (attr store5 ne 1)) loop dbloop 
 CNSsolve> igroup interaction (not all) (not all) end 
 CNSsolve> igroup interaction (all) (byres(id $wat_id)) end 
 CNSsolve> energy end 
 CNSsolve> eval($waterenergy=$vdw + $elec) 
 CNSsolve> if ($waterenergy>$enercutoff) then 
 CNSsolve> !energy too high --> 'deleted' 
 CNSsolve>  do (store5=1) (id $wat_id) 
 CNSsolve>!  display SOLVATED-DOCKING: energy of id $wat_id is $waterenergy which is higher than cutoff $enercutoff 
 CNSsolve> else 
 CNSsolve>!  display SOLVATED-DOCKING: energy of id $wat_id is $waterenergy which is lower than cutoff $enercutoff 
 CNSsolve> end if 
 CNSsolve>end loop dbloop 
 CNSsolve> 
 CNSsolve>show sum(1) ((resn WAT or resn HOH) and name OH2 and (attr store5 ne 1)) 
 CNSsolve>if ($watercount > 0) then 
 CNSsolve>  eval($fractionleft = $result/$watercount) 
 CNSsolve>else 
 CNSsolve>  eval($fractionleft = 0.0) 
 CNSsolve>end if 
 CNSsolve>display SOLVATED-DOCKING: FINAL FRACTION LEFT AFTER ENERGY FILTER $fractionleft ($result WATERS) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>do (store5 = 1) (byres(attr store5 =1 )) 
 CNSsolve> 
 CNSsolve>!"removing" of water: interaction weight 0 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) (segid $Toppar.prot_segid_$nchain1) weight * 1.0 end 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) 
 CNSsolve>	           ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) weight * 1.0 end 
 CNSsolve>  interaction (attr store5 = 1) (all) weight * 0.0 end 
 CNSsolve>  interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>         end if 
 CNSsolve>         inline @RUN:protocols/waterdock_mini.cns 
 ASSFIL: file waterdock_mini.cns opened.
 CNSsolve>! waterdock_mini.cns 
 CNSsolve>!    Minimize water molecules in solvated docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>  minimize rigid 
 CNSsolve>   eval ($nchain1 = 0) 
 CNSsolve>   while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>            eval($nchain1 = $nchain1 + 1) 
 CNSsolve>            group (segid $Toppar.prot_segid_$nchain1 and not (resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>            translation=true 
 CNSsolve>   end loop nloop1 
 CNSsolve>   for $id in id ((resn WAT or resn HOH or resn TIP*) and name OH2 and (attr store5 ne 1)) loop miniwater 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>   end loop miniwater 
 CNSsolve>   translation=$data.transwater 
 CNSsolve>   nstep 100 
 CNSsolve>   nprint 10 
 CNSsolve>  end 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  !store5 is what is to be removed 
 CNSsolve>  !store4 is used to determine what is at interface 
 CNSsolve>  eval ($surfcutoff = $data.water_surfcutoff) 
 CNSsolve>  do (store4 = 0) (all) 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    do (store4 = store4 + 1) (name oh2 and ((segid $Toppar.prot_segid_$nchain1) around $surfcutoff)) 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  !an interfacial water should have at least store4=2 
 CNSsolve>  do (store4 = 0) (attribute store4 < 2) 
 CNSsolve>  do (store4 = 1) (attribute store4 > 0) 
 CNSsolve>  do (store5 = 1) ((attr store5 = 1) or (name oh2 and (not resn TIP*) and (attr store4 ne 1))) 
 CNSsolve>  do (store5 = 1) (byres (attr store5 = 1)) 
 CNSsolve>  do (store5 = 0) (resn TIP*) 
 CNSsolve> 
 CNSsolve>  !"removing" of water: interaction weight 0 
 CNSsolve>  igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>   eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>   while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) (segid $Toppar.prot_segid_$nchain1) weight * 1.0 end 
 CNSsolve>   end loop nloop1 
 CNSsolve> 
 CNSsolve>   interaction ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) 
 CNSsolve>	           ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) weight * 1.0 end 
 CNSsolve>   interaction (attr store5 = 1) (all) weight * 0.0 end 
 CNSsolve>   interaction (resn DUM) (not resn DUM) weight * 0.0 end 
 CNSsolve>   interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  if ($data.solvate_method eq "restraints") then 
 CNSsolve>   noe reset end 
 CNSsolve>   !read again the NOE data 
 CNSsolve>   @RUN:protocols/read_noes.cns(Iteration=$Iteration; Data=$Data; count=$count) 
 ASSFIL: file read_noes.cns opened.
 CNSsolve>! read_noes.cns 
 CNSsolve>!    Read distance restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(Iteration; Data; count;) 
 CNSsolve> 
 CNSsolve>!NOEs, hbonds 
 CNSsolve>noe 
 CNSsolve>  reset 
 CNSsolve>  nrestraints = 12000000     ! allocate space for NOEs 
 CNSsolve>  ceiling 1000 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>display reading NEWIT:unambig.tbl in iteration &iteration with option &data.unamb_firstit 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if (&data.amb_firstit le &iteration)   then 
 CNSsolve>     evaluate ($filenam0 = "NEWIT:ambig.tbl_" + encode($count)) 
 CNSsolve>     fileexist $filenam0 end 
 CNSsolve>     if ($result eq false) then 
 CNSsolve>       evaluate ($filenam0 = "NEWIT:ambig.tbl") 
 CNSsolve>     end if 
 CNSsolve>     noe class ambi @@$filenam0 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.unamb_firstit le &iteration) then 
 CNSsolve>     noe class dist @@NEWIT:unambig.tbl end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.hbond_firstit le &iteration) then 
 CNSsolve>   if (&data.hbonds_on eq true) then 
 CNSsolve>      noe @@RUN:data/hbonds/hbonds.tbl end 
 CNSsolve>   end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>  averaging  * sum 
 CNSsolve>  potential  * soft 
 CNSsolve>  scale      * 1.0 
 CNSsolve>  sqconstant * 1.0 
 CNSsolve>  sqexponent * 2 
 CNSsolve>  soexponent * 1 
 CNSsolve>  rswitch    * 1.0 
 CNSsolve>  sqoffset   * 0.0 
 CNSsolve>  asymptote  * 2.0 
 CNSsolve>  msoexponent * 1 
 CNSsolve>  masymptote  * -0.1 
 CNSsolve>  mrswitch    * 1.0 
 CNSsolve>  avexpo hbond 20 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>if (&data.waterdock eq true) then 
 CNSsolve> if (&iteration eq 0) then 
 CNSsolve>  if (&data.solvate_method eq "restraints") then 
 CNSsolve>   evaluate ($nchain=0) 
 CNSsolve>   while ($nchain < &data.ncomponents) loop nloop1 
 CNSsolve>    evaluate ($nchain = $nchain + 1) 
 CNSsolve>    evaluate ($watersegname_$nchain="WA" + encode($nchain)) 
 CNSsolve>    noe class amwa end 
 CNSsolve>    for $atom_id in id ((resn WAT or resn HOH or resn TIP*) and name OH2 and segid $watersegname_$nchain and not store5) loop waterrestraint 
 CNSsolve>   noe 
 CNSsolve>    assi (segid $toppar.prot_segid_$nchain and (resn arg or resn glu or resn lys or resn asp or resn tyr) and ((id $atom_id) around &data.water_restraint_cutoff)) 
 CNSsolve>        (id $atom_id) &data.water_restraint_cutoff &data.water_restraint_cutoff 0.0 
 CNSsolve>   end 
 CNSsolve>  end loop waterrestraint 
 CNSsolve>   end loop nloop1 
 CNSsolve>  end if 
 CNSsolve> end if 
 CNSsolve>end if 
 CNSsolve>  end if 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        fix sele=(name OO and not resn XAN) end 
 CNSsolve>        minimize rigid 
 CNSsolve>          eval ($nchain1 = 0) 
 CNSsolve>          while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>            eval($nchain1 = $nchain1 + 1) 
 CNSsolve>            if ($Toppar.fix_origin_$nchain1 eq false) then 
 CNSsolve>              group (segid $Toppar.prot_segid_$nchain1 and not (resn WAT or resn HOH or resn TIP* or name MAP)) 
 CNSsolve>            end if 
 CNSsolve>            translation=true 
 CNSsolve>          end loop nloop1 
 CNSsolve>          for $id in id (segid WA* and (resn WAT or resn HOH or resn TIP*) and name OH2 and (attr store5 ne 1)) loop miniwater 
 CNSsolve>            group (byres(id $id)) 
 CNSsolve>          end loop miniwater 
 CNSsolve>          translation=true 
 CNSsolve>          nstep $ministeps 
 CNSsolve>          nprint 10 
 CNSsolve>        end 
 CNSsolve>        energy end 
 CNSsolve> 
 CNSsolve>        if ($data.waterdock eq true) then 
 CNSsolve>          inline @RUN:protocols/waterdock_mini.cns 
 ASSFIL: file waterdock_mini.cns opened.
 CNSsolve>! waterdock_mini.cns 
 CNSsolve>!    Minimize water molecules in solvated docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>  minimize rigid 
 CNSsolve>   eval ($nchain1 = 0) 
 CNSsolve>   while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>            eval($nchain1 = $nchain1 + 1) 
 CNSsolve>            group (segid $Toppar.prot_segid_$nchain1 and not (resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>            translation=true 
 CNSsolve>   end loop nloop1 
 CNSsolve>   for $id in id ((resn WAT or resn HOH or resn TIP*) and name OH2 and (attr store5 ne 1)) loop miniwater 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>   end loop miniwater 
 CNSsolve>   translation=$data.transwater 
 CNSsolve>   nstep 100 
 CNSsolve>   nprint 10 
 CNSsolve>  end 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  !store5 is what is to be removed 
 CNSsolve>  !store4 is used to determine what is at interface 
 CNSsolve>  eval ($surfcutoff = $data.water_surfcutoff) 
 CNSsolve>  do (store4 = 0) (all) 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    do (store4 = store4 + 1) (name oh2 and ((segid $Toppar.prot_segid_$nchain1) around $surfcutoff)) 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  !an interfacial water should have at least store4=2 
 CNSsolve>  do (store4 = 0) (attribute store4 < 2) 
 CNSsolve>  do (store4 = 1) (attribute store4 > 0) 
 CNSsolve>  do (store5 = 1) ((attr store5 = 1) or (name oh2 and (not resn TIP*) and (attr store4 ne 1))) 
 CNSsolve>  do (store5 = 1) (byres (attr store5 = 1)) 
 CNSsolve>  do (store5 = 0) (resn TIP*) 
 CNSsolve> 
 CNSsolve>  !"removing" of water: interaction weight 0 
 CNSsolve>  igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>   eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>   while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) (segid $Toppar.prot_segid_$nchain1) weight * 1.0 end 
 CNSsolve>   end loop nloop1 
 CNSsolve> 
 CNSsolve>   interaction ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) 
 CNSsolve>	           ((resn WAT or resn HOH or resn TIP*) and (attr store5 ne 1)) weight * 1.0 end 
 CNSsolve>   interaction (attr store5 = 1) (all) weight * 0.0 end 
 CNSsolve>   interaction (resn DUM) (not resn DUM) weight * 0.0 end 
 CNSsolve>   interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  if ($data.solvate_method eq "restraints") then 
 CNSsolve>   noe reset end 
 CNSsolve>   !read again the NOE data 
 CNSsolve>   @RUN:protocols/read_noes.cns(Iteration=$Iteration; Data=$Data; count=$count) 
 ASSFIL: file read_noes.cns opened.
 CNSsolve>! read_noes.cns 
 CNSsolve>!    Read distance restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(Iteration; Data; count;) 
 CNSsolve> 
 CNSsolve>!NOEs, hbonds 
 CNSsolve>noe 
 CNSsolve>  reset 
 CNSsolve>  nrestraints = 12000000     ! allocate space for NOEs 
 CNSsolve>  ceiling 1000 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>display reading NEWIT:unambig.tbl in iteration &iteration with option &data.unamb_firstit 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if (&data.amb_firstit le &iteration)   then 
 CNSsolve>     evaluate ($filenam0 = "NEWIT:ambig.tbl_" + encode($count)) 
 CNSsolve>     fileexist $filenam0 end 
 CNSsolve>     if ($result eq false) then 
 CNSsolve>       evaluate ($filenam0 = "NEWIT:ambig.tbl") 
 CNSsolve>     end if 
 CNSsolve>     noe class ambi @@$filenam0 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.unamb_firstit le &iteration) then 
 CNSsolve>     noe class dist @@NEWIT:unambig.tbl end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.hbond_firstit le &iteration) then 
 CNSsolve>   if (&data.hbonds_on eq true) then 
 CNSsolve>      noe @@RUN:data/hbonds/hbonds.tbl end 
 CNSsolve>   end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>  averaging  * sum 
 CNSsolve>  potential  * soft 
 CNSsolve>  scale      * 1.0 
 CNSsolve>  sqconstant * 1.0 
 CNSsolve>  sqexponent * 2 
 CNSsolve>  soexponent * 1 
 CNSsolve>  rswitch    * 1.0 
 CNSsolve>  sqoffset   * 0.0 
 CNSsolve>  asymptote  * 2.0 
 CNSsolve>  msoexponent * 1 
 CNSsolve>  masymptote  * -0.1 
 CNSsolve>  mrswitch    * 1.0 
 CNSsolve>  avexpo hbond 20 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>if (&data.waterdock eq true) then 
 CNSsolve> if (&iteration eq 0) then 
 CNSsolve>  if (&data.solvate_method eq "restraints") then 
 CNSsolve>   evaluate ($nchain=0) 
 CNSsolve>   while ($nchain < &data.ncomponents) loop nloop1 
 CNSsolve>    evaluate ($nchain = $nchain + 1) 
 CNSsolve>    evaluate ($watersegname_$nchain="WA" + encode($nchain)) 
 CNSsolve>    noe class amwa end 
 CNSsolve>    for $atom_id in id ((resn WAT or resn HOH or resn TIP*) and name OH2 and segid $watersegname_$nchain and not store5) loop waterrestraint 
 CNSsolve>   noe 
 CNSsolve>    assi (segid $toppar.prot_segid_$nchain and (resn arg or resn glu or resn lys or resn asp or resn tyr) and ((id $atom_id) around &data.water_restraint_cutoff)) 
 CNSsolve>        (id $atom_id) &data.water_restraint_cutoff &data.water_restraint_cutoff 0.0 
 CNSsolve>   end 
 CNSsolve>  end loop waterrestraint 
 CNSsolve>   end loop nloop1 
 CNSsolve>  end if 
 CNSsolve> end if 
 CNSsolve>end if 
 CNSsolve>  end if 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>        if ($anisotropy eq true) then 
 CNSsolve>          fix sele=(not all) end 
 CNSsolve>          fix sele=(name OO and not resn XAN) end 
 CNSsolve>          minimize rigid 
 CNSsolve>            for $id in id ((resn ANI or resn DAN or resn XAN) and name OO) loop miniani 
 CNSsolve>              group (byres(id $id)) 
 CNSsolve>              translation=false 
 CNSsolve>            end loop miniani 
 CNSsolve>            translation=false 
 CNSsolve>            nstep 100 
 CNSsolve>            drop 10.0 
 CNSsolve>            nprint 10 
 CNSsolve>          end 
 CNSsolve>          minimize rigid 
 CNSsolve>            eval ($nchain1 = 0) 
 CNSsolve>            while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>              eval($nchain1 = $nchain1 + 1) 
 CNSsolve>              if ($Toppar.fix_origin_$nchain1 eq false) then 
 CNSsolve>                group ((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP) 
 CNSsolve>              end if 
 CNSsolve>              translation=true 
 CNSsolve>            end loop nloop1 
 CNSsolve>            for $id in id ((resn ANI or resn DAN or resn XAN) and name OO) loop miniani 
 CNSsolve>              group (byres(id $id)) 
 CNSsolve>              translation=false 
 CNSsolve>            end loop miniani 
 CNSsolve>            translation=true 
 CNSsolve>            nstep $ministeps 
 CNSsolve>            nprint 10 
 CNSsolve>          end 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>      end if ! ($Saprotocol.rigidtrans eq true) 
 CNSsolve> 
 CNSsolve>      ! centroids based energy should not be part of the $NOE energy 
 CNSsolve>      if ($data.flags.centroids = true) then 
 CNSsolve>          noe scale centroid 0 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      if ($data.flags.em = true) then 
 CNSsolve>          if ($fixmol = false) then 
 CNSsolve>              ! determine the best orientation of the complex in the density 
 CNSsolve>              @RUN:protocols/em_orien_search.cns 
 ASSFIL: file em_orien_search.cns opened.
 CNSsolve>if ($fixmol eq false) then 
 CNSsolve>    ! perform a search to orient the complex properly in the density. 
 CNSsolve>    if ($data.ncomponents = 2) then 
 CNSsolve>        @RUN:protocols/em_rot_search.cns(data=$data; saprotocol=$saprotocol; 
 ASSFIL: file em_rot_search.cns opened.
 CNSsolve>module(Data; 
 MODULE-DECLARATION>       Saprotocol; 
 MODULE-DECLARATION>       Toppar; 
 MODULE-DECLARATION>       ) 
 MODULE-INVOCATION>                toppar=$toppar;) 
 CNSsolve>    {*Module optimizes the orientation of binary systems in the EM-density 
 CNSsolve> 
 CNSsolve>    The orientation is optimized by a fine rotation search of the axis that is 
 CNSsolve>    formed by the line that joins the two centroids. The XREF energy is 
 CNSsolve>    calculated at every orientation to differentiate. 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    Data 
 CNSsolve>        The Data object 
 CNSsolve> 
 CNSsolve>    Toppar 
 CNSsolve>        The Toppar object 
 CNSsolve> 
 CNSsolve>    Notes 
 CNSsolve>    ----- 
 CNSsolve>    The module uses the COMP coordinate set 
 CNSsolve>    The MAIN coordinate set are set to the orientation with the lowest XREF energy 
 CNSsolve> 
 CNSsolve>    *} 
 CNSsolve> 
 CNSsolve>    eval($time0 = $CPU) 
 CNSsolve> 
 CNSsolve>    ! Copy main coordinates to the comp set 
 CNSsolve>    coor copy selection=(all) end 
 CNSsolve> 
 CNSsolve>    ! Get rotation axis used for search.  ! It is the line that is made by 
 CNSsolve>    ! joining the two centroids 
 CNSsolve>    show (x) (name DUM and segid &Toppar.prot_segid_1) 
 CNSsolve>    eval($x1 = $result) 
 CNSsolve>    show (x) (name DUM and segid &Toppar.prot_segid_2) 
 CNSsolve>    eval($x2 = $result) 
 CNSsolve>    eval($rot_axis.x = $x1 - $x2) 
 CNSsolve> 
 CNSsolve>    show (y) (name DUM and segid &Toppar.prot_segid_1) 
 CNSsolve>    eval($y1 = $result) 
 CNSsolve>    show (y) (name DUM and segid &Toppar.prot_segid_2) 
 CNSsolve>    eval($y2 = $result) 
 CNSsolve>    eval($rot_axis.y = $y1 - $y2) 
 CNSsolve> 
 CNSsolve>    show (z) (name DUM and segid &Toppar.prot_segid_1) 
 CNSsolve>    eval($z1 = $result) 
 CNSsolve>    show (z) (name DUM and segid &Toppar.prot_segid_2) 
 CNSsolve>    eval($z2 = $result) 
 CNSsolve>    eval($rot_axis.z = $z1 - $z2) 
 CNSsolve> 
 CNSsolve>    ! Set the XREF flag to calculate the cross correlation potential in CNS 
 CNSsolve>    flags include xref end 
 CNSsolve>    ! Initialize the search values 
 CNSsolve>    eval($angle = 0) 
 CNSsolve>    eval($bestangle = 0) 
 CNSsolve>    eval($anglestep = 6) 
 CNSsolve>    eval($best_fit_energy = 9999) 
 CNSsolve> 
 CNSsolve>    while ($angle < 360.0) loop loopsearch 
 CNSsolve> 
 CNSsolve>        ! Rotate the system around the axis that is formed 
 CNSsolve>        ! by the line created by joining the two centroids. 
 CNSsolve>        coor rotate 
 CNSsolve>             center=($x1 $y1 $z1) 
 CNSsolve>             selection=(not name MAP) 
 CNSsolve>             axis ($rot_axis.x $rot_axis.y $rot_axis.z) $angle 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! Calculate the XREF energy 
 CNSsolve>        energy end 
 CNSsolve> 
 CNSsolve>        ! XREF is internally calculated by CNS 
 CNSsolve>        if ($XREF < $best_fit_energy) then 
 CNSsolve>            ! Update optimal parameters 
 CNSsolve>            eval($best_fit_energy = $XREF) 
 CNSsolve>            eval($bestangle = $angle) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        eval($angle = $angle + $anglestep) 
 CNSsolve> 
 CNSsolve>        ! Copy the original locations to the main coordinate set 
 CNSsolve>        coor swap end 
 CNSsolve>        coor copy end 
 CNSsolve> 
 CNSsolve>    end loop loopsearch 
 CNSsolve> 
 CNSsolve>    ! Reorient the original coordinates to the best fit values 
 CNSsolve>    coor rotate 
 CNSsolve>        center=($x1 $y1 $z1) 
 CNSsolve>        selection=(not name MAP) 
 CNSsolve>        axis ($rot_axis.x $rot_axis.y $rot_axis.z) $bestangle 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! Calculate the energy to check 
 CNSsolve>    energy end 
 CNSsolve> 
 CNSsolve>    ! Turn off the XREF energy term again 
 CNSsolve>    flags exclude xref end 
 CNSsolve> 
 CNSsolve>    ! Show the time required for the search 
 CNSsolve>    eval($time0 = $CPU - $time0) 
 CNSsolve>    display Time used for rotational search: $time0 s 
 CNSsolve>    elseif ($data.flags.sym = true) then 
 CNSsolve>        ! the search for symmetry only works for C-symmetry. Other symmetries 
 CNSsolve>        ! will break! 
 CNSsolve>        @RUN:protocols/em_sym_search.cns(data=$data; saprotocol=$saprotocol; 
 ASSFIL: file em_sym_search.cns opened.
 CNSsolve>module (Data; 
 MODULE-DECLARATION>        Saprotocol; 
 MODULE-DECLARATION>        Toppar;) 
 MODULE-INVOCATION>                toppar=$toppar;) 
 CNSsolve>    {*Module determines the correct orientation for symmetric complexes 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    Data 
 CNSsolve>        Data object 
 CNSsolve> 
 CNSsolve>    Saprotocol 
 CNSsolve>        Saprotocol object 
 CNSsolve> 
 CNSsolve>    Toppar 
 CNSsolve>        Toppar object 
 CNSsolve> 
 CNSsolve>    Notes 
 CNSsolve>    ----- 
 CNSsolve>    Only C-symmetry is supported. 
 CNSsolve>    Module uses the COMP coordinate set. 
 CNSsolve>    Module might change the MAIN coordinate set 
 CNSsolve>    *} 
 CNSsolve> 
 CNSsolve>    ! get the local cross correlation of the current orientation 
 CNSsolve>    @RUN:protocols/em_calc_lcc.cns(Toppar=&Toppar; 
 ASSFIL: file em_calc_lcc.cns opened.
 CNSsolve>module (Toppar; 
 MODULE-DECLARATION>        Data; 
 MODULE-DECLARATION>        Saprotocol; 
 MODULE-DECLARATION>        lcc; 
 MODULE-DECLARATION>        ) 
 MODULE-INVOCATION>                                   Data=&Data; 
 MODULE-INVOCATION>                                   Saprotocol=&Saprotocol; 
 MODULE-INVOCATION>                                   lcc=$lcc; 
 MODULE-INVOCATION>                                   ) 
 CNSsolve>    {*The module calculates the local cross-correlation coefficient (lcc) between 
 CNSsolve>    the targetmap and the atomic model. 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    Toppar 
 CNSsolve>	Toppar object 
 CNSsolve> 
 CNSsolve>    Data 
 CNSsolve>	Data object 
 CNSsolve> 
 CNSsolve>    Saprotocol 
 CNSsolve>	Saprotocol object 
 CNSsolve> 
 CNSsolve>    lcc : float (output) 
 CNSsolve>	The local cross correlation value in the interval [-1, 1] 
 CNSsolve> 
 CNSsolve>    Examples 
 CNSsolve>    -------- 
 CNSsolve>    >>> ! lcc calculation requires that the cryoEM data is read 
 CNSsolve>    >>> @RUN:protocols/em_read_data.cns(Data=$Data;) 
 CNSsolve>    >>> @RUN:protocols/em_calc_lcc.cns(Toppar=$Toppar; Data=$Data; Saprotocol=$Saprotocol; 
 CNSsolve>    >>>                                lcc=$lcc;) 
 CNSsolve>    >>> display Local cross correlation-coefficient: $lcc 
 CNSsolve> 
 CNSsolve>    Notes 
 CNSsolve>    ----- 
 CNSsolve>    This module uses the "b" atomobject. 
 CNSsolve>    *} 
 CNSsolve> 
 CNSsolve>    ! get the time 
 CNSsolve>    evaluate($time0 = $CPU) 
 CNSsolve> 
 CNSsolve>    ! check whether the arrays that are required for the lcc calculation exist 
 CNSsolve>    xray 
 CNSsolve>        query name=modelmap domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmap domain=real end 
 CNSsolve>            do (modelmap = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=map_tmp domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=map_tmp domain=real end 
 CNSsolve>            do (map_tmp = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=modelmask domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmask domain=real end 
 CNSsolve>            do (modelmask = 0) (all) 
 CNSsolve>        end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    do (b = 0) (all) 
 CNSsolve>    evaluate($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < &Data.ncomponents) loop nloop1 
 CNSsolve>        evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>        !if ($Saprotocol.init_placement.prot_segid_$nchain1.fixed = False) then 
 CNSsolve>            do (b = 1) (segid &Toppar.prot_segid_$nchain1 and not resn DUM) 
 CNSsolve>        !end if 
 CNSsolve>    end loop nloop1 
 CNSsolve> 
 CNSsolve>    ! Create the modelmap up to a certain resolution. We need to do 
 CNSsolve>    ! this via reciprocal space, by first creating the structure factors 
 CNSsolve>    ! and afters performing an inverse FFT to get the density. 
 CNSsolve>    xray 
 CNSsolve>        predict 
 CNSsolve>            mode=reciprocal 
 CNSsolve>            to=fcalc 
 CNSsolve>            atomselectiom=(attr b > 0) 
 CNSsolve>            selection=(all) 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        do (modelmap=real(ft(fcalc))) (all) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! create mask around the model 
 CNSsolve>    xray 
 CNSsolve>        mask 
 CNSsolve>            to=modelmask 
 CNSsolve>            selection=(attr b > 0) 
 CNSsolve>            averaging_mode=False 
 CNSsolve>            mode=sigma 
 CNSsolve>            proberadius=3 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! normalize modelmap and map within the modelmask 
 CNSsolve>        show average(modelmap) (modelmask=0) 
 CNSsolve>        evaluate($ave_modelmap = $RESULT) 
 CNSsolve>        do (modelmap = modelmap - $ave_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(modelmap*modelmap) (modelmask=0) 
 CNSsolve>        evaluate($std_modelmap = sqrt($RESULT)) 
 CNSsolve>        do (modelmap = modelmap / $std_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        ! normalize map within range of modelmask 
 CNSsolve>        show average(map) (modelmask=0) 
 CNSsolve>        evaluate($ave_map = $RESULT) 
 CNSsolve>        do (map_tmp = map - $ave_map) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(map_tmp*map_tmp) (modelmask=0) 
 CNSsolve>        evaluate($std_map = sqrt($RESULT)) 
 CNSsolve>        ! check if the std of the targetmap is larger than zero, else lcc is undefined. 
 CNSsolve>        if ($std_map > 0) then 
 CNSsolve>            do (map_tmp = map_tmp / $std_map) (modelmask=0) 
 CNSsolve>            ! now calculate the local cross correlation coefficient 
 CNSsolve>            show sum(modelmap * map_tmp) (modelmask=0) 
 CNSsolve>            evaluate(&lcc = $RESULT) 
 CNSsolve>        else 
 CNSsolve>            evaluate(&lcc = 0) 
 CNSsolve>       end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    evaluate($time0 = $CPU - $time0) 
 CNSsolve>    display Local cross correlation coefficient: &lcc 
 CNSsolve>    display Time used for local cross correlation calculation: $time0 s 
 CNSsolve> 
 CNSsolve>    ! calculate the mid point of the centroids 
 CNSsolve>    show average(x) (name MAP) 
 CNSsolve>    evaluate($center.x = $result) 
 CNSsolve>    show average(y) (name MAP) 
 CNSsolve>    evaluate($center.y = $result) 
 CNSsolve>    show average(z) (name MAP) 
 CNSsolve>    evaluate($center.z = $result) 
 CNSsolve> 
 CNSsolve>    ! determine the vector going from the first centroid to the midpoint 
 CNSsolve>    ! of the centroids. this represents the axis of rotation 
 CNSsolve>    show (x) (name MAP and segid &Toppar.prot_segid_1) 
 CNSsolve>    evaluate($map.x = $result) 
 CNSsolve>    show (y) (name MAP and segid &Toppar.prot_segid_1) 
 CNSsolve>    evaluate($map.y = $result) 
 CNSsolve>    show (z) (name MAP and segid &Toppar.prot_segid_1) 
 CNSsolve>    evaluate($map.z = $result) 
 CNSsolve> 
 CNSsolve>    evaluate($rot_axis.x = $center.x - $map.x) 
 CNSsolve>    evaluate($rot_axis.y = $center.y - $map.y) 
 CNSsolve>    evaluate($rot_axis.z = $center.z - $map.z) 
 CNSsolve> 
 CNSsolve>    ! store the current coordinates in the COMP coordinate set 
 CNSsolve>    coor copy selection=(all) end 
 CNSsolve> 
 CNSsolve>    ! rotate around the previous determined axis with 180 degrees. 
 CNSsolve>    coor rotate 
 CNSsolve>        center=($center.x $center.y $center.z) 
 CNSsolve>        selection=(not name MAP) 
 CNSsolve>        axis ($rot_axis.x $rot_axis.y $rot_axis.z) 180.0 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! calculate the local cross correlation for the rotated orientation 
 CNSsolve>    @RUN:protocols/em_calc_lcc.cns(Toppar=&Toppar; 
 ASSFIL: file em_calc_lcc.cns opened.
 CNSsolve>module (Toppar; 
 MODULE-DECLARATION>        Data; 
 MODULE-DECLARATION>        Saprotocol; 
 MODULE-DECLARATION>        lcc; 
 MODULE-DECLARATION>        ) 
 MODULE-INVOCATION>                                   Data=&Data; 
 MODULE-INVOCATION>                                   Saprotocol=&Saprotocol; 
 MODULE-INVOCATION>                                   lcc=$newlcc; 
 MODULE-INVOCATION>                                   ) 
 CNSsolve>    {*The module calculates the local cross-correlation coefficient (lcc) between 
 CNSsolve>    the targetmap and the atomic model. 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    Toppar 
 CNSsolve>	Toppar object 
 CNSsolve> 
 CNSsolve>    Data 
 CNSsolve>	Data object 
 CNSsolve> 
 CNSsolve>    Saprotocol 
 CNSsolve>	Saprotocol object 
 CNSsolve> 
 CNSsolve>    lcc : float (output) 
 CNSsolve>	The local cross correlation value in the interval [-1, 1] 
 CNSsolve> 
 CNSsolve>    Examples 
 CNSsolve>    -------- 
 CNSsolve>    >>> ! lcc calculation requires that the cryoEM data is read 
 CNSsolve>    >>> @RUN:protocols/em_read_data.cns(Data=$Data;) 
 CNSsolve>    >>> @RUN:protocols/em_calc_lcc.cns(Toppar=$Toppar; Data=$Data; Saprotocol=$Saprotocol; 
 CNSsolve>    >>>                                lcc=$lcc;) 
 CNSsolve>    >>> display Local cross correlation-coefficient: $lcc 
 CNSsolve> 
 CNSsolve>    Notes 
 CNSsolve>    ----- 
 CNSsolve>    This module uses the "b" atomobject. 
 CNSsolve>    *} 
 CNSsolve> 
 CNSsolve>    ! get the time 
 CNSsolve>    evaluate($time0 = $CPU) 
 CNSsolve> 
 CNSsolve>    ! check whether the arrays that are required for the lcc calculation exist 
 CNSsolve>    xray 
 CNSsolve>        query name=modelmap domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmap domain=real end 
 CNSsolve>            do (modelmap = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=map_tmp domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=map_tmp domain=real end 
 CNSsolve>            do (map_tmp = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=modelmask domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmask domain=real end 
 CNSsolve>            do (modelmask = 0) (all) 
 CNSsolve>        end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    do (b = 0) (all) 
 CNSsolve>    evaluate($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < &Data.ncomponents) loop nloop1 
 CNSsolve>        evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>        !if ($Saprotocol.init_placement.prot_segid_$nchain1.fixed = False) then 
 CNSsolve>            do (b = 1) (segid &Toppar.prot_segid_$nchain1 and not resn DUM) 
 CNSsolve>        !end if 
 CNSsolve>    end loop nloop1 
 CNSsolve> 
 CNSsolve>    ! Create the modelmap up to a certain resolution. We need to do 
 CNSsolve>    ! this via reciprocal space, by first creating the structure factors 
 CNSsolve>    ! and afters performing an inverse FFT to get the density. 
 CNSsolve>    xray 
 CNSsolve>        predict 
 CNSsolve>            mode=reciprocal 
 CNSsolve>            to=fcalc 
 CNSsolve>            atomselectiom=(attr b > 0) 
 CNSsolve>            selection=(all) 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        do (modelmap=real(ft(fcalc))) (all) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! create mask around the model 
 CNSsolve>    xray 
 CNSsolve>        mask 
 CNSsolve>            to=modelmask 
 CNSsolve>            selection=(attr b > 0) 
 CNSsolve>            averaging_mode=False 
 CNSsolve>            mode=sigma 
 CNSsolve>            proberadius=3 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! normalize modelmap and map within the modelmask 
 CNSsolve>        show average(modelmap) (modelmask=0) 
 CNSsolve>        evaluate($ave_modelmap = $RESULT) 
 CNSsolve>        do (modelmap = modelmap - $ave_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(modelmap*modelmap) (modelmask=0) 
 CNSsolve>        evaluate($std_modelmap = sqrt($RESULT)) 
 CNSsolve>        do (modelmap = modelmap / $std_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        ! normalize map within range of modelmask 
 CNSsolve>        show average(map) (modelmask=0) 
 CNSsolve>        evaluate($ave_map = $RESULT) 
 CNSsolve>        do (map_tmp = map - $ave_map) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(map_tmp*map_tmp) (modelmask=0) 
 CNSsolve>        evaluate($std_map = sqrt($RESULT)) 
 CNSsolve>        ! check if the std of the targetmap is larger than zero, else lcc is undefined. 
 CNSsolve>        if ($std_map > 0) then 
 CNSsolve>            do (map_tmp = map_tmp / $std_map) (modelmask=0) 
 CNSsolve>            ! now calculate the local cross correlation coefficient 
 CNSsolve>            show sum(modelmap * map_tmp) (modelmask=0) 
 CNSsolve>            evaluate(&lcc = $RESULT) 
 CNSsolve>        else 
 CNSsolve>            evaluate(&lcc = 0) 
 CNSsolve>       end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    evaluate($time0 = $CPU - $time0) 
 CNSsolve>    display Local cross correlation coefficient: &lcc 
 CNSsolve>    display Time used for local cross correlation calculation: $time0 s 
 CNSsolve> 
 CNSsolve>    ! if the lcc of the initial orientation is better, swap the COMP 
 CNSsolve>    ! coordinate set to the MAIN coordinate set 
 CNSsolve>    if ($lcc > $newlcc) then 
 CNSsolve>        coor swap selection=(all) end 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! do a final rigid body energy minimization directly against the EM 
 CNSsolve>! density, but without the centroid restraints 
 CNSsolve>flags include xref end 
 CNSsolve>minimize rigid 
 CNSsolve>    eval($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>        eval($nchain1 = $nchain1 + 1) 
 CNSsolve>        if ($Toppar.fix_origin_$nchain1 eq false) then 
 CNSsolve>            group ((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP) 
 CNSsolve>        end if 
 CNSsolve>        translation=true 
 CNSsolve>    end loop nloop1 
 CNSsolve>    nstep 250 
 CNSsolve>    nprint 10 
 CNSsolve>end 
 CNSsolve>flags exclude xref end 
 CNSsolve>          end if 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      inline @RUN:protocols/bestener.cns 
 ASSFIL: file bestener.cns opened.
 CNSsolve>! bestener.cns 
 CNSsolve>!   Store best score model from rigid-body dokcing (it0) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>    eval ($kinter = 1.0) 
 CNSsolve>    @RUN:protocols/scale_inter_final.cns 
 ASSFIL: file scale_inter_final.cns opened.
 CNSsolve>! scale_inter_final.cns 
 CNSsolve>!   Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not 
 CNSsolve>                   (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA or resn DPP or resn PCW or resn PEE)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not 
 CNSsolve>                   (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA or resn DPP or resn PCW or resn PEE)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DUM) (resn DUM) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn SHA) (resn SHA) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>    evaluate ($unamb_scale = $Data.unamb_cool3) 
 CNSsolve>    evaluate ($ambig_scale = $Data.amb_cool3) 
 CNSsolve>    evaluate ($hbond_scale = $Data.hbond_cool3) 
 CNSsolve> 
 CNSsolve>    noe 
 CNSsolve>      scale dist $unamb_scale 
 CNSsolve>      scale ambi $ambig_scale 
 CNSsolve>      scale hbon $hbond_scale 
 CNSsolve>      scale symm 0.0 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    evaluate ($nrdc=1) 
 CNSsolve>    while ($nrdc <= $data.numrdc) loop rdc 
 CNSsolve>      evaluate ($cln = "rd" + encode($nrdc) ) 
 CNSsolve>      if ($Data.flags.sani eq true) then 
 CNSsolve>        sani class $cln force $Data.rdc_cool3_$nrdc end 
 CNSsolve>      end if 
 CNSsolve>      if ($Data.flags.xrdc eq true) then 
 CNSsolve>        xrdc class $cln force $Data.rdc_cool3_$nrdc end 
 CNSsolve>      end if 
 CNSsolve>      if ($Data.flags.vean eq true) then 
 CNSsolve>        vean class $cln force $Data.fin_bor_cool3_$nrdc $Data.fin_cen_cool3_$nrdc end 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($nrdc = $nrdc + 1) 
 CNSsolve>    end loop rdc 
 CNSsolve> 
 CNSsolve>    evaluate ($ndani=1) 
 CNSsolve>    while ($ndani <= $data.numdani) loop dani 
 CNSsolve>      evaluate ($cln = "da" + encode($ndani) ) 
 CNSsolve>      if ($Data.flags.dani eq true) then 
 CNSsolve>        dani class $cln force $Data.dan_cool3_$ndani end 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($ndani = $ndani + 1) 
 CNSsolve>    end loop dani 
 CNSsolve> 
 CNSsolve>    evaluate ($npcs=1) 
 CNSsolve>    while ($npcs <= $data.numpcs) loop pcs 
 CNSsolve>      evaluate ($cln = "pc" + encode($ndani) ) 
 CNSsolve>      if ($Data.flags.xpcs eq true) then 
 CNSsolve>        xpcs class $cln force $Data.pcs_cool3_$npcs end 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($npcs = $npcs + 1) 
 CNSsolve>    end loop pcs 
 CNSsolve> 
 CNSsolve>    evaluate ($ener = 0) 
 CNSsolve>    evaluate ($vdw  = 0) 
 CNSsolve>    evaluate ($elec = 0) 
 CNSsolve>    evaluate ($noe  = 0) 
 CNSsolve>    evaluate ($coll = 0) 
 CNSsolve>    evaluate ($eair = 0) 
 CNSsolve>    evaluate ($cdih = 0) 
 CNSsolve>    evaluate ($vean = 0) 
 CNSsolve>    evaluate ($sani = 0) 
 CNSsolve>    evaluate ($xrdc = 0) 
 CNSsolve>    evaluate ($xpcs = 0) 
 CNSsolve>    evaluate ($dani = 0) 
 CNSsolve>    evaluate ($esym = 0) 
 CNSsolve>    evaluate ($zhar = 0) 
 CNSsolve>    evaluate ($bsa  = 0) 
 CNSsolve>    evaluate ($desolv = 0.0) 
 CNSsolve>    evaluate ($lcc = 0.0) 
 CNSsolve> 
 CNSsolve>    energy end 
 CNSsolve>    evaluate ($eair = $noe) 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.sym eq true) then 
 CNSsolve>      noe 
 CNSsolve>        scale * 0.0 
 CNSsolve>        scale symm $Data.ksym 
 CNSsolve>      end 
 CNSsolve>      energy end 
 CNSsolve>      evaluate ($esym = $noe) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($SaProtocol.rigidtrans eq true) then 
 CNSsolve>      inline @RUN:protocols/bsa.cns 
 ASSFIL: file bsa.cns opened.
 CNSsolve> 
 CNSsolve>!   Calculate buried surface area and desolvation energy of the complex 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2016 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{====>} {* define ASA-based solvation parameters *} 
 CNSsolve>inline @RUN:protocols/def_solv_param.cns 
 ASSFIL: file def_solv_param.cns opened.
 CNSsolve>! def_solv_param.cns 
 CNSsolve>!    Define atomic solvation parameters taken from Fernandez-Recio et al. JMB 335:843 (2004) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($arofac = 6.26) 
 CNSsolve>evaluate ($alifac = 1.27) 
 CNSsolve>evaluate ($polfac = 2.30) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>do (store1 =  0.0000) (all) 
 CNSsolve>do (store1 =  0.0151 * $alifac) (name C*) 
 CNSsolve>do (store1 =  0.0176 * $arofac) ((name CG* or name CD* or name CE* or name CH* or name CZ*) and (resn PHE or resn TYR or resn HIS or resn TRP)) 
 CNSsolve>do (store1 = -0.0170 * $polfac) (name N*) 
 CNSsolve>do (store1 = -0.0548 * $polfac) (name NT* or (name NZ* and resn LYS)) 
 CNSsolve>do (store1 = -0.0273 * $polfac) (name NH* and resn ARG) 
 CNSsolve>do (store1 = -0.0136 * $polfac) (name O*) 
 CNSsolve>do (store1 = -0.0185 * $polfac) (name OG* or name OH) 
 CNSsolve>do (store1 = -0.0299 * $polfac) ((name OD* and resn ASP) or (name OE* and resn GLU)) 
 CNSsolve>do (store1 =  0.0112 * $polfac) (name S*) 
 CNSsolve>do (store1 =  0.0022 * $polfac) ((name S* and attr charge = -0.3) or (name SD and resn MET)) 
 CNSsolve>do (store1 =  0.0000) (name SHA) 
 CNSsolve> 
 CNSsolve>! 
 CNSsolve>! CG parameters matched from the original terms 
 CNSsolve>! 
 CNSsolve>!                  Edesolv_aa 
 CNSsolve>! ASP_cg = _________________________ 
 CNSsolve>!                    ASA_cg 
 CNSsolve>! 
 CNSsolve>! ASA_cg and Edesol_aa calculated on a GGXGG peptide 
 CNSsolve>! accuracy=0.0025, rh2o=1.4, delete H, sele=(resn X) 
 CNSsolve>! 
 CNSsolve>! e.g. BB bead alanine 
 CNSsolve>! 
 CNSsolve>! BB = CA + C + N + O 
 CNSsolve>! ASA_cg = 176.4940 
 CNSsolve>! Edesolv_aa = -1.8889 
 CNSsolve>! 
 CNSsolve>! ASP_cg = -0.0107 
 CNSsolve>! 
 CNSsolve>! Charleen Don (2012), JR (2014), Jorge Roel (2017) 
 CNSsolve>! 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store1 =  0.0000) (name BB or name SC*) 
 CNSsolve>! Backbone beads 
 CNSsolve>do (store1 = -0.0107) (name BB and resn ALA) 
 CNSsolve>do (store1 = -0.0089) (name BB and resn GLY) 
 CNSsolve>do (store1 = -0.0153) (name BB and resn ILE) 
 CNSsolve>do (store1 = -0.0158) (name BB and resn VAL) 
 CNSsolve>do (store1 = -0.0046) (name BB and resn PRO) 
 CNSsolve>do (store1 = -0.0137) (name BB and resn ASN) 
 CNSsolve>do (store1 = -0.0147) (name BB and resn GLN) 
 CNSsolve>do (store1 = -0.0165) (name BB and resn THR) 
 CNSsolve>do (store1 = -0.0154) (name BB and resn SER) 
 CNSsolve>do (store1 = -0.0130) (name BB and resn MET) 
 CNSsolve>do (store1 = -0.0167) (name BB and resn CYS) 
 CNSsolve>do (store1 = -0.0126) (name BB and resn PHE) 
 CNSsolve>do (store1 = -0.0134) (name BB and resn TYR) 
 CNSsolve>do (store1 = -0.0134) (name BB and resn TRP) 
 CNSsolve>do (store1 = -0.0169) (name BB and resn ASP) 
 CNSsolve>do (store1 = -0.0150) (name BB and resn GLU) 
 CNSsolve>do (store1 = -0.0155) (name BB and resn HIS) 
 CNSsolve>do (store1 = -0.0163) (name BB and resn LYS) 
 CNSsolve>do (store1 = -0.0162) (name BB and resn ARG) 
 CNSsolve> 
 CNSsolve>! Side-chain beads 
 CNSsolve>!do (store1 =  0.0000) (name SC* and resn ALA) 
 CNSsolve>!do (store1 =  0.0000) (name SC* and resn GLY) 
 CNSsolve>do (store1 =  0.0255) (name SC* and resn ILE) 
 CNSsolve>do (store1 =  0.0222) (name SC* and resn VAL) 
 CNSsolve>do (store1 =  0.0230) (name SC* and resn PRO) 
 CNSsolve>do (store1 = -0.0192) (name SC* and resn ASN) 
 CNSsolve>do (store1 = -0.0135) (name SC* and resn GLN) 
 CNSsolve>do (store1 = -0.0009) (name SC* and resn THR) 
 CNSsolve>do (store1 = -0.0056) (name SC* and resn SER) 
 CNSsolve>do (store1 =  0.0202) (name SC* and resn MET) 
 CNSsolve>do (store1 =  0.0201) (name SC* and resn CYS) 
 CNSsolve>do (store1 =  0.1005) (name SC* and resn PHE) 
 CNSsolve>do (store1 =  0.0669) (name SC* and resn TYR) 
 CNSsolve>do (store1 =  0.0872) (name SC* and resn TRP) 
 CNSsolve>do (store1 = -0.0360) (name SC* and resn ASP) 
 CNSsolve>do (store1 = -0.0301) (name SC* and resn GLU) 
 CNSsolve>do (store1 =  0.0501) (name SC* and resn HIS) 
 CNSsolve>do (store1 = -0.0210) (name SC* and resn LYS) 
 CNSsolve>do (store1 = -0.0229) (name SC* and resn ARG) 
 CNSsolve> 
 CNSsolve>! Fake beads 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn ASN) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn GLN) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn SER) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn THR) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn ARG) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn LYS) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn GLU) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn ASP) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{====>} {* buried surface area and desolvation of single chains *} 
 CNSsolve>evaluate ($nchain1 = 0) 
 CNSsolve>evaluate ($saafree = 0) 
 CNSsolve>evaluate ($esolfree = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 CNSsolve>  {====>} {* buried surface area and desolvation*} 
 CNSsolve>  do (rmsd = 0) (all) 
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) end 
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 CNSsolve>  do (store2 = rmsd * store1) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>  show sum (store2) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>  evaluate ($esolfree = $esolfree + $result) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>{====>} {* buried surface area and desolvation of complex *} 
 CNSsolve>do (rmsd = 0) (all) 
 CNSsolve>do (store2 = 0) (all) 
 CNSsolve>surface mode=access accu=0.075 rh2o=1.4 sele=(not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) end 
 CNSsolve>show sum (rmsd) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>evaluate ($satot = $result) 
 CNSsolve>do (store2 = rmsd * store1) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>show sum (store2) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>evaluate ($esolcplx = $result) 
 CNSsolve>evaluate ($saburied = $saafree - $satot) 
 CNSsolve>! minimum BSA value set to 15 (one H atom would have SASA of 12.56 A**2) 
 CNSsolve>if ($saburied < 15) then 
 CNSsolve>  evaluate ($saburied = -999999) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($edesolv = $esolcplx - $esolfree) 
 CNSsolve> 
 CNSsolve>if ($data.ncomponents eq 1) then 
 CNSsolve>  evaluate ($bsa = 0) 
 CNSsolve>  evaluate ($desolv = 0) 
 CNSsolve>end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    ! get the local cross-correlation for cryo-EM data 
 CNSsolve>    if ($data.flags.em = true) then 
 CNSsolve>        @RUN:protocols/em_calc_lcc.cns(Toppar=$toppar; Data=$data; Saprotocol=$saprotocol; lcc=$lcc;) 
 ASSFIL: file em_calc_lcc.cns opened.
 CNSsolve>module (Toppar; 
 MODULE-DECLARATION>        Data; 
 MODULE-DECLARATION>        Saprotocol; 
 MODULE-DECLARATION>        lcc; 
 MODULE-DECLARATION>        ) 
 CNSsolve>    {*The module calculates the local cross-correlation coefficient (lcc) between 
 CNSsolve>    the targetmap and the atomic model. 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    Toppar 
 CNSsolve>	Toppar object 
 CNSsolve> 
 CNSsolve>    Data 
 CNSsolve>	Data object 
 CNSsolve> 
 CNSsolve>    Saprotocol 
 CNSsolve>	Saprotocol object 
 CNSsolve> 
 CNSsolve>    lcc : float (output) 
 CNSsolve>	The local cross correlation value in the interval [-1, 1] 
 CNSsolve> 
 CNSsolve>    Examples 
 CNSsolve>    -------- 
 CNSsolve>    >>> ! lcc calculation requires that the cryoEM data is read 
 CNSsolve>    >>> @RUN:protocols/em_read_data.cns(Data=$Data;) 
 CNSsolve>    >>> @RUN:protocols/em_calc_lcc.cns(Toppar=$Toppar; Data=$Data; Saprotocol=$Saprotocol; 
 CNSsolve>    >>>                                lcc=$lcc;) 
 CNSsolve>    >>> display Local cross correlation-coefficient: $lcc 
 CNSsolve> 
 CNSsolve>    Notes 
 CNSsolve>    ----- 
 CNSsolve>    This module uses the "b" atomobject. 
 CNSsolve>    *} 
 CNSsolve> 
 CNSsolve>    ! get the time 
 CNSsolve>    evaluate($time0 = $CPU) 
 CNSsolve> 
 CNSsolve>    ! check whether the arrays that are required for the lcc calculation exist 
 CNSsolve>    xray 
 CNSsolve>        query name=modelmap domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmap domain=real end 
 CNSsolve>            do (modelmap = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=map_tmp domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=map_tmp domain=real end 
 CNSsolve>            do (map_tmp = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=modelmask domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmask domain=real end 
 CNSsolve>            do (modelmask = 0) (all) 
 CNSsolve>        end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    do (b = 0) (all) 
 CNSsolve>    evaluate($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < &Data.ncomponents) loop nloop1 
 CNSsolve>        evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>        !if ($Saprotocol.init_placement.prot_segid_$nchain1.fixed = False) then 
 CNSsolve>            do (b = 1) (segid &Toppar.prot_segid_$nchain1 and not resn DUM) 
 CNSsolve>        !end if 
 CNSsolve>    end loop nloop1 
 CNSsolve> 
 CNSsolve>    ! Create the modelmap up to a certain resolution. We need to do 
 CNSsolve>    ! this via reciprocal space, by first creating the structure factors 
 CNSsolve>    ! and afters performing an inverse FFT to get the density. 
 CNSsolve>    xray 
 CNSsolve>        predict 
 CNSsolve>            mode=reciprocal 
 CNSsolve>            to=fcalc 
 CNSsolve>            atomselectiom=(attr b > 0) 
 CNSsolve>            selection=(all) 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        do (modelmap=real(ft(fcalc))) (all) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! create mask around the model 
 CNSsolve>    xray 
 CNSsolve>        mask 
 CNSsolve>            to=modelmask 
 CNSsolve>            selection=(attr b > 0) 
 CNSsolve>            averaging_mode=False 
 CNSsolve>            mode=sigma 
 CNSsolve>            proberadius=3 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! normalize modelmap and map within the modelmask 
 CNSsolve>        show average(modelmap) (modelmask=0) 
 CNSsolve>        evaluate($ave_modelmap = $RESULT) 
 CNSsolve>        do (modelmap = modelmap - $ave_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(modelmap*modelmap) (modelmask=0) 
 CNSsolve>        evaluate($std_modelmap = sqrt($RESULT)) 
 CNSsolve>        do (modelmap = modelmap / $std_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        ! normalize map within range of modelmask 
 CNSsolve>        show average(map) (modelmask=0) 
 CNSsolve>        evaluate($ave_map = $RESULT) 
 CNSsolve>        do (map_tmp = map - $ave_map) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(map_tmp*map_tmp) (modelmask=0) 
 CNSsolve>        evaluate($std_map = sqrt($RESULT)) 
 CNSsolve>        ! check if the std of the targetmap is larger than zero, else lcc is undefined. 
 CNSsolve>        if ($std_map > 0) then 
 CNSsolve>            do (map_tmp = map_tmp / $std_map) (modelmask=0) 
 CNSsolve>            ! now calculate the local cross correlation coefficient 
 CNSsolve>            show sum(modelmap * map_tmp) (modelmask=0) 
 CNSsolve>            evaluate(&lcc = $RESULT) 
 CNSsolve>        else 
 CNSsolve>            evaluate(&lcc = 0) 
 CNSsolve>       end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    evaluate($time0 = $CPU - $time0) 
 CNSsolve>    display Local cross correlation coefficient: &lcc 
 CNSsolve>    display Time used for local cross correlation calculation: $time0 s 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    evaluate ($etot = $iterations.w_vdw  * $vdw) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_elec * $elec) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_dist * $eair) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_rg *   $coll) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_cdih * $cdih) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_sani * $sani) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_xrdc * $xrdc) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_xpcs * $xpcs) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_dani * $dani) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_vean * $vean) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_sym  * $esym) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_zres * $zhar) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_bsa  * $bsa) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_desolv * $desolv) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_lcc * $lcc) 
 CNSsolve> 
 CNSsolve>    if ($nfirst = 1) then 
 CNSsolve>      evaluate ($bestener = $etot) 
 CNSsolve>      evaluate ($bestair = $eair) 
 CNSsolve>      evaluate ($ncvbest = $npart) 
 CNSsolve>      do (refx = x) (all) 
 CNSsolve>      do (refy = y) (all) 
 CNSsolve>      do (refz = z) (all) 
 CNSsolve>      evaluate ($nfirst = 0) 
 CNSsolve>      if ($data.waterdock eq true) then 
 CNSsolve>       ident (store3) (not all) 
 CNSsolve>       ident (store3) (store5) 
 CNSsolve>      else 
 CNSsolve>       ident (store3) (not all) 
 CNSsolve>      end if 
 CNSsolve>    else 
 CNSsolve>      if ($etot < $bestener) then 
 CNSsolve>        evaluate ($bestener = $etot) 
 CNSsolve>        evaluate ($bestair = $eair) 
 CNSsolve>        evaluate ($ncvbest = $npart) 
 CNSsolve>        do (refx = x) (all) 
 CNSsolve>        do (refy = y) (all) 
 CNSsolve>        do (refz = z) (all) 
 CNSsolve>        if ($data.waterdock eq true) then 
 CNSsolve>         ident (store3) (not all) 
 CNSsolve>         ident (store3) (store5) 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    evaluate ($kinter = $SaProtocol.inter_rigid) 
 CNSsolve>    @RUN:protocols/scale_inter_mini.cns 
 ASSFIL: file scale_inter_mini.cns opened.
 CNSsolve>! scale_inter_mini.cns 
 CNSsolve>!    Scaling of intermolecular interations 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DUM) (resn DUM) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn SHA) (resn SHA) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>    evaluate ($unamb_scale = $unamb_scale_store) 
 CNSsolve>    evaluate ($ambig_scale = $ambig_scale_store) 
 CNSsolve>    evaluate ($hbond_scale = $hbond_scale_store) 
 CNSsolve>    evaluate ($symm_scale = $symm_scale_store) 
 CNSsolve> 
 CNSsolve>    noe 
 CNSsolve>      scale dist $unamb_scale 
 CNSsolve>      scale ambi $ambig_scale 
 CNSsolve>      scale hbon $hbond_scale 
 CNSsolve>      scale symm $symm_scale 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>      if ($saprotocol.rotate180_it0 eq true) then 
 CNSsolve>          eval($nchain1 = 0) 
 CNSsolve>          while ($nchain1 < $data.ncomponents) loop nloop4 
 CNSsolve>            eval($nchain1 = $nchain1 + 1) 
 CNSsolve>            if ($Toppar.shape_$nchain1 eq false) then 
 CNSsolve>              eval($nchain2 = $nchain1 ) 
 CNSsolve>              while ($nchain2 < $data.ncomponents) loop nloop3 
 CNSsolve>                eval($nchain2 = $nchain2 + 1) 
 CNSsolve>                if ($Toppar.shape_$nchain2 eq false) then 
 CNSsolve>                  @RUN:protocols/rotation180.cns 
 ASSFIL: file rotation180.cns opened.
 CNSsolve>! rotation180.cns 
 CNSsolve>!    Perform a 180 degree rotation around a vector perpendicular to 
 CNSsolve>!    the interface of the complex 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>	eval($distcu = 5.0) 
 CNSsolve>        eval($rotate180 = 180.0) 
 CNSsolve>	eval($xa = 0.0) 
 CNSsolve>	eval($ya = 0.0) 
 CNSsolve>	eval($za = 0.0) 
 CNSsolve>	eval($xb = 0.0) 
 CNSsolve>	eval($zb = 0.0) 
 CNSsolve>	eval($zb = 0.0) 
 CNSsolve> 
 CNSsolve>        show aver (x) (segid $Toppar.prot_segid_$nchain1 and ((segid $Toppar.prot_segid_$nchain2) around $distcu)) 
 CNSsolve>        evaluate ($xa = $result) 
 CNSsolve>        show aver (y) (segid $Toppar.prot_segid_$nchain1 and ((segid $Toppar.prot_segid_$nchain2) around $distcu)) 
 CNSsolve>        evaluate ($ya = $result) 
 CNSsolve>        show aver (z) (segid $Toppar.prot_segid_$nchain1 and ((segid $Toppar.prot_segid_$nchain2) around $distcu)) 
 CNSsolve>        evaluate ($za = $result) 
 CNSsolve>        show aver (x) (segid $Toppar.prot_segid_$nchain2 and ((segid $Toppar.prot_segid_$nchain1) around $distcu)) 
 CNSsolve>        evaluate ($xb = $result) 
 CNSsolve>        show aver (y) (segid $Toppar.prot_segid_$nchain2 and ((segid $Toppar.prot_segid_$nchain1) around $distcu)) 
 CNSsolve>        evaluate ($yb = $result) 
 CNSsolve>        show aver (z) (segid $Toppar.prot_segid_$nchain2 and ((segid $Toppar.prot_segid_$nchain1) around $distcu)) 
 CNSsolve>        evaluate ($zb = $result) 
 CNSsolve>        eval($xdiff=$xa-$xb) 
 CNSsolve>        eval($ydiff=$ya-$yb) 
 CNSsolve>        eval($zdiff=$za-$zb) 
 CNSsolve>	eval($rnorm=$xdiff**2+$ydiff**2+$zdiff**2) 
 CNSsolve> 
 CNSsolve>	if ($rnorm > 0.0) then 
 CNSsolve> 
 CNSsolve>          coor 
 CNSsolve>            rotate sele= (segid $Toppar.prot_segid_$nchain2 or segid $watersegname_$nchain2 and not name MAP) 
 CNSsolve>            center=($xa $ya $za) 
 CNSsolve>            axis ($xdiff $ydiff $zdiff) 
 CNSsolve>            $rotate180 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>   	  fix sele=(name OO) end 
 CNSsolve>	 
 CNSsolve>          minimize rigid 
 CNSsolve>            eval ($nch1 = 0) 
 CNSsolve>            while ($nch1 < $data.ncomponents) loop nloop1 
 CNSsolve>	      eval($nch1 = $nch1 + 1) 
 CNSsolve>              if ($Toppar.fix_origin_$nch1 eq false) then 
 CNSsolve>                group (segid $Toppar.prot_segid_$nch1 or segid $watersegname_$nch1 and not name MAP) 
 CNSsolve>              end if 
 CNSsolve>              translation=true 
 CNSsolve>            end loop nloop1 
 CNSsolve>            translation=true 
 CNSsolve>            nstep 250 
 CNSsolve>            nprint 10 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          minimize rigid 
 CNSsolve>            eval ($nch1 = 0) 
 CNSsolve>            while ($nch1 < $data.ncomponents) loop nloop1 
 CNSsolve>	      eval($nch1 = $nch1 + 1) 
 CNSsolve>              if ($Toppar.fix_origin_$nch1 eq false) then 
 CNSsolve>                group (segid $Toppar.prot_segid_$nch1 or segid $watersegname_$nch1 and not name MAP) 
 CNSsolve>              end if 
 CNSsolve>              translation=true 
 CNSsolve>            end loop nloop1 
 CNSsolve>            translation=true 
 CNSsolve>            nstep 250 
 CNSsolve>            nprint 10 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          energy end 
 CNSsolve> 
 CNSsolve>          if ($anisotropy eq true) then 
 CNSsolve>            fix sele=(not all) end 
 CNSsolve>   	    fix sele=(name OO) end 
 CNSsolve>            minimize rigid 
 CNSsolve>              group (not (resn ANI or resn DAN or resn XAN or name MAP)) 
 CNSsolve>              translation=false 
 CNSsolve>              for $id in id ((resn ANI or resn DAN or resn XAN) and name OO) loop miniani 
 CNSsolve>                group (byres(id $id)) 
 CNSsolve>                translation=false 
 CNSsolve>              end loop miniani 
 CNSsolve>              translation=false 
 CNSsolve>              nstep 100 
 CNSsolve>              drop 10.0 
 CNSsolve>              nprint 10 
 CNSsolve>            end 
 CNSsolve>            minimize rigid 
 CNSsolve>              eval ($nch1 = 0) 
 CNSsolve>              while ($nch1 < $data.ncomponents) loop nloop1 
 CNSsolve>                eval($nch1 = $nch1 + 1) 
 CNSsolve>                if ($Toppar.fix_origin_$nch1 eq false) then 
 CNSsolve>                  group (segid $Toppar.prot_segid_$nch1 or segid $watersegname_$nch1 and not name MAP) 
 CNSsolve>		end if 
 CNSsolve>                translation=true 
 CNSsolve>              end loop nloop1 
 CNSsolve>              for $id in id ((resn ANI or resn DAN or resn XAN) and name OO) loop miniani 
 CNSsolve>                group (byres(id $id)) 
 CNSsolve>                translation=true 
 CNSsolve>              end loop miniani 
 CNSsolve>              translation=true 
 CNSsolve>              nstep 250 
 CNSsolve>              nprint 10 
 CNSsolve>            end 
 CNSsolve>          end if 
 CNSsolve>	 
 CNSsolve>	end if 
 CNSsolve>                  if ($data.flags.em = true) then 
 CNSsolve>                    if ($data.flags.centroids eq true) then 
 CNSsolve>                      if ($fixmol = false) then 
 CNSsolve>                        @RUN:protocols/em_orien_search.cns 
 ASSFIL: file em_orien_search.cns opened.
 CNSsolve>if ($fixmol eq false) then 
 CNSsolve>    ! perform a search to orient the complex properly in the density. 
 CNSsolve>    if ($data.ncomponents = 2) then 
 CNSsolve>        @RUN:protocols/em_rot_search.cns(data=$data; saprotocol=$saprotocol; 
 ASSFIL: file em_rot_search.cns opened.
 CNSsolve>module(Data; 
 MODULE-DECLARATION>       Saprotocol; 
 MODULE-DECLARATION>       Toppar; 
 MODULE-DECLARATION>       ) 
 MODULE-INVOCATION>                toppar=$toppar;) 
 CNSsolve>    {*Module optimizes the orientation of binary systems in the EM-density 
 CNSsolve> 
 CNSsolve>    The orientation is optimized by a fine rotation search of the axis that is 
 CNSsolve>    formed by the line that joins the two centroids. The XREF energy is 
 CNSsolve>    calculated at every orientation to differentiate. 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    Data 
 CNSsolve>        The Data object 
 CNSsolve> 
 CNSsolve>    Toppar 
 CNSsolve>        The Toppar object 
 CNSsolve> 
 CNSsolve>    Notes 
 CNSsolve>    ----- 
 CNSsolve>    The module uses the COMP coordinate set 
 CNSsolve>    The MAIN coordinate set are set to the orientation with the lowest XREF energy 
 CNSsolve> 
 CNSsolve>    *} 
 CNSsolve> 
 CNSsolve>    eval($time0 = $CPU) 
 CNSsolve> 
 CNSsolve>    ! Copy main coordinates to the comp set 
 CNSsolve>    coor copy selection=(all) end 
 CNSsolve> 
 CNSsolve>    ! Get rotation axis used for search.  ! It is the line that is made by 
 CNSsolve>    ! joining the two centroids 
 CNSsolve>    show (x) (name DUM and segid &Toppar.prot_segid_1) 
 CNSsolve>    eval($x1 = $result) 
 CNSsolve>    show (x) (name DUM and segid &Toppar.prot_segid_2) 
 CNSsolve>    eval($x2 = $result) 
 CNSsolve>    eval($rot_axis.x = $x1 - $x2) 
 CNSsolve> 
 CNSsolve>    show (y) (name DUM and segid &Toppar.prot_segid_1) 
 CNSsolve>    eval($y1 = $result) 
 CNSsolve>    show (y) (name DUM and segid &Toppar.prot_segid_2) 
 CNSsolve>    eval($y2 = $result) 
 CNSsolve>    eval($rot_axis.y = $y1 - $y2) 
 CNSsolve> 
 CNSsolve>    show (z) (name DUM and segid &Toppar.prot_segid_1) 
 CNSsolve>    eval($z1 = $result) 
 CNSsolve>    show (z) (name DUM and segid &Toppar.prot_segid_2) 
 CNSsolve>    eval($z2 = $result) 
 CNSsolve>    eval($rot_axis.z = $z1 - $z2) 
 CNSsolve> 
 CNSsolve>    ! Set the XREF flag to calculate the cross correlation potential in CNS 
 CNSsolve>    flags include xref end 
 CNSsolve>    ! Initialize the search values 
 CNSsolve>    eval($angle = 0) 
 CNSsolve>    eval($bestangle = 0) 
 CNSsolve>    eval($anglestep = 6) 
 CNSsolve>    eval($best_fit_energy = 9999) 
 CNSsolve> 
 CNSsolve>    while ($angle < 360.0) loop loopsearch 
 CNSsolve> 
 CNSsolve>        ! Rotate the system around the axis that is formed 
 CNSsolve>        ! by the line created by joining the two centroids. 
 CNSsolve>        coor rotate 
 CNSsolve>             center=($x1 $y1 $z1) 
 CNSsolve>             selection=(not name MAP) 
 CNSsolve>             axis ($rot_axis.x $rot_axis.y $rot_axis.z) $angle 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! Calculate the XREF energy 
 CNSsolve>        energy end 
 CNSsolve> 
 CNSsolve>        ! XREF is internally calculated by CNS 
 CNSsolve>        if ($XREF < $best_fit_energy) then 
 CNSsolve>            ! Update optimal parameters 
 CNSsolve>            eval($best_fit_energy = $XREF) 
 CNSsolve>            eval($bestangle = $angle) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        eval($angle = $angle + $anglestep) 
 CNSsolve> 
 CNSsolve>        ! Copy the original locations to the main coordinate set 
 CNSsolve>        coor swap end 
 CNSsolve>        coor copy end 
 CNSsolve> 
 CNSsolve>    end loop loopsearch 
 CNSsolve> 
 CNSsolve>    ! Reorient the original coordinates to the best fit values 
 CNSsolve>    coor rotate 
 CNSsolve>        center=($x1 $y1 $z1) 
 CNSsolve>        selection=(not name MAP) 
 CNSsolve>        axis ($rot_axis.x $rot_axis.y $rot_axis.z) $bestangle 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! Calculate the energy to check 
 CNSsolve>    energy end 
 CNSsolve> 
 CNSsolve>    ! Turn off the XREF energy term again 
 CNSsolve>    flags exclude xref end 
 CNSsolve> 
 CNSsolve>    ! Show the time required for the search 
 CNSsolve>    eval($time0 = $CPU - $time0) 
 CNSsolve>    display Time used for rotational search: $time0 s 
 CNSsolve>    elseif ($data.flags.sym = true) then 
 CNSsolve>        ! the search for symmetry only works for C-symmetry. Other symmetries 
 CNSsolve>        ! will break! 
 CNSsolve>        @RUN:protocols/em_sym_search.cns(data=$data; saprotocol=$saprotocol; 
 ASSFIL: file em_sym_search.cns opened.
 CNSsolve>module (Data; 
 MODULE-DECLARATION>        Saprotocol; 
 MODULE-DECLARATION>        Toppar;) 
 MODULE-INVOCATION>                toppar=$toppar;) 
 CNSsolve>    {*Module determines the correct orientation for symmetric complexes 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    Data 
 CNSsolve>        Data object 
 CNSsolve> 
 CNSsolve>    Saprotocol 
 CNSsolve>        Saprotocol object 
 CNSsolve> 
 CNSsolve>    Toppar 
 CNSsolve>        Toppar object 
 CNSsolve> 
 CNSsolve>    Notes 
 CNSsolve>    ----- 
 CNSsolve>    Only C-symmetry is supported. 
 CNSsolve>    Module uses the COMP coordinate set. 
 CNSsolve>    Module might change the MAIN coordinate set 
 CNSsolve>    *} 
 CNSsolve> 
 CNSsolve>    ! get the local cross correlation of the current orientation 
 CNSsolve>    @RUN:protocols/em_calc_lcc.cns(Toppar=&Toppar; 
 ASSFIL: file em_calc_lcc.cns opened.
 CNSsolve>module (Toppar; 
 MODULE-DECLARATION>        Data; 
 MODULE-DECLARATION>        Saprotocol; 
 MODULE-DECLARATION>        lcc; 
 MODULE-DECLARATION>        ) 
 MODULE-INVOCATION>                                   Data=&Data; 
 MODULE-INVOCATION>                                   Saprotocol=&Saprotocol; 
 MODULE-INVOCATION>                                   lcc=$lcc; 
 MODULE-INVOCATION>                                   ) 
 CNSsolve>    {*The module calculates the local cross-correlation coefficient (lcc) between 
 CNSsolve>    the targetmap and the atomic model. 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    Toppar 
 CNSsolve>	Toppar object 
 CNSsolve> 
 CNSsolve>    Data 
 CNSsolve>	Data object 
 CNSsolve> 
 CNSsolve>    Saprotocol 
 CNSsolve>	Saprotocol object 
 CNSsolve> 
 CNSsolve>    lcc : float (output) 
 CNSsolve>	The local cross correlation value in the interval [-1, 1] 
 CNSsolve> 
 CNSsolve>    Examples 
 CNSsolve>    -------- 
 CNSsolve>    >>> ! lcc calculation requires that the cryoEM data is read 
 CNSsolve>    >>> @RUN:protocols/em_read_data.cns(Data=$Data;) 
 CNSsolve>    >>> @RUN:protocols/em_calc_lcc.cns(Toppar=$Toppar; Data=$Data; Saprotocol=$Saprotocol; 
 CNSsolve>    >>>                                lcc=$lcc;) 
 CNSsolve>    >>> display Local cross correlation-coefficient: $lcc 
 CNSsolve> 
 CNSsolve>    Notes 
 CNSsolve>    ----- 
 CNSsolve>    This module uses the "b" atomobject. 
 CNSsolve>    *} 
 CNSsolve> 
 CNSsolve>    ! get the time 
 CNSsolve>    evaluate($time0 = $CPU) 
 CNSsolve> 
 CNSsolve>    ! check whether the arrays that are required for the lcc calculation exist 
 CNSsolve>    xray 
 CNSsolve>        query name=modelmap domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmap domain=real end 
 CNSsolve>            do (modelmap = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=map_tmp domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=map_tmp domain=real end 
 CNSsolve>            do (map_tmp = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=modelmask domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmask domain=real end 
 CNSsolve>            do (modelmask = 0) (all) 
 CNSsolve>        end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    do (b = 0) (all) 
 CNSsolve>    evaluate($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < &Data.ncomponents) loop nloop1 
 CNSsolve>        evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>        !if ($Saprotocol.init_placement.prot_segid_$nchain1.fixed = False) then 
 CNSsolve>            do (b = 1) (segid &Toppar.prot_segid_$nchain1 and not resn DUM) 
 CNSsolve>        !end if 
 CNSsolve>    end loop nloop1 
 CNSsolve> 
 CNSsolve>    ! Create the modelmap up to a certain resolution. We need to do 
 CNSsolve>    ! this via reciprocal space, by first creating the structure factors 
 CNSsolve>    ! and afters performing an inverse FFT to get the density. 
 CNSsolve>    xray 
 CNSsolve>        predict 
 CNSsolve>            mode=reciprocal 
 CNSsolve>            to=fcalc 
 CNSsolve>            atomselectiom=(attr b > 0) 
 CNSsolve>            selection=(all) 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        do (modelmap=real(ft(fcalc))) (all) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! create mask around the model 
 CNSsolve>    xray 
 CNSsolve>        mask 
 CNSsolve>            to=modelmask 
 CNSsolve>            selection=(attr b > 0) 
 CNSsolve>            averaging_mode=False 
 CNSsolve>            mode=sigma 
 CNSsolve>            proberadius=3 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! normalize modelmap and map within the modelmask 
 CNSsolve>        show average(modelmap) (modelmask=0) 
 CNSsolve>        evaluate($ave_modelmap = $RESULT) 
 CNSsolve>        do (modelmap = modelmap - $ave_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(modelmap*modelmap) (modelmask=0) 
 CNSsolve>        evaluate($std_modelmap = sqrt($RESULT)) 
 CNSsolve>        do (modelmap = modelmap / $std_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        ! normalize map within range of modelmask 
 CNSsolve>        show average(map) (modelmask=0) 
 CNSsolve>        evaluate($ave_map = $RESULT) 
 CNSsolve>        do (map_tmp = map - $ave_map) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(map_tmp*map_tmp) (modelmask=0) 
 CNSsolve>        evaluate($std_map = sqrt($RESULT)) 
 CNSsolve>        ! check if the std of the targetmap is larger than zero, else lcc is undefined. 
 CNSsolve>        if ($std_map > 0) then 
 CNSsolve>            do (map_tmp = map_tmp / $std_map) (modelmask=0) 
 CNSsolve>            ! now calculate the local cross correlation coefficient 
 CNSsolve>            show sum(modelmap * map_tmp) (modelmask=0) 
 CNSsolve>            evaluate(&lcc = $RESULT) 
 CNSsolve>        else 
 CNSsolve>            evaluate(&lcc = 0) 
 CNSsolve>       end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    evaluate($time0 = $CPU - $time0) 
 CNSsolve>    display Local cross correlation coefficient: &lcc 
 CNSsolve>    display Time used for local cross correlation calculation: $time0 s 
 CNSsolve> 
 CNSsolve>    ! calculate the mid point of the centroids 
 CNSsolve>    show average(x) (name MAP) 
 CNSsolve>    evaluate($center.x = $result) 
 CNSsolve>    show average(y) (name MAP) 
 CNSsolve>    evaluate($center.y = $result) 
 CNSsolve>    show average(z) (name MAP) 
 CNSsolve>    evaluate($center.z = $result) 
 CNSsolve> 
 CNSsolve>    ! determine the vector going from the first centroid to the midpoint 
 CNSsolve>    ! of the centroids. this represents the axis of rotation 
 CNSsolve>    show (x) (name MAP and segid &Toppar.prot_segid_1) 
 CNSsolve>    evaluate($map.x = $result) 
 CNSsolve>    show (y) (name MAP and segid &Toppar.prot_segid_1) 
 CNSsolve>    evaluate($map.y = $result) 
 CNSsolve>    show (z) (name MAP and segid &Toppar.prot_segid_1) 
 CNSsolve>    evaluate($map.z = $result) 
 CNSsolve> 
 CNSsolve>    evaluate($rot_axis.x = $center.x - $map.x) 
 CNSsolve>    evaluate($rot_axis.y = $center.y - $map.y) 
 CNSsolve>    evaluate($rot_axis.z = $center.z - $map.z) 
 CNSsolve> 
 CNSsolve>    ! store the current coordinates in the COMP coordinate set 
 CNSsolve>    coor copy selection=(all) end 
 CNSsolve> 
 CNSsolve>    ! rotate around the previous determined axis with 180 degrees. 
 CNSsolve>    coor rotate 
 CNSsolve>        center=($center.x $center.y $center.z) 
 CNSsolve>        selection=(not name MAP) 
 CNSsolve>        axis ($rot_axis.x $rot_axis.y $rot_axis.z) 180.0 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! calculate the local cross correlation for the rotated orientation 
 CNSsolve>    @RUN:protocols/em_calc_lcc.cns(Toppar=&Toppar; 
 ASSFIL: file em_calc_lcc.cns opened.
 CNSsolve>module (Toppar; 
 MODULE-DECLARATION>        Data; 
 MODULE-DECLARATION>        Saprotocol; 
 MODULE-DECLARATION>        lcc; 
 MODULE-DECLARATION>        ) 
 MODULE-INVOCATION>                                   Data=&Data; 
 MODULE-INVOCATION>                                   Saprotocol=&Saprotocol; 
 MODULE-INVOCATION>                                   lcc=$newlcc; 
 MODULE-INVOCATION>                                   ) 
 CNSsolve>    {*The module calculates the local cross-correlation coefficient (lcc) between 
 CNSsolve>    the targetmap and the atomic model. 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    Toppar 
 CNSsolve>	Toppar object 
 CNSsolve> 
 CNSsolve>    Data 
 CNSsolve>	Data object 
 CNSsolve> 
 CNSsolve>    Saprotocol 
 CNSsolve>	Saprotocol object 
 CNSsolve> 
 CNSsolve>    lcc : float (output) 
 CNSsolve>	The local cross correlation value in the interval [-1, 1] 
 CNSsolve> 
 CNSsolve>    Examples 
 CNSsolve>    -------- 
 CNSsolve>    >>> ! lcc calculation requires that the cryoEM data is read 
 CNSsolve>    >>> @RUN:protocols/em_read_data.cns(Data=$Data;) 
 CNSsolve>    >>> @RUN:protocols/em_calc_lcc.cns(Toppar=$Toppar; Data=$Data; Saprotocol=$Saprotocol; 
 CNSsolve>    >>>                                lcc=$lcc;) 
 CNSsolve>    >>> display Local cross correlation-coefficient: $lcc 
 CNSsolve> 
 CNSsolve>    Notes 
 CNSsolve>    ----- 
 CNSsolve>    This module uses the "b" atomobject. 
 CNSsolve>    *} 
 CNSsolve> 
 CNSsolve>    ! get the time 
 CNSsolve>    evaluate($time0 = $CPU) 
 CNSsolve> 
 CNSsolve>    ! check whether the arrays that are required for the lcc calculation exist 
 CNSsolve>    xray 
 CNSsolve>        query name=modelmap domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmap domain=real end 
 CNSsolve>            do (modelmap = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=map_tmp domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=map_tmp domain=real end 
 CNSsolve>            do (map_tmp = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=modelmask domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmask domain=real end 
 CNSsolve>            do (modelmask = 0) (all) 
 CNSsolve>        end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    do (b = 0) (all) 
 CNSsolve>    evaluate($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < &Data.ncomponents) loop nloop1 
 CNSsolve>        evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>        !if ($Saprotocol.init_placement.prot_segid_$nchain1.fixed = False) then 
 CNSsolve>            do (b = 1) (segid &Toppar.prot_segid_$nchain1 and not resn DUM) 
 CNSsolve>        !end if 
 CNSsolve>    end loop nloop1 
 CNSsolve> 
 CNSsolve>    ! Create the modelmap up to a certain resolution. We need to do 
 CNSsolve>    ! this via reciprocal space, by first creating the structure factors 
 CNSsolve>    ! and afters performing an inverse FFT to get the density. 
 CNSsolve>    xray 
 CNSsolve>        predict 
 CNSsolve>            mode=reciprocal 
 CNSsolve>            to=fcalc 
 CNSsolve>            atomselectiom=(attr b > 0) 
 CNSsolve>            selection=(all) 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        do (modelmap=real(ft(fcalc))) (all) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! create mask around the model 
 CNSsolve>    xray 
 CNSsolve>        mask 
 CNSsolve>            to=modelmask 
 CNSsolve>            selection=(attr b > 0) 
 CNSsolve>            averaging_mode=False 
 CNSsolve>            mode=sigma 
 CNSsolve>            proberadius=3 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! normalize modelmap and map within the modelmask 
 CNSsolve>        show average(modelmap) (modelmask=0) 
 CNSsolve>        evaluate($ave_modelmap = $RESULT) 
 CNSsolve>        do (modelmap = modelmap - $ave_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(modelmap*modelmap) (modelmask=0) 
 CNSsolve>        evaluate($std_modelmap = sqrt($RESULT)) 
 CNSsolve>        do (modelmap = modelmap / $std_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        ! normalize map within range of modelmask 
 CNSsolve>        show average(map) (modelmask=0) 
 CNSsolve>        evaluate($ave_map = $RESULT) 
 CNSsolve>        do (map_tmp = map - $ave_map) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(map_tmp*map_tmp) (modelmask=0) 
 CNSsolve>        evaluate($std_map = sqrt($RESULT)) 
 CNSsolve>        ! check if the std of the targetmap is larger than zero, else lcc is undefined. 
 CNSsolve>        if ($std_map > 0) then 
 CNSsolve>            do (map_tmp = map_tmp / $std_map) (modelmask=0) 
 CNSsolve>            ! now calculate the local cross correlation coefficient 
 CNSsolve>            show sum(modelmap * map_tmp) (modelmask=0) 
 CNSsolve>            evaluate(&lcc = $RESULT) 
 CNSsolve>        else 
 CNSsolve>            evaluate(&lcc = 0) 
 CNSsolve>       end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    evaluate($time0 = $CPU - $time0) 
 CNSsolve>    display Local cross correlation coefficient: &lcc 
 CNSsolve>    display Time used for local cross correlation calculation: $time0 s 
 CNSsolve> 
 CNSsolve>    ! if the lcc of the initial orientation is better, swap the COMP 
 CNSsolve>    ! coordinate set to the MAIN coordinate set 
 CNSsolve>    if ($lcc > $newlcc) then 
 CNSsolve>        coor swap selection=(all) end 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! do a final rigid body energy minimization directly against the EM 
 CNSsolve>! density, but without the centroid restraints 
 CNSsolve>flags include xref end 
 CNSsolve>minimize rigid 
 CNSsolve>    eval($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>        eval($nchain1 = $nchain1 + 1) 
 CNSsolve>        if ($Toppar.fix_origin_$nchain1 eq false) then 
 CNSsolve>            group ((segid $Toppar.prot_segid_$nchain1 or segid $watersegname_$nchain1) and not name MAP) 
 CNSsolve>        end if 
 CNSsolve>        translation=true 
 CNSsolve>    end loop nloop1 
 CNSsolve>    nstep 250 
 CNSsolve>    nprint 10 
 CNSsolve>end 
 CNSsolve>flags exclude xref end 
 CNSsolve>                      end if 
 CNSsolve>                    end if 
 CNSsolve>                  end if 
 CNSsolve>                  inline @RUN:protocols/bestener.cns 
 ASSFIL: file bestener.cns opened.
 CNSsolve>! bestener.cns 
 CNSsolve>!   Store best score model from rigid-body dokcing (it0) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>    eval ($kinter = 1.0) 
 CNSsolve>    @RUN:protocols/scale_inter_final.cns 
 ASSFIL: file scale_inter_final.cns opened.
 CNSsolve>! scale_inter_final.cns 
 CNSsolve>!   Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not 
 CNSsolve>                   (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA or resn DPP or resn PCW or resn PEE)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not 
 CNSsolve>                   (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA or resn DPP or resn PCW or resn PEE)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DUM) (resn DUM) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn SHA) (resn SHA) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>    evaluate ($unamb_scale = $Data.unamb_cool3) 
 CNSsolve>    evaluate ($ambig_scale = $Data.amb_cool3) 
 CNSsolve>    evaluate ($hbond_scale = $Data.hbond_cool3) 
 CNSsolve> 
 CNSsolve>    noe 
 CNSsolve>      scale dist $unamb_scale 
 CNSsolve>      scale ambi $ambig_scale 
 CNSsolve>      scale hbon $hbond_scale 
 CNSsolve>      scale symm 0.0 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    evaluate ($nrdc=1) 
 CNSsolve>    while ($nrdc <= $data.numrdc) loop rdc 
 CNSsolve>      evaluate ($cln = "rd" + encode($nrdc) ) 
 CNSsolve>      if ($Data.flags.sani eq true) then 
 CNSsolve>        sani class $cln force $Data.rdc_cool3_$nrdc end 
 CNSsolve>      end if 
 CNSsolve>      if ($Data.flags.xrdc eq true) then 
 CNSsolve>        xrdc class $cln force $Data.rdc_cool3_$nrdc end 
 CNSsolve>      end if 
 CNSsolve>      if ($Data.flags.vean eq true) then 
 CNSsolve>        vean class $cln force $Data.fin_bor_cool3_$nrdc $Data.fin_cen_cool3_$nrdc end 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($nrdc = $nrdc + 1) 
 CNSsolve>    end loop rdc 
 CNSsolve> 
 CNSsolve>    evaluate ($ndani=1) 
 CNSsolve>    while ($ndani <= $data.numdani) loop dani 
 CNSsolve>      evaluate ($cln = "da" + encode($ndani) ) 
 CNSsolve>      if ($Data.flags.dani eq true) then 
 CNSsolve>        dani class $cln force $Data.dan_cool3_$ndani end 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($ndani = $ndani + 1) 
 CNSsolve>    end loop dani 
 CNSsolve> 
 CNSsolve>    evaluate ($npcs=1) 
 CNSsolve>    while ($npcs <= $data.numpcs) loop pcs 
 CNSsolve>      evaluate ($cln = "pc" + encode($ndani) ) 
 CNSsolve>      if ($Data.flags.xpcs eq true) then 
 CNSsolve>        xpcs class $cln force $Data.pcs_cool3_$npcs end 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($npcs = $npcs + 1) 
 CNSsolve>    end loop pcs 
 CNSsolve> 
 CNSsolve>    evaluate ($ener = 0) 
 CNSsolve>    evaluate ($vdw  = 0) 
 CNSsolve>    evaluate ($elec = 0) 
 CNSsolve>    evaluate ($noe  = 0) 
 CNSsolve>    evaluate ($coll = 0) 
 CNSsolve>    evaluate ($eair = 0) 
 CNSsolve>    evaluate ($cdih = 0) 
 CNSsolve>    evaluate ($vean = 0) 
 CNSsolve>    evaluate ($sani = 0) 
 CNSsolve>    evaluate ($xrdc = 0) 
 CNSsolve>    evaluate ($xpcs = 0) 
 CNSsolve>    evaluate ($dani = 0) 
 CNSsolve>    evaluate ($esym = 0) 
 CNSsolve>    evaluate ($zhar = 0) 
 CNSsolve>    evaluate ($bsa  = 0) 
 CNSsolve>    evaluate ($desolv = 0.0) 
 CNSsolve>    evaluate ($lcc = 0.0) 
 CNSsolve> 
 CNSsolve>    energy end 
 CNSsolve>    evaluate ($eair = $noe) 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.sym eq true) then 
 CNSsolve>      noe 
 CNSsolve>        scale * 0.0 
 CNSsolve>        scale symm $Data.ksym 
 CNSsolve>      end 
 CNSsolve>      energy end 
 CNSsolve>      evaluate ($esym = $noe) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($SaProtocol.rigidtrans eq true) then 
 CNSsolve>      inline @RUN:protocols/bsa.cns 
 ASSFIL: file bsa.cns opened.
 CNSsolve> 
 CNSsolve>!   Calculate buried surface area and desolvation energy of the complex 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2016 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{====>} {* define ASA-based solvation parameters *} 
 CNSsolve>inline @RUN:protocols/def_solv_param.cns 
 ASSFIL: file def_solv_param.cns opened.
 CNSsolve>! def_solv_param.cns 
 CNSsolve>!    Define atomic solvation parameters taken from Fernandez-Recio et al. JMB 335:843 (2004) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($arofac = 6.26) 
 CNSsolve>evaluate ($alifac = 1.27) 
 CNSsolve>evaluate ($polfac = 2.30) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>do (store1 =  0.0000) (all) 
 CNSsolve>do (store1 =  0.0151 * $alifac) (name C*) 
 CNSsolve>do (store1 =  0.0176 * $arofac) ((name CG* or name CD* or name CE* or name CH* or name CZ*) and (resn PHE or resn TYR or resn HIS or resn TRP)) 
 CNSsolve>do (store1 = -0.0170 * $polfac) (name N*) 
 CNSsolve>do (store1 = -0.0548 * $polfac) (name NT* or (name NZ* and resn LYS)) 
 CNSsolve>do (store1 = -0.0273 * $polfac) (name NH* and resn ARG) 
 CNSsolve>do (store1 = -0.0136 * $polfac) (name O*) 
 CNSsolve>do (store1 = -0.0185 * $polfac) (name OG* or name OH) 
 CNSsolve>do (store1 = -0.0299 * $polfac) ((name OD* and resn ASP) or (name OE* and resn GLU)) 
 CNSsolve>do (store1 =  0.0112 * $polfac) (name S*) 
 CNSsolve>do (store1 =  0.0022 * $polfac) ((name S* and attr charge = -0.3) or (name SD and resn MET)) 
 CNSsolve>do (store1 =  0.0000) (name SHA) 
 CNSsolve> 
 CNSsolve>! 
 CNSsolve>! CG parameters matched from the original terms 
 CNSsolve>! 
 CNSsolve>!                  Edesolv_aa 
 CNSsolve>! ASP_cg = _________________________ 
 CNSsolve>!                    ASA_cg 
 CNSsolve>! 
 CNSsolve>! ASA_cg and Edesol_aa calculated on a GGXGG peptide 
 CNSsolve>! accuracy=0.0025, rh2o=1.4, delete H, sele=(resn X) 
 CNSsolve>! 
 CNSsolve>! e.g. BB bead alanine 
 CNSsolve>! 
 CNSsolve>! BB = CA + C + N + O 
 CNSsolve>! ASA_cg = 176.4940 
 CNSsolve>! Edesolv_aa = -1.8889 
 CNSsolve>! 
 CNSsolve>! ASP_cg = -0.0107 
 CNSsolve>! 
 CNSsolve>! Charleen Don (2012), JR (2014), Jorge Roel (2017) 
 CNSsolve>! 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store1 =  0.0000) (name BB or name SC*) 
 CNSsolve>! Backbone beads 
 CNSsolve>do (store1 = -0.0107) (name BB and resn ALA) 
 CNSsolve>do (store1 = -0.0089) (name BB and resn GLY) 
 CNSsolve>do (store1 = -0.0153) (name BB and resn ILE) 
 CNSsolve>do (store1 = -0.0158) (name BB and resn VAL) 
 CNSsolve>do (store1 = -0.0046) (name BB and resn PRO) 
 CNSsolve>do (store1 = -0.0137) (name BB and resn ASN) 
 CNSsolve>do (store1 = -0.0147) (name BB and resn GLN) 
 CNSsolve>do (store1 = -0.0165) (name BB and resn THR) 
 CNSsolve>do (store1 = -0.0154) (name BB and resn SER) 
 CNSsolve>do (store1 = -0.0130) (name BB and resn MET) 
 CNSsolve>do (store1 = -0.0167) (name BB and resn CYS) 
 CNSsolve>do (store1 = -0.0126) (name BB and resn PHE) 
 CNSsolve>do (store1 = -0.0134) (name BB and resn TYR) 
 CNSsolve>do (store1 = -0.0134) (name BB and resn TRP) 
 CNSsolve>do (store1 = -0.0169) (name BB and resn ASP) 
 CNSsolve>do (store1 = -0.0150) (name BB and resn GLU) 
 CNSsolve>do (store1 = -0.0155) (name BB and resn HIS) 
 CNSsolve>do (store1 = -0.0163) (name BB and resn LYS) 
 CNSsolve>do (store1 = -0.0162) (name BB and resn ARG) 
 CNSsolve> 
 CNSsolve>! Side-chain beads 
 CNSsolve>!do (store1 =  0.0000) (name SC* and resn ALA) 
 CNSsolve>!do (store1 =  0.0000) (name SC* and resn GLY) 
 CNSsolve>do (store1 =  0.0255) (name SC* and resn ILE) 
 CNSsolve>do (store1 =  0.0222) (name SC* and resn VAL) 
 CNSsolve>do (store1 =  0.0230) (name SC* and resn PRO) 
 CNSsolve>do (store1 = -0.0192) (name SC* and resn ASN) 
 CNSsolve>do (store1 = -0.0135) (name SC* and resn GLN) 
 CNSsolve>do (store1 = -0.0009) (name SC* and resn THR) 
 CNSsolve>do (store1 = -0.0056) (name SC* and resn SER) 
 CNSsolve>do (store1 =  0.0202) (name SC* and resn MET) 
 CNSsolve>do (store1 =  0.0201) (name SC* and resn CYS) 
 CNSsolve>do (store1 =  0.1005) (name SC* and resn PHE) 
 CNSsolve>do (store1 =  0.0669) (name SC* and resn TYR) 
 CNSsolve>do (store1 =  0.0872) (name SC* and resn TRP) 
 CNSsolve>do (store1 = -0.0360) (name SC* and resn ASP) 
 CNSsolve>do (store1 = -0.0301) (name SC* and resn GLU) 
 CNSsolve>do (store1 =  0.0501) (name SC* and resn HIS) 
 CNSsolve>do (store1 = -0.0210) (name SC* and resn LYS) 
 CNSsolve>do (store1 = -0.0229) (name SC* and resn ARG) 
 CNSsolve> 
 CNSsolve>! Fake beads 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn ASN) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn GLN) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn SER) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn THR) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn ARG) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn LYS) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn GLU) 
 CNSsolve>do (store1 = 0.0) (name SCD* and resn ASP) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{====>} {* buried surface area and desolvation of single chains *} 
 CNSsolve>evaluate ($nchain1 = 0) 
 CNSsolve>evaluate ($saafree = 0) 
 CNSsolve>evaluate ($esolfree = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 CNSsolve>  {====>} {* buried surface area and desolvation*} 
 CNSsolve>  do (rmsd = 0) (all) 
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) end 
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 CNSsolve>  do (store2 = rmsd * store1) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>  show sum (store2) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>  evaluate ($esolfree = $esolfree + $result) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>{====>} {* buried surface area and desolvation of complex *} 
 CNSsolve>do (rmsd = 0) (all) 
 CNSsolve>do (store2 = 0) (all) 
 CNSsolve>surface mode=access accu=0.075 rh2o=1.4 sele=(not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) end 
 CNSsolve>show sum (rmsd) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>evaluate ($satot = $result) 
 CNSsolve>do (store2 = rmsd * store1) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>show sum (store2) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn SHA)) 
 CNSsolve>evaluate ($esolcplx = $result) 
 CNSsolve>evaluate ($saburied = $saafree - $satot) 
 CNSsolve>! minimum BSA value set to 15 (one H atom would have SASA of 12.56 A**2) 
 CNSsolve>if ($saburied < 15) then 
 CNSsolve>  evaluate ($saburied = -999999) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($edesolv = $esolcplx - $esolfree) 
 CNSsolve> 
 CNSsolve>if ($data.ncomponents eq 1) then 
 CNSsolve>  evaluate ($bsa = 0) 
 CNSsolve>  evaluate ($desolv = 0) 
 CNSsolve>end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    ! get the local cross-correlation for cryo-EM data 
 CNSsolve>    if ($data.flags.em = true) then 
 CNSsolve>        @RUN:protocols/em_calc_lcc.cns(Toppar=$toppar; Data=$data; Saprotocol=$saprotocol; lcc=$lcc;) 
 ASSFIL: file em_calc_lcc.cns opened.
 CNSsolve>module (Toppar; 
 MODULE-DECLARATION>        Data; 
 MODULE-DECLARATION>        Saprotocol; 
 MODULE-DECLARATION>        lcc; 
 MODULE-DECLARATION>        ) 
 CNSsolve>    {*The module calculates the local cross-correlation coefficient (lcc) between 
 CNSsolve>    the targetmap and the atomic model. 
 CNSsolve> 
 CNSsolve>    Parameters 
 CNSsolve>    ---------- 
 CNSsolve>    Toppar 
 CNSsolve>	Toppar object 
 CNSsolve> 
 CNSsolve>    Data 
 CNSsolve>	Data object 
 CNSsolve> 
 CNSsolve>    Saprotocol 
 CNSsolve>	Saprotocol object 
 CNSsolve> 
 CNSsolve>    lcc : float (output) 
 CNSsolve>	The local cross correlation value in the interval [-1, 1] 
 CNSsolve> 
 CNSsolve>    Examples 
 CNSsolve>    -------- 
 CNSsolve>    >>> ! lcc calculation requires that the cryoEM data is read 
 CNSsolve>    >>> @RUN:protocols/em_read_data.cns(Data=$Data;) 
 CNSsolve>    >>> @RUN:protocols/em_calc_lcc.cns(Toppar=$Toppar; Data=$Data; Saprotocol=$Saprotocol; 
 CNSsolve>    >>>                                lcc=$lcc;) 
 CNSsolve>    >>> display Local cross correlation-coefficient: $lcc 
 CNSsolve> 
 CNSsolve>    Notes 
 CNSsolve>    ----- 
 CNSsolve>    This module uses the "b" atomobject. 
 CNSsolve>    *} 
 CNSsolve> 
 CNSsolve>    ! get the time 
 CNSsolve>    evaluate($time0 = $CPU) 
 CNSsolve> 
 CNSsolve>    ! check whether the arrays that are required for the lcc calculation exist 
 CNSsolve>    xray 
 CNSsolve>        query name=modelmap domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmap domain=real end 
 CNSsolve>            do (modelmap = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=map_tmp domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=map_tmp domain=real end 
 CNSsolve>            do (map_tmp = 0) (all) 
 CNSsolve>        end if 
 CNSsolve> 
 CNSsolve>        query name=modelmask domain=real end 
 CNSsolve>        if ($OBJECT_EXIST = false) then 
 CNSsolve>            declare name=modelmask domain=real end 
 CNSsolve>            do (modelmask = 0) (all) 
 CNSsolve>        end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    do (b = 0) (all) 
 CNSsolve>    evaluate($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < &Data.ncomponents) loop nloop1 
 CNSsolve>        evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>        !if ($Saprotocol.init_placement.prot_segid_$nchain1.fixed = False) then 
 CNSsolve>            do (b = 1) (segid &Toppar.prot_segid_$nchain1 and not resn DUM) 
 CNSsolve>        !end if 
 CNSsolve>    end loop nloop1 
 CNSsolve> 
 CNSsolve>    ! Create the modelmap up to a certain resolution. We need to do 
 CNSsolve>    ! this via reciprocal space, by first creating the structure factors 
 CNSsolve>    ! and afters performing an inverse FFT to get the density. 
 CNSsolve>    xray 
 CNSsolve>        predict 
 CNSsolve>            mode=reciprocal 
 CNSsolve>            to=fcalc 
 CNSsolve>            atomselectiom=(attr b > 0) 
 CNSsolve>            selection=(all) 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        do (modelmap=real(ft(fcalc))) (all) 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    ! create mask around the model 
 CNSsolve>    xray 
 CNSsolve>        mask 
 CNSsolve>            to=modelmask 
 CNSsolve>            selection=(attr b > 0) 
 CNSsolve>            averaging_mode=False 
 CNSsolve>            mode=sigma 
 CNSsolve>            proberadius=3 
 CNSsolve>        end 
 CNSsolve> 
 CNSsolve>        ! normalize modelmap and map within the modelmask 
 CNSsolve>        show average(modelmap) (modelmask=0) 
 CNSsolve>        evaluate($ave_modelmap = $RESULT) 
 CNSsolve>        do (modelmap = modelmap - $ave_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(modelmap*modelmap) (modelmask=0) 
 CNSsolve>        evaluate($std_modelmap = sqrt($RESULT)) 
 CNSsolve>        do (modelmap = modelmap / $std_modelmap) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        ! normalize map within range of modelmask 
 CNSsolve>        show average(map) (modelmask=0) 
 CNSsolve>        evaluate($ave_map = $RESULT) 
 CNSsolve>        do (map_tmp = map - $ave_map) (modelmask=0) 
 CNSsolve> 
 CNSsolve>        show sum(map_tmp*map_tmp) (modelmask=0) 
 CNSsolve>        evaluate($std_map = sqrt($RESULT)) 
 CNSsolve>        ! check if the std of the targetmap is larger than zero, else lcc is undefined. 
 CNSsolve>        if ($std_map > 0) then 
 CNSsolve>            do (map_tmp = map_tmp / $std_map) (modelmask=0) 
 CNSsolve>            ! now calculate the local cross correlation coefficient 
 CNSsolve>            show sum(modelmap * map_tmp) (modelmask=0) 
 CNSsolve>            evaluate(&lcc = $RESULT) 
 CNSsolve>        else 
 CNSsolve>            evaluate(&lcc = 0) 
 CNSsolve>       end if 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    evaluate($time0 = $CPU - $time0) 
 CNSsolve>    display Local cross correlation coefficient: &lcc 
 CNSsolve>    display Time used for local cross correlation calculation: $time0 s 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    evaluate ($etot = $iterations.w_vdw  * $vdw) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_elec * $elec) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_dist * $eair) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_rg *   $coll) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_cdih * $cdih) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_sani * $sani) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_xrdc * $xrdc) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_xpcs * $xpcs) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_dani * $dani) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_vean * $vean) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_sym  * $esym) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_zres * $zhar) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_bsa  * $bsa) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_desolv * $desolv) 
 CNSsolve>    evaluate ($etot = $etot + $iterations.w_lcc * $lcc) 
 CNSsolve> 
 CNSsolve>    if ($nfirst = 1) then 
 CNSsolve>      evaluate ($bestener = $etot) 
 CNSsolve>      evaluate ($bestair = $eair) 
 CNSsolve>      evaluate ($ncvbest = $npart) 
 CNSsolve>      do (refx = x) (all) 
 CNSsolve>      do (refy = y) (all) 
 CNSsolve>      do (refz = z) (all) 
 CNSsolve>      evaluate ($nfirst = 0) 
 CNSsolve>      if ($data.waterdock eq true) then 
 CNSsolve>       ident (store3) (not all) 
 CNSsolve>       ident (store3) (store5) 
 CNSsolve>      else 
 CNSsolve>       ident (store3) (not all) 
 CNSsolve>      end if 
 CNSsolve>    else 
 CNSsolve>      if ($etot < $bestener) then 
 CNSsolve>        evaluate ($bestener = $etot) 
 CNSsolve>        evaluate ($bestair = $eair) 
 CNSsolve>        evaluate ($ncvbest = $npart) 
 CNSsolve>        do (refx = x) (all) 
 CNSsolve>        do (refy = y) (all) 
 CNSsolve>        do (refz = z) (all) 
 CNSsolve>        if ($data.waterdock eq true) then 
 CNSsolve>         ident (store3) (not all) 
 CNSsolve>         ident (store3) (store5) 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    evaluate ($kinter = $SaProtocol.inter_rigid) 
 CNSsolve>    @RUN:protocols/scale_inter_mini.cns 
 ASSFIL: file scale_inter_mini.cns opened.
 CNSsolve>! scale_inter_mini.cns 
 CNSsolve>!    Scaling of intermolecular interations 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DUM) (resn DUM) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn SHA) (resn SHA) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>    evaluate ($unamb_scale = $unamb_scale_store) 
 CNSsolve>    evaluate ($ambig_scale = $ambig_scale_store) 
 CNSsolve>    evaluate ($hbond_scale = $hbond_scale_store) 
 CNSsolve>    evaluate ($symm_scale = $symm_scale_store) 
 CNSsolve> 
 CNSsolve>    noe 
 CNSsolve>      scale dist $unamb_scale 
 CNSsolve>      scale ambi $ambig_scale 
 CNSsolve>      scale hbon $hbond_scale 
 CNSsolve>      scale symm $symm_scale 
 CNSsolve>    end 
 CNSsolve>                end if 
 CNSsolve>              end loop nloop3 
 CNSsolve>            end if 
 CNSsolve>          end loop nloop4 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>    end loop trials 
 CNSsolve> 
 CNSsolve>  else ! if ($Saprotocol.rigidmini = False) 
 CNSsolve> 
 CNSsolve>    evaluate ($kinter = $SaProtocol.inter_rigid) 
 EVALUATE: symbol $KINTER set to    1.00000     (real)
 CNSsolve>    @RUN:protocols/scale_inter_only.cns 
 ASSFIL: file scale_inter_only.cns opened.
 CNSsolve>! scale_inter_only.cns 
 CNSsolve>!   Scaling of intermolecular interaction (not internal energies) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>igroup 
 IGROup> 
 IGROup>  eval($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 IGROup> 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 IGROup>    eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    1.00000     (real)
 IGROup>    while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as true
 IGROup>      eval($nchain2 = $nchain2 + 1) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 IGROup>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 EVALUATE: symbol $SCALFAC set to    1.00000     (real)
 IGROup>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 SELRPN:   3166 atoms have been selected out of   3253
 SELRPN>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1.0 vdw $scalfac elec $scalfac end 
 SELRPN:     87 atoms have been selected out of   3253
 IGROup>    end loop nloop2 
 IGROup>    while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 IGROup>      eval($nchain2 = $nchain2 + 1) 
 IGROup>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 IGROup>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 IGROup>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1.0 vdw $scalfac elec $scalfac end 
 IGROup>    end loop nloop2 
 IGROup>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 SELRPN:   3166 atoms have been selected out of   3253
 SELRPN>                ((resn WAT or resn HOH or resn TIP* or resn DMS)) weight * 1.0 vdw $kinter elec $kinter end 
 SELRPN:      0 atoms have been selected out of   3253
 IGROup> 
 IGROup>  end loop nloop1 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 IGROup>    eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 IGROup>    while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 IGROup>      eval($nchain2 = $nchain2 + 1) 
 IGROup>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 IGROup>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 IGROup>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1.0 vdw $scalfac elec $scalfac end 
 IGROup>    end loop nloop2 
 IGROup>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 SELRPN:     87 atoms have been selected out of   3253
 SELRPN>                ((resn WAT or resn HOH or resn TIP* or resn DMS)) weight * 1.0 vdw $kinter elec $kinter end 
 SELRPN:      0 atoms have been selected out of   3253
 IGROup> 
 IGROup>  end loop nloop1 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 IGROup>    eval($nchain2 = $nchain1 ) 
 IGROup>    while ($nchain2 < $data.ncomponents) loop nloop2 
 IGROup>      eval($nchain2 = $nchain2 + 1) 
 IGROup>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 IGROup>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 IGROup>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1.0 vdw $scalfac elec $scalfac end 
 IGROup>    end loop nloop2 
 IGROup>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 IGROup>                ((resn WAT or resn HOH or resn TIP* or resn DMS)) weight * 1.0 vdw $kinter elec $kinter end 
 IGROup> 
 IGROup>  end loop nloop1 
 IGROup> 
 IGROup>  interaction ((resn WAT or resn HOH or resn TIP*)) ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 IGROup> 
 IGROup>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 IGROup>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 IGROup>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 IGROup>  interaction (resn DUM) (resn DUM) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 IGROup>  interaction (resn SHA) (resn SHA) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 IGROup>  interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:   3253 atoms have been selected out of   3253
 IGROup> 
 IGROup>end 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.sani eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($nrdc=1) 
 CNSsolve>      while ($nrdc <= $data.numrdc) loop rdc 
 CNSsolve>        evaluate ($cln = "rd"+encode($nrdc) ) 
 CNSsolve>        sani class $cln force $Data.rdc_hot_$nrdc end 
 CNSsolve>        evaluate ($nrdc = $nrdc + 1) 
 CNSsolve>      end loop rdc 
 CNSsolve>      if ($rantens eq true) then 
 CNSsolve>        @RUN:protocols/mini_tensor.cns 
 ASSFIL: file mini_tensor.cns opened.
 CNSsolve>! mini_tensor.cns 
 CNSsolve>!    Optimize the RDC tensor orientation 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{* Optimize tensor orientation *} 
 CNSsolve> 
 CNSsolve>{* first randomize the tensor orientation because of some CNS problems *} 
 CNSsolve>{* possible resulting in infinite gradient and a failure of the EM     *} 
 CNSsolve> 
 CNSsolve>eval ($erdc = 999999999.0) 
 CNSsolve>eval ($ncount = 0) 
 CNSsolve>while ($ncount < 4) loop trial 
 CNSsolve>  eval ($ncount = $ncount + 1) 
 CNSsolve>  do (xcomp = x) (resn ANI) 
 CNSsolve>  do (ycomp = y) (resn ANI) 
 CNSsolve>  do (zcomp = z) (resn ANI) 
 CNSsolve> 
 CNSsolve>  !random rotation of tensor 
 CNSsolve> 
 CNSsolve>  show aver (x) (resn ANI) 
 CNSsolve>  evaluate ($xc = $result) 
 CNSsolve>  show aver (y) (resn ANI) 
 CNSsolve>  evaluate ($yc = $result) 
 CNSsolve>  show aver (z) (resn ANI) 
 CNSsolve>  evaluate ($zc = $result) 
 CNSsolve> 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  {* rotate around z axis *} 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = -sin($xr)) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = sin($xr)) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = 1 ) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  {* rotate around x axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = 1 ) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = -sin($xr)) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = sin($xr)) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve>  {* rotate around y axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = -sin($xr)) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = 1 ) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = sin($xr)) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  if ($ncount = 1) then 
 CNSsolve>    eval ($erdc=$sani) 
 CNSsolve>  end if 
 CNSsolve>  if ($sani < $erdc) then 
 CNSsolve>    eval ($erdc=$sani) 
 CNSsolve>    do (xcomp = x) (resn ANI) 
 CNSsolve>    do (ycomp = y) (resn ANI) 
 CNSsolve>    do (zcomp = z) (resn ANI) 
 CNSsolve>  else 
 CNSsolve>    do (x = xcomp) (resn ANI) 
 CNSsolve>    do (y = ycomp) (resn ANI) 
 CNSsolve>    do (z = zcomp) (resn ANI) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end loop trial 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve>fix sele=(name OO) end 
 CNSsolve>minimize rigid 
 CNSsolve>  group (not resn ANI) 
 CNSsolve>  translation=false 
 CNSsolve>  for $id in id (resn ANI and name OO) loop miniani 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop miniani 
 CNSsolve>  translation=false 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve>minimize rigid 
 CNSsolve>  eval($nchain1= 1) 
 CNSsolve>  while ($nchain1 <= $data.ncomponents) loop cloop1 
 CNSsolve>    group (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    translation=false 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>  end loop cloop1 
 CNSsolve>  for $id in id (resn ANI and name OO) loop miniani 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop miniani 
 CNSsolve>  translation=false 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    evaluate ($paramin = false) 
 EVALUATE: symbol $PARAMIN set to FALSE (logical)
 CNSsolve>    if ($Data.flags.xrdc eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($nrdc=1) 
 CNSsolve>      while ($nrdc <= $data.numrdc) loop rdc 
 CNSsolve>        evaluate ($cln = "rd"+encode($nrdc) ) 
 CNSsolve>        xrdc class $cln force $Data.rdc_hot_$nrdc end 
 CNSsolve>        evaluate ($nrdc = $nrdc + 1) 
 CNSsolve>      end loop rdc 
 CNSsolve>      evaluate ($paramin = true) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.xpcs eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($npcs=1) 
 CNSsolve>      while ($npcs <= $data.numpcs) loop pcs 
 CNSsolve>        evaluate ($cln = "pc"+encode($npcs) ) 
 CNSsolve>        xpcs class $cln force $Data.pcs_hot_$npcs end 
 CNSsolve>        evaluate ($paramin = true) 
 CNSsolve>        evaluate ($npcs= $npcs + 1) 
 CNSsolve>      end loop pcs 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($paramin eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      if ($rantens_para eq true) then 
 CNSsolve>        @RUN:protocols/mini_tensor_para.cns 
 ASSFIL: file mini_tensor_para.cns opened.
 CNSsolve>! mini_tensor_para.cns 
 CNSsolve>!    Optimize the tensor orientation for PCS restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>!set message on echo on end 
 CNSsolve> 
 CNSsolve>display STARTing mini_tensor_para.cns 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="trial.pdb" end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{* minimize tensor position *} 
 CNSsolve>display STARTing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>!flag excl * include noe end 
 CNSsolve>flag excl xpcs include noe end 
 CNSsolve>fix sele=(not resn XAN) end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve>  interaction (not all) (not all) 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>minimize rigid 
 CNSsolve>  group (resname XAN) 
 CNSsolve>  translation=true 
 CNSsolve>  nstep 1000 
 CNSsolve>  tole 0.1 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="position.pdb" end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>display STARTing minimization of orientation 
 CNSsolve> 
 CNSsolve>{* minimize tensor orientation *} 
 CNSsolve> 
 CNSsolve>evaluate ($protocol = 0) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($protocol = 0) then {* powell minimization protocol together *} 
 CNSsolve> 
 CNSsolve>  display protocol 0 
 CNSsolve>!  flag excl * include noe xpcs bond end 
 CNSsolve>  flag  include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>    interaction (not all) (not all) 
 CNSsolve>    interaction ( resn XAN ) ( resn XAN ) weight * 0 bond 1.0 end 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  fix sele=(not (resn XAN)) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve>elseif ($protocol = 1) then {* powell minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 1 
 CNSsolve>  flag excl * include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    igroup 
 CNSsolve>      interaction (not all) (not all) 
 CNSsolve>      interaction ( (byres(id $id)) ) ( (byres(id $id)) ) weight * 0 bond 1.0 end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    fix sele=(not ( (byres(id $id)) )) end 
 CNSsolve> 
 CNSsolve>    minimize powell 
 CNSsolve>      nstep=500 
 CNSsolve>      drop=10 
 CNSsolve>      nprint=10 
 CNSsolve>      tolgradient=0.01 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 4) then {* powell minimization protocol simultaneously *} 
 CNSsolve> 
 CNSsolve>  display protocol 4 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve> 
 CNSsolve>  fix sele=(not ( resname XAN )) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 2) then  {* rigid body minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 2 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    minimize rigid 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>      nstep 500 
 CNSsolve>      nprint 10 
 CNSsolve>      drop=10 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 3) then {* original rigid body minimization protocol *} 
 CNSsolve>  display protocol 3 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  fix sele=(not resname XAN) end 
 CNSsolve>  minimize rigid 
 CNSsolve>    group (not resname XAN) 
 CNSsolve>    translation=true 
 CNSsolve>    for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>    end loop miniani 
 CNSsolve>    translation=true 
 CNSsolve>    nstep 5000 
 CNSsolve> 
 CNSsolve>    nprint 10 
 CNSsolve>  end 
 CNSsolve>  display XPCS_ENERGY $xpcs 
 CNSsolve>  fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of orientation 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.dani eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($ndani=1) 
 CNSsolve>      while ($ndani <= $data.numdani) loop dani 
 CNSsolve>        evaluate ($cln = "da"+encode($ndani) ) 
 CNSsolve>        dani class $cln force $Data.dan_hot_$ndani end 
 CNSsolve>        evaluate ($ndani = $ndani + 1) 
 CNSsolve>      end loop dani 
 CNSsolve>      if ($rantens_dani eq true) then 
 CNSsolve>        @RUN:protocols/mini_tensor_dani.cns 
 ASSFIL: file mini_tensor_dani.cns opened.
 CNSsolve>! mini_tensor_dani.cns 
 CNSsolve>!    Optimize the tensor orientation for diffusion anisotropy restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{* Optimize tensor orientation *} 
 CNSsolve>{* ADJ van Dijk*} 
 CNSsolve>{* copied from mini_tensor.cns *} 
 CNSsolve> 
 CNSsolve>{* first randomize the tensor orientation because of some CNS problems *} 
 CNSsolve>{* possible resulting in infinite gradient and a failure of the EM     *} 
 CNSsolve> 
 CNSsolve>eval ($edani = 999999999.0) 
 CNSsolve>eval ($ncount = 0) 
 CNSsolve>while ($ncount < 4) loop trial 
 CNSsolve>  eval ($ncount = $ncount + 1) 
 CNSsolve>  do (xcomp = x) (resn DAN) 
 CNSsolve>  do (ycomp = y) (resn DAN) 
 CNSsolve>  do (zcomp = z) (resn DAN) 
 CNSsolve> 
 CNSsolve>  !random rotation of tensor 
 CNSsolve> 
 CNSsolve>  show aver (x) (resn DAN) 
 CNSsolve>  evaluate ($xc = $result) 
 CNSsolve>  show aver (y) (resn DAN) 
 CNSsolve>  evaluate ($yc = $result) 
 CNSsolve>  show aver (z) (resn DAN) 
 CNSsolve>  evaluate ($zc = $result) 
 CNSsolve> 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  {* rotate around z axis *} 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = -sin($xr)) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = sin($xr)) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = 1 ) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  {* rotate around x axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = 1 ) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = -sin($xr)) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = sin($xr)) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve>  {* rotate around y axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = -sin($xr)) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = 1 ) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = sin($xr)) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  if ($ncount = 1) then 
 CNSsolve>    eval ($edani=$dani) 
 CNSsolve>  end if 
 CNSsolve>  if ($dani < $edani) then 
 CNSsolve>    eval ($edani=$dani) 
 CNSsolve>    do (xcomp = x) (resn DAN) 
 CNSsolve>    do (ycomp = y) (resn DAN) 
 CNSsolve>    do (zcomp = z) (resn DAN) 
 CNSsolve>  else 
 CNSsolve>    do (x = xcomp) (resn DAN) 
 CNSsolve>    do (y = ycomp) (resn DAN) 
 CNSsolve>    do (z = zcomp) (resn DAN) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end loop trial 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve>fix sele=(name OO) end 
 CNSsolve>minimize rigid 
 CNSsolve>  group (not resn DAN) 
 CNSsolve>  translation=false 
 CNSsolve>  for $id in id (resn DAN and name OO) loop minidan 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop minidan 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve>minimize rigid 
 CNSsolve>  eval($nchain1= 1) 
 CNSsolve>  while ($nchain1 <= $data.ncomponents) loop cloop1 
 CNSsolve>    group (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop cloop1 
 CNSsolve>  for $id in id (resn DAN and name OO) loop minidan 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop minidan 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    do (refx=x) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>    do (refy=y) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>    do (refz=z) (all) 
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>    ! the centroid based restraints should not be included in the energy calculation 
 CNSsolve>    if ($data.flags.centroids eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>        noe scale centroid 0 end 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    energy end 
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found      0 exclusions and      0 interactions(1-4)
 NBONDS: found     5618 intra-atom interactions
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found      0 exclusions and      0 interactions(1-4)
 NBONDS: found        0 intra-atom interactions
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found      0 exclusions and      0 interactions(1-4)
 NBONDS: found        0 intra-atom interactions
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found      0 exclusions and      0 interactions(1-4)
 NBONDS: found        0 intra-atom interactions
 --------------- cycle=     1 --------------------------------------------------
 | Etotal =-10.828    grad(E)=0.933      E(VDW )=-18.554    E(ELEC)=-3.296     |
 | E(NOE )=11.022                                                              |
 -------------------------------------------------------------------------------
 CNSsolve>    evaluate ($bestair = $noe) 
 EVALUATE: symbol $BESTAIR set to    11.0219     (real)
 CNSsolve> 
 CNSsolve>  end if ! ($Saprotocol.rigidmini = true) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{* ===================== calculate complex internal energy *} 
 CNSsolve>  evaluate ($kinter = 1.0) 
 EVALUATE: symbol $KINTER set to    1.00000     (real)
 CNSsolve>  @RUN:protocols/scale_intra_only.cns 
 ASSFIL: file scale_intra_only.cns opened.
 CNSsolve>! scale_intra_only.cns 
 CNSsolve>!    Scaling of intramolecular energies (no intermolecular energies) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>igroup 
 IGROup> 
 IGROup>  eval($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 IGROup> 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 IGROup> 
 IGROup>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 SELRPN:   3166 atoms have been selected out of   3253
 SELRPN>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1.0 end 
 SELRPN:   3166 atoms have been selected out of   3253
 IGROup> 
 IGROup> end loop nloop1 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 IGROup> 
 IGROup>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 SELRPN:     87 atoms have been selected out of   3253
 SELRPN>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1.0 end 
 SELRPN:     87 atoms have been selected out of   3253
 IGROup> 
 IGROup> end loop nloop1 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 IGROup> 
 IGROup>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) 
 IGROup>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN or resn DUM or resn SHA)) weight * 1.0 end 
 IGROup> 
 IGROup> end loop nloop1 
 IGROup> 
 IGROup> interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 IGROup> interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 IGROup> interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 IGROup> interaction (resn DUM) (resn DUM) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 IGROup> interaction (resn SHA) (resn SHA) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:      0 atoms have been selected out of   3253
 IGROup> interaction (resn SHA) (not resn SHA) weight * 0.0 end 
 SELRPN:      0 atoms have been selected out of   3253
 SELRPN:   3253 atoms have been selected out of   3253
 IGROup> 
 IGROup>end 
 CNSsolve> 
 CNSsolve>inline @RUN:protocols/charge-beads-interactions.cns 
 ASSFIL: file charge-beads-interactions.cns opened.
 CNSsolve>! charge-beads-interactions.cns 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * and from the CNS distriution of Brunger and Adams                   * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>for $id1 in id ( (resn SER or resn THR or resn ASN or resn GLN) and name BB ) loop c1beads 
 SELRPN:      0 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>   show (segid) (id $id1) 
 CNSsolve>   evaluate ($cgsegid=$result) 
 CNSsolve>   show (resid) (id $id1) 
 CNSsolve>   evaluate ($cgresid=$result) 
 CNSsolve> 
 CNSsolve>   igroup 
 CNSsolve>     ! turn off all vdw interactions between charged beads and all beads 
 CNSsolve>     interaction (segid $cgsegid and resid $cgresid and name SCD1) (all) weight vdw 0.0 end 
 CNSsolve>     interaction (segid $cgsegid and resid $cgresid and name SCD2) (all) weight vdw 0.0 end 
 CNSsolve> 
 CNSsolve>     ! turn off all vdw and elec interactions between the charged beads within one residue 
 CNSsolve>     interaction (segid $cgsegid and resid $cgresid and name SCD1) 
 CNSsolve>                 (segid $cgsegid and resid $cgresid and name SCD2) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>   end 
 CNSsolve> 
 CNSsolve>end loop c1beads 
 CNSsolve> 
 CNSsolve>for $id1 in id ( (resn LYS or resn ARG or resn ASP or resn GLU) and name BB ) loop c2beads 
 SELRPN:      0 atoms have been selected out of   3253
 CNSsolve> 
 CNSsolve>   show (segid) (id $id1) 
 CNSsolve>   evaluate ($cgsegid=$result) 
 CNSsolve>   show (resid) (id $id1) 
 CNSsolve>   evaluate ($cgresid=$result) 
 CNSsolve> 
 CNSsolve>   igroup 
 CNSsolve>     ! turn off all vdw interactions between charged beads and all beads 
 CNSsolve>     interaction (segid $cgsegid and resid $cgresid and name SCD1) (all) weight vdw 0.0 end 
 CNSsolve>   end 
 CNSsolve> 
 CNSsolve>end loop c2beads 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  flag include bond angle dihe impr vdw end 
 CNSsolve> 
 CNSsolve>  evaluate ($elec = 0.0) 
 EVALUATE: symbol $ELEC set to    0.00000     (real)
 CNSsolve>  evaluate ($eintfree = 0.0) 
 EVALUATE: symbol $EINTFREE set to    0.00000     (real)
 CNSsolve>  if ($Data.flags.elec0 eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    flag include elec end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  energy end 
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found   7964 exclusions and   5647 interactions(1-4)
 NBONDS: found   234513 intra-atom interactions
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found    216 exclusions and    145 interactions(1-4)
 NBONDS: found     2315 intra-atom interactions
 --------------- cycle=     2 --------------------------------------------------
 | Etotal =8566.079   grad(E)=88.211     E(BOND)=1005.588   E(ANGL)=1883.816   |
 | E(DIHE)=1777.839   E(IMPR)=6244.500   E(VDW )=-1771.983  E(ELEC)=-584.704   |
 | E(NOE )=11.022                                                              |
 -------------------------------------------------------------------------------
 CNSsolve> 
 CNSsolve>  evaluate ($eintcplx = $bond + $angl + $impr + $dihe + $vdw + $elec) 
 EVALUATE: symbol $EINTCPLX set to    8555.06     (real)
 CNSsolve>  evaluate ($eintfree = $eintcplx) 
 EVALUATE: symbol $EINTFREE set to    8555.06     (real)
 CNSsolve>  {* at this stage the two are similar since rigid-body EM only *} 
 CNSsolve> 
 CNSsolve>{* =========================== write out structure after rigid body refinement *} 
 CNSsolve> 
 CNSsolve>  !bestener.cns: for waterdock, store3 contains store5 from lowest energy structure 
 CNSsolve>  do (x = refx) (not store3) 
 SELRPN: Store empty. No atoms selected.
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>  do (y = refy) (not store3) 
 SELRPN: Store empty. No atoms selected.
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>  do (z = refz) (not store3) 
 SELRPN: Store empty. No atoms selected.
 SELRPN:   3253 atoms have been selected out of   3253
 CNSsolve>  if ($data.waterdock eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    if ($data.solvate_method eq "restraints") then 
 CNSsolve>      noe reset end 
 CNSsolve>      @RUN:protocols/read_noes.cns(Iteration=$Iteration; Data=$Data; count=$count) 
 ASSFIL: file read_noes.cns opened.
 CNSsolve>! read_noes.cns 
 CNSsolve>!    Read distance restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(Iteration; Data; count;) 
 CNSsolve> 
 CNSsolve>!NOEs, hbonds 
 CNSsolve>noe 
 CNSsolve>  reset 
 CNSsolve>  nrestraints = 12000000     ! allocate space for NOEs 
 CNSsolve>  ceiling 1000 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>display reading NEWIT:unambig.tbl in iteration &iteration with option &data.unamb_firstit 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if (&data.amb_firstit le &iteration)   then 
 CNSsolve>     evaluate ($filenam0 = "NEWIT:ambig.tbl_" + encode($count)) 
 CNSsolve>     fileexist $filenam0 end 
 CNSsolve>     if ($result eq false) then 
 CNSsolve>       evaluate ($filenam0 = "NEWIT:ambig.tbl") 
 CNSsolve>     end if 
 CNSsolve>     noe class ambi @@$filenam0 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.unamb_firstit le &iteration) then 
 CNSsolve>     noe class dist @@NEWIT:unambig.tbl end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.hbond_firstit le &iteration) then 
 CNSsolve>   if (&data.hbonds_on eq true) then 
 CNSsolve>      noe @@RUN:data/hbonds/hbonds.tbl end 
 CNSsolve>   end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>  averaging  * sum 
 CNSsolve>  potential  * soft 
 CNSsolve>  scale      * 1.0 
 CNSsolve>  sqconstant * 1.0 
 CNSsolve>  sqexponent * 2 
 CNSsolve>  soexponent * 1 
 CNSsolve>  rswitch    * 1.0 
 CNSsolve>  sqoffset   * 0.0 
 CNSsolve>  asymptote  * 2.0 
 CNSsolve>  msoexponent * 1 
 CNSsolve>  masymptote  * -0.1 
 CNSsolve>  mrswitch    * 1.0 
 CNSsolve>  avexpo hbond 20 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>if (&data.waterdock eq true) then 
 CNSsolve> if (&iteration eq 0) then 
 CNSsolve>  if (&data.solvate_method eq "restraints") then 
 CNSsolve>   evaluate ($nchain=0) 
 CNSsolve>   while ($nchain < &data.ncomponents) loop nloop1 
 CNSsolve>    evaluate ($nchain = $nchain + 1) 
 CNSsolve>    evaluate ($watersegname_$nchain="WA" + encode($nchain)) 
 CNSsolve>    noe class amwa end 
 CNSsolve>    for $atom_id in id ((resn WAT or resn HOH or resn TIP*) and name OH2 and segid $watersegname_$nchain and not store5) loop waterrestraint 
 CNSsolve>   noe 
 CNSsolve>    assi (segid $toppar.prot_segid_$nchain and (resn arg or resn glu or resn lys or resn asp or resn tyr) and ((id $atom_id) around &data.water_restraint_cutoff)) 
 CNSsolve>        (id $atom_id) &data.water_restraint_cutoff &data.water_restraint_cutoff 0.0 
 CNSsolve>   end 
 CNSsolve>  end loop waterrestraint 
 CNSsolve>   end loop nloop1 
 CNSsolve>  end if 
 CNSsolve> end if 
 CNSsolve>end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  evaluate ($esym = 0.0) 
 EVALUATE: symbol $ESYM set to    0.00000     (real)
 CNSsolve>  evaluate ($ncs = 0.0) 
 EVALUATE: symbol $NCS set to    0.00000     (real)
 CNSsolve>  evaluate ($zhar = 0.0) 
 EVALUATE: symbol $ZHAR set to    0.00000     (real)
 CNSsolve>  evaluate ($rms_test_noe = 0.0) 
 EVALUATE: symbol $RMS_TEST_NOE set to    0.00000     (real)
 CNSsolve>  evaluate ($violations_test_noe = 0) 
 EVALUATE: symbol $VIOLATIONS_TEST_NOE set to    0.00000     (real)
 CNSsolve>  if ($Data.flags.sym eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    noe reset nres= 2000000 end 
 CNSsolve>    @RUN:protocols/symmultimer.cns 
 ASSFIL: file symmultimer.cns opened.
 CNSsolve>! symmultimer.cns 
 CNSsolve>!    Define symmetry restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2018 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>! Define NCS restraints for symmetrical multimers 
 CNSsolve>if ($Data.flags.ncs eq true) then 
 CNSsolve> 
 CNSsolve>  ncs restraints 
 CNSsolve>    initialize 
 CNSsolve>    eval ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.numncs) loop ncsloop 
 CNSsolve>      eval ($ncount = $ncount + 1) 
 CNSsolve>      group 
 CNSsolve>        equi (not name H* and resid $Toppar.ncs_sta1_$ncount : $Toppar.ncs_end1_$ncount and segid $Toppar.ncs_seg1_$ncount) 
 CNSsolve>        equi (not name H* and resid $Toppar.ncs_sta2_$ncount : $Toppar.ncs_end2_$ncount and segid $Toppar.ncs_seg2_$ncount) 
 CNSsolve>	weight = $Data.kncs 
 CNSsolve>      end 
 CNSsolve>    end loop ncsloop 
 CNSsolve>    ? 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym eq true) then 
 CNSsolve> 
 CNSsolve>  noe class symm end 
 CNSsolve> 
 CNSsolve>! Define C2 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc2sym) loop c2symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c2sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c2sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c2sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c2sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c2sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c2sym_seg2_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc2sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resid1 = $i1start) 
 CNSsolve>      evaluate ($resid2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resid3 = $i2start) 
 CNSsolve>      evaluate ($resid4 = $i1end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>	assign (resid $resid1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>	       (resid $resid2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>	assign (resid $resid3 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>	       (resid $resid4 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 1) 
 CNSsolve>      evaluate ($i1start = $i1start + 1) 
 CNSsolve>      evaluate ($i2start = $i2start + 1) 
 CNSsolve> 
 CNSsolve>    end loop genc2sym 
 CNSsolve> 
 CNSsolve>  end loop c2symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Define C3 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc3sym) loop c3symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c3sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c3sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c3sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c3sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c3sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c3sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c3sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c3sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c3sym_seg3_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc3sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve> 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resen1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resen1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 2) 
 CNSsolve>      evaluate ($i1start = $i1start + 2) 
 CNSsolve>      evaluate ($i2start = $i2start + 2) 
 CNSsolve>      evaluate ($i3start = $i3start + 2) 
 CNSsolve> 
 CNSsolve>    end loop genc3sym 
 CNSsolve> 
 CNSsolve>  end loop c3symloop 
 CNSsolve> 
 CNSsolve>! Define S3 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.nums3sym) loop s3symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.s3sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.s3sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.s3sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.s3sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.s3sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.s3sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.s3sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.s3sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.s3sym_seg3_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    eval ($istep = 4) 
 CNSsolve>    eval ($istop = $i1end - $istep) 
 CNSsolve>    while ($i1start < $istop) loop gens3sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst11 = $i1start) 
 CNSsolve>      evaluate ($resst21 = $i1start+1) 
 CNSsolve>      evaluate ($resst12 = $i2start) 
 CNSsolve>      evaluate ($resst22 = $i2start+1) 
 CNSsolve>      evaluate ($resst13 = $i3start) 
 CNSsolve>      evaluate ($resst23 = $i3start+1) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve> 
 CNSsolve>         assign (resid $resst11 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resst12 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst12 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resst13 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst21 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resst22 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst22 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resst23 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + $istep) 
 CNSsolve>      evaluate ($i1start = $i1start + $istep) 
 CNSsolve>      evaluate ($i2start = $i2start + $istep) 
 CNSsolve>      evaluate ($i3start = $i3start + $istep) 
 CNSsolve> 
 CNSsolve>    end loop gens3sym 
 CNSsolve> 
 CNSsolve>  end loop s3symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Define C4 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($istep = 10) 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc4sym) loop c4symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c4sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c4sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c4sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c4sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c4sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c4sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c4sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c4sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c4sym_seg3_$ncount) 
 CNSsolve>    evaluate ($i4start = decode($Toppar.c4sym_sta4_$ncount)) 
 CNSsolve>    evaluate ($i4end   = decode($Toppar.c4sym_end4_$ncount)) 
 CNSsolve>    evaluate ($chain4  = $Toppar.c4sym_seg4_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the four defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    evaluate ($diff4 = $i4end - $i4start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff3 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc4sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resst4 = $i4start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve>      evaluate ($resen4 = $i4end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>		 
 CNSsolve>		! N to N sequential restraints to prevent anti-parallel arrangements 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>		 
 CNSsolve>		! N to C sequential restraints to assure planarity 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resen1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resen1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>		 
 CNSsolve>	 assign (resid $resen1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resen2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resen2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resen3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resen3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resen4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resen4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resen1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + $istep) 
 CNSsolve>      evaluate ($i1start = $i1start + $istep) 
 CNSsolve>      evaluate ($i2start = $i2start + $istep) 
 CNSsolve>      evaluate ($i3start = $i3start + $istep) 
 CNSsolve>      evaluate ($i4start = $i4start + $istep) 
 CNSsolve> 
 CNSsolve>    end loop genc4sym 
 CNSsolve> 
 CNSsolve>  end loop c4symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Define C5 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve>  eval ($istep = 4) 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc5sym) loop c5symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c5sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c5sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c5sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c5sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c5sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c5sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c5sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c5sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c5sym_seg3_$ncount) 
 CNSsolve>    evaluate ($i4start = decode($Toppar.c5sym_sta4_$ncount)) 
 CNSsolve>    evaluate ($i4end   = decode($Toppar.c5sym_end4_$ncount)) 
 CNSsolve>    evaluate ($chain4  = $Toppar.c5sym_seg4_$ncount) 
 CNSsolve>    evaluate ($i5start = decode($Toppar.c5sym_sta5_$ncount)) 
 CNSsolve>    evaluate ($i5end   = decode($Toppar.c5sym_end5_$ncount)) 
 CNSsolve>    evaluate ($chain5  = $Toppar.c5sym_seg5_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    evaluate ($diff4 = $i4end - $i4start) 
 CNSsolve>    evaluate ($diff5 = $i5end - $i5start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff3 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff4 ne $diff5) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc5sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resst4 = $i4start) 
 CNSsolve>      evaluate ($resst5 = $i5start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve>      evaluate ($resen4 = $i4end - $icount) 
 CNSsolve>      evaluate ($resen5 = $i5end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resst5 and (name CA or name P or name BB)  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resst5 and (name CA or name P or name BB)  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst5 and (name CA or name P or name BB)  and segid $chain5) 
 CNSsolve>                (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst5 and (name CA or name P or name BB)  and segid $chain5) 
 CNSsolve>                (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + $istep) 
 CNSsolve>      evaluate ($i1start = $i1start + $istep) 
 CNSsolve>      evaluate ($i2start = $i2start + $istep) 
 CNSsolve>      evaluate ($i3start = $i3start + $istep) 
 CNSsolve>      evaluate ($i4start = $i4start + $istep) 
 CNSsolve>      evaluate ($i5start = $i5start + $istep) 
 CNSsolve> 
 CNSsolve>    end loop genc5sym 
 CNSsolve> 
 CNSsolve>  end loop c5symloop 
 CNSsolve> 
 CNSsolve>! Define C6 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve>  eval ($istep = 10) 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc6sym) loop c6symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c6sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c6sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c6sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c6sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c6sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c6sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c6sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c6sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c6sym_seg3_$ncount) 
 CNSsolve>    evaluate ($i4start = decode($Toppar.c6sym_sta4_$ncount)) 
 CNSsolve>    evaluate ($i4end   = decode($Toppar.c6sym_end4_$ncount)) 
 CNSsolve>    evaluate ($chain4  = $Toppar.c6sym_seg4_$ncount) 
 CNSsolve>    evaluate ($i5start = decode($Toppar.c6sym_sta5_$ncount)) 
 CNSsolve>    evaluate ($i5end   = decode($Toppar.c6sym_end5_$ncount)) 
 CNSsolve>    evaluate ($chain5  = $Toppar.c6sym_seg5_$ncount) 
 CNSsolve>    evaluate ($i6start = decode($Toppar.c6sym_sta6_$ncount)) 
 CNSsolve>    evaluate ($i6end   = decode($Toppar.c6sym_end6_$ncount)) 
 CNSsolve>    evaluate ($chain6  = $Toppar.c6sym_seg6_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    evaluate ($diff4 = $i4end - $i4start) 
 CNSsolve>    evaluate ($diff5 = $i5end - $i5start) 
 CNSsolve>    evaluate ($diff6 = $i6end - $i6start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff3 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff4 ne $diff5) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff5 ne $diff6) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc6sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resst4 = $i4start) 
 CNSsolve>      evaluate ($resst5 = $i5start) 
 CNSsolve>      evaluate ($resst6 = $i6start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve>      evaluate ($resen4 = $i4end - $icount) 
 CNSsolve>      evaluate ($resen5 = $i5end - $icount) 
 CNSsolve>      evaluate ($resen6 = $i6end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve> 
 CNSsolve>         ! Around the C6 ring 
 CNSsolve>         ! N to N sequential restraints to prevent anti-parallel arrangements 
 CNSsolve> 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resst5 and (name CA or name P or name BB)  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resst5 and (name CA or name P or name BB)  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst5 and (name CA or name P or name BB)  and segid $chain5) 
 CNSsolve>                (resid $resst6 and (name CA or name P or name BB)  and segid $chain6) 0 0 0 
 CNSsolve>		 
 CNSsolve>         assign (resid $resst5 and (name CA or name P or name BB)  and segid $chain5) 
 CNSsolve>                (resid $resst6 and (name CA or name P or name BB)  and segid $chain6) 0 0 0 
 CNSsolve>         assign (resid $resst6 and (name CA or name P or name BB)  and segid $chain6) 
 CNSsolve>                (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve>		 
 CNSsolve>         assign (resid $resst6 and (name CA or name P or name BB)  and segid $chain6) 
 CNSsolve>                (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0	 
 CNSsolve>		 
 CNSsolve>	! N to C sequential restraints to assure planarity 
 CNSsolve> 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resen5 and (name CA or name P or name BB)  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resen5 and (name CA or name P or name BB)  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst5 and (name CA or name P or name BB)  and segid $chain5) 
 CNSsolve>                (resid $resen6 and (name CA or name P or name BB)  and segid $chain6) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst5 and (name CA or name P or name BB)  and segid $chain5) 
 CNSsolve>                (resid $resen6 and (name CA or name P or name BB)  and segid $chain6) 0 0 0 
 CNSsolve>         assign (resid $resst6 and (name CA or name P or name BB)  and segid $chain6) 
 CNSsolve>                (resid $resen1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         ! Triples 
 CNSsolve> 
 CNSsolve>         assign (resid $resst1 and (name CA or name P or name BB)  and segid $chain1) 
 CNSsolve>                (resid $resen3 and (name CA or name P or name BB)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resen5 and (name CA or name P or name BB)  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P or name BB)  and segid $chain3) 
 CNSsolve>                (resid $resen5 and (name CA or name P or name BB)  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst5 and (name CA or name P or name BB)  and segid $chain5) 
 CNSsolve>                (resid $resen1 and (name CA or name P or name BB)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P or name BB)  and segid $chain2) 
 CNSsolve>                (resid $resen4 and (name CA or name P or name BB)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resen6 and (name CA or name P or name BB)  and segid $chain6) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P or name BB)  and segid $chain4) 
 CNSsolve>                (resid $resen6 and (name CA or name P or name BB)  and segid $chain6) 0 0 0 
 CNSsolve>         assign (resid $resst6 and (name CA or name P or name BB)  and segid $chain6) 
 CNSsolve>                (resid $resen2 and (name CA or name P or name BB)  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + $istep) 
 CNSsolve>      evaluate ($i1start = $i1start + $istep) 
 CNSsolve>      evaluate ($i2start = $i2start + $istep) 
 CNSsolve>      evaluate ($i3start = $i3start + $istep) 
 CNSsolve>      evaluate ($i4start = $i4start + $istep) 
 CNSsolve>      evaluate ($i5start = $i5start + $istep) 
 CNSsolve>      evaluate ($i6start = $i6start + $istep) 
 CNSsolve> 
 CNSsolve>    end loop genc6sym 
 CNSsolve> 
 CNSsolve>  end loop c6symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  noe 
 CNSsolve>    potential  symm symmetry 
 CNSsolve>    scale      symm $Data.ksym 
 CNSsolve>    sqconstant symm 1.0 
 CNSsolve>    sqexponent symm 2 
 CNSsolve>    soexponent symm 1 
 CNSsolve>    rswitch    symm 0.5 
 CNSsolve>    sqoffset   symm 0.0 
 CNSsolve>    asymptote  symm 1.0 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve>    noe 
 CNSsolve>      scale symm $Data.ksym 
 CNSsolve>    end 
 CNSsolve>    energy end 
 CNSsolve>    evaluate ($esym = $noe) 
 CNSsolve>    if ($Data.noecv eq true) then 
 CNSsolve>      display Print out of cross-validated violations and rms not 
 CNSsolve>      display possible in combination with symmetry restraints 
 CNSsolve>      display CV values set therefore to 0 
 CNSsolve>    end if 
 CNSsolve>    noe reset end 
 CNSsolve>    set message=normal echo=on end 
 CNSsolve>    !read again the NOE data, needed to remove the symmetry restraints 
 CNSsolve>    @@RUN:protocols/read_noes.cns(Iteration=$Iteration; Data=$Data; count=$count) 
 CNSsolve>    if ( $log_level = verbose ) then 
 CNSsolve>       set message=normal echo=on end 
 CNSsolve>    else 
 CNSsolve>       set message=off echo=off end 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    if ($Data.noecv eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      set message=on echo=on end 
 CNSsolve>      noe cv $ncvbest ? end 
 CNSsolve>    end if 
 CNSsolve>    if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      set message=normal echo=on end 
 CNSsolve>    else 
 CNSsolve>      set message=off echo=off end 
 $$$$$$$$$$$$$$$$$$ working set $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +++++++++++++++++++++++++++++++ CLASS CONT +++++++++++++++++++++++++++++++++++
 for this class: SCALe=   1.000 AVERage=center POTEntial=biharmonic 
                 TEMPerature= 300.000
 
 ========== restraint    25 ==========
 set-i-atoms
          A    434  ASP  CA  
          A    435  TYR  CA  
          A    436  PHE  CA  
          A    437  GLN  CA  
          A    438  GLY  CA  
          A    439  ALA  CA  
          A    440  MET  CA  
          A    441  GLY  CA  
          A    442  SER  CA  
          A    443  LYS  CA  
          A    444  PRO  CA  
          A    445  ALA  CA  
          A    446  TYR  CA  
          A    447  SER  CA  
          A    448  PHE  CA  
          A    449  HIS  CA  
          A    450  VAL  CA  
          A    451  THR  CA  
          A    452  ALA  CA  
          A    453  ASP  CA  
          A    454  GLY  CA  
          A    455  GLN  CA  
          A    456  MET  CA  
          A    457  GLN  CA  
          A    458  PRO  CA  
          A    459  VAL  CA  
          A    460  PRO  CA  
          A    461  PHE  CA  
          A    462  PRO  CA  
          A    463  PRO  CA  
          A    464  ASP  CA  
          A    465  ALA  CA  
          A    466  LEU  CA  
          A    467  ILE  CA  
          A    468  GLY  CA  
          A    469  PRO  CA  
          A    470  GLY  CA  
          A    471  ILE  CA  
          A    472  PRO  CA  
          A    473  ARG  CA  
          A    474  HIS  CA  
          A    475  ALA  CA  
          A    476  ARG  CA  
          A    477  GLN  CA  
          A    478  ILE  CA  
          A    479  ASN  CA  
          A    480  THR  CA  
          A    481  LEU  CA  
          A    482  ASN  CA  
          A    483  HIS  CA  
          A    484  GLY  CA  
          A    485  GLU  CA  
          A    486  VAL  CA  
          A    487  VAL  CA  
          A    488  CYS  CA  
          A    489  ALA  CA  
          A    490  VAL  CA  
          A    491  THR  CA  
          A    492  ILE  CA  
          A    493  SER  CA  
          A    494  ASN  CA  
          A    495  PRO  CA  
          A    496  THR  CA  
          A    497  ARG  CA  
          A    498  HIS  CA  
          A    499  VAL  CA  
          A    500  TYR  CA  
          A    501  THR  CA  
          A    502  GLY  CA  
          A    503  GLY  CA  
          A    504  LYS  CA  
          A    505  GLY  CA  
          A    506  CYS  CA  
          A    507  VAL  CA  
          A    508  LYS  CA  
          A    509  VAL  CA  
          A    510  TRP  CA  
          A    511  ASP  CA  
          A    512  ILE  CA  
          A    513  SER  CA  
          A    514  HIS  CA  
          A    515  PRO  CA  
          A    516  GLY  CA  
          A    517  ASN  CA  
          A    518  LYS  CA  
          A    519  SER  CA  
          A    520  PRO  CA  
          A    521  VAL  CA  
          A    522  SER  CA  
          A    523  GLN  CA  
          A    524  LEU  CA  
          A    525  ASP  CA  
          A    526  CYS  CA  
          A    527  LEU  CA  
          A    528  ASN  CA  
          A    529  ARG  CA  
          A    530  ASP  CA  
          A    531  ASN  CA  
          A    532  TYR  CA  
          A    533  ILE  CA  
          A    534  ARG  CA  
          A    535  SER  CA  
          A    536  CYS  CA  
          A    537  LYS  CA  
          A    538  LEU  CA  
          A    539  LEU  CA  
          A    540  PRO  CA  
          A    541  ASP  CA  
          A    542  GLY  CA  
          A    543  CYS  CA  
          A    544  THR  CA  
          A    545  LEU  CA  
          A    546  ILE  CA  
          A    547  VAL  CA  
          A    548  GLY  CA  
          A    549  GLY  CA  
          A    550  GLU  CA  
          A    551  ALA  CA  
          A    552  SER  CA  
          A    553  THR  CA  
          A    554  LEU  CA  
          A    555  SER  CA  
          A    556  ILE  CA  
          A    557  TRP  CA  
          A    558  ASP  CA  
          A    559  LEU  CA  
          A    560  ALA  CA  
          A    561  ALA  CA  
          A    562  PRO  CA  
          A    563  THR  CA  
          A    564  PRO  CA  
          A    565  ARG  CA  
          A    566  ILE  CA  
          A    567  LYS  CA  
          A    568  ALA  CA  
          A    569  GLU  CA  
          A    570  LEU  CA  
          A    571  THR  CA  
          A    572  SER  CA  
          A    573  SER  CA  
          A    574  ALA  CA  
          A    575  PRO  CA  
          A    576  ALA  CA  
          A    577  CYS  CA  
          A    578  TYR  CA  
          A    579  ALA  CA  
          A    580  LEU  CA  
          A    581  ALA  CA  
          A    582  ILE  CA  
          A    583  SER  CA  
          A    584  PRO  CA  
          A    585  ASP  CA  
          A    586  SER  CA  
          A    587  LYS  CA  
          A    588  VAL  CA  
          A    589  CYS  CA  
          A    590  PHE  CA  
          A    591  SER  CA  
          A    592  CYS  CA  
          A    593  CYS  CA  
          A    594  SER  CA  
          A    595  ASP  CA  
          A    596  GLY  CA  
          A    597  ASN  CA  
          A    598  ILE  CA  
          A    599  ALA  CA  
          A    600  VAL  CA  
          A    601  TRP  CA  
          A    602  ASP  CA  
          A    603  LEU  CA  
          A    604  HIS  CA  
          A    605  ASN  CA  
          A    606  GLN  CA  
          A    607  THR  CA  
          A    608  LEU  CA  
          A    609  VAL  CA  
          A    610  ARG  CA  
          A    611  GLN  CA  
          A    612  PHE  CA  
          A    613  GLN  CA  
          A    614  GLY  CA  
          A    615  HIS  CA  
          A    616  THR  CA  
          A    617  ASP  CA  
          A    618  GLY  CA  
          A    619  ALA  CA  
          A    620  SER  CA  
          A    621  CYS  CA  
          A    622  ILE  CA  
          A    623  ASP  CA  
          A    624  ILE  CA  
          A    625  SER  CA  
          A    626  ASN  CA  
          A    627  ASP  CA  
          A    628  GLY  CA  
          A    629  THR  CA  
          A    630  LYS  CA  
          A    631  LEU  CA  
          A    632  TRP  CA  
          A    633  THR  CA  
          A    634  GLY  CA  
          A    635  GLY  CA  
          A    636  LEU  CA  
          A    637  ASP  CA  
          A    638  ASN  CA  
          A    639  THR  CA  
          A    640  VAL  CA  
          A    641  ARG  CA  
          A    642  SER  CA  
          A    643  TRP  CA  
          A    644  ASP  CA  
          A    645  LEU  CA  
          A    646  ARG  CA  
          A    647  GLU  CA  
          A    648  GLY  CA  
          A    649  ARG  CA  
          A    650  GLN  CA  
          A    651  LEU  CA  
          A    652  GLN  CA  
          A    653  GLN  CA  
          A    654  HIS  CA  
          A    655  ASP  CA  
          A    656  PHE  CA  
          A    657  THR  CA  
          A    658  SER  CA  
          A    659  GLN  CA  
          A    660  ILE  CA  
          A    661  PHE  CA  
          A    662  SER  CA  
          A    663  LEU  CA  
          A    664  GLY  CA  
          A    665  TYR  CA  
          A    666  CYS  CA  
          A    667  PRO  CA  
          A    668  THR  CA  
          A    669  GLY  CA  
          A    670  GLU  CA  
          A    671  TRP  CA  
          A    672  LEU  CA  
          A    673  ALA  CA  
          A    674  VAL  CA  
          A    675  GLY  CA  
          A    676  MET  CA  
          A    677  GLU  CA  
          A    678  SER  CA  
          A    679  SER  CA  
          A    680  ASN  CA  
          A    681  VAL  CA  
          A    682  GLU  CA  
          A    683  VAL  CA  
          A    684  LEU  CA  
          A    685  HIS  CA  
          A    686  VAL  CA  
          A    687  ASN  CA  
          A    688  LYS  CA  
          A    689  PRO  CA  
          A    690  ASP  CA  
          A    691  LYS  CA  
          A    692  TYR  CA  
          A    693  GLN  CA  
          A    694  LEU  CA  
          A    695  HIS  CA  
          A    696  LEU  CA  
          A    697  HIS  CA  
          A    698  GLU  CA  
          A    699  SER  CA  
          A    700  CYS  CA  
          A    701  VAL  CA  
          A    702  LEU  CA  
          A    703  SER  CA  
          A    704  LEU  CA  
          A    705  LYS  CA  
          A    706  PHE  CA  
          A    707  ALA  CA  
          A    708  TYR  CA  
          A    709  CYS  CA  
          A    710  GLY  CA  
          A    711  LYS  CA  
          A    712  TRP  CA  
          A    713  PHE  CA  
          A    714  VAL  CA  
          A    715  SER  CA  
          A    716  THR  CA  
          A    717  GLY  CA  
          A    718  LYS  CA  
          A    719  ASP  CA  
          A    720  ASN  CA  
          A    721  LEU  CA  
          A    722  LEU  CA  
          A    723  ASN  CA  
          A    724  ALA  CA  
          A    725  TRP  CA  
          A    726  ARG  CA  
          A    727  THR  CA  
          A    728  PRO  CA  
          A    729  TYR  CA  
          A    730  GLY  CA  
          A    731  ALA  CA  
          A    732  SER  CA  
          A    733  ILE  CA  
          A    734  PHE  CA  
          A    735  GLN  CA  
          A    736  SER  CA  
          A    737  LYS  CA  
          A    738  GLU  CA  
          A    739  SER  CA  
          A    740  SER  CA  
          A    741  SER  CA  
          A    742  VAL  CA  
          A    743  LEU  CA  
          A    744  SER  CA  
          A    745  CYS  CA  
          A    746  ASP  CA  
          A    747  ILE  CA  
          A    748  SER  CA  
          A    749  VAL  CA  
          A    750  ASP  CA  
          A    751  ASP  CA  
          A    752  LYS  CA  
          A    753  TYR  CA  
          A    754  ILE  CA  
          A    755  VAL  CA  
          A    756  THR  CA  
          A    757  GLY  CA  
          A    758  SER  CA  
          A    759  GLY  CA  
          A    760  ASP  CA  
          A    761  LYS  CA  
          A    762  LYS  CA  
          A    763  ALA  CA  
          A    764  THR  CA  
          A    765  VAL  CA  
          A    766  TYR  CA  
          A    767  GLU  CA  
          A    768  VAL  CA  
          A    769  ILE  CA  
          A    770  TYR  CA  
 set-j-atoms
          B    1    MET  CA  
          B    2    PHE  CA  
          B    3    TYR  CA  
          B    4    ILE  CA  
          B    5    GLU  CA  
          B    6    ASP  CA  
          B    7    ILE  CA  
          B    8    LEU  CA  
          B    9    ALA  CA  
 R<average>=  17.653 NOE=11.59 (-11.59/+ 1.00) Delta=  -6.065  E(NOE)=  10.963

 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +++++++++++++++++++++++++++++++ CLASS SURF +++++++++++++++++++++++++++++++++++
 for this class: SCALe=   1.000 AVERage=sum    POTEntial=biharmonic 
                 TEMPerature= 300.000
 
 ========== restraint    26 ==========
 set-i-atoms
          A    434  ASP  CA  
          A    435  TYR  CA  
          A    436  PHE  CA  
          A    437  GLN  CA  
          A    438  GLY  CA  
          A    439  ALA  CA  
          A    440  MET  CA  
          A    441  GLY  CA  
          A    442  SER  CA  
          A    443  LYS  CA  
          A    444  PRO  CA  
          A    445  ALA  CA  
          A    446  TYR  CA  
          A    447  SER  CA  
          A    448  PHE  CA  
          A    449  HIS  CA  
          A    450  VAL  CA  
          A    451  THR  CA  
          A    452  ALA  CA  
          A    453  ASP  CA  
          A    454  GLY  CA  
          A    455  GLN  CA  
          A    456  MET  CA  
          A    457  GLN  CA  
          A    458  PRO  CA  
          A    459  VAL  CA  
          A    460  PRO  CA  
          A    461  PHE  CA  
          A    462  PRO  CA  
          A    463  PRO  CA  
          A    464  ASP  CA  
          A    465  ALA  CA  
          A    466  LEU  CA  
          A    467  ILE  CA  
          A    468  GLY  CA  
          A    469  PRO  CA  
          A    470  GLY  CA  
          A    471  ILE  CA  
          A    472  PRO  CA  
          A    473  ARG  CA  
          A    474  HIS  CA  
          A    475  ALA  CA  
          A    476  ARG  CA  
          A    477  GLN  CA  
          A    478  ILE  CA  
          A    479  ASN  CA  
          A    480  THR  CA  
          A    481  LEU  CA  
          A    482  ASN  CA  
          A    483  HIS  CA  
          A    484  GLY  CA  
          A    485  GLU  CA  
          A    486  VAL  CA  
          A    487  VAL  CA  
          A    488  CYS  CA  
          A    489  ALA  CA  
          A    490  VAL  CA  
          A    491  THR  CA  
          A    492  ILE  CA  
          A    493  SER  CA  
          A    494  ASN  CA  
          A    495  PRO  CA  
          A    496  THR  CA  
          A    497  ARG  CA  
          A    498  HIS  CA  
          A    499  VAL  CA  
          A    500  TYR  CA  
          A    501  THR  CA  
          A    502  GLY  CA  
          A    503  GLY  CA  
          A    504  LYS  CA  
          A    505  GLY  CA  
          A    506  CYS  CA  
          A    507  VAL  CA  
          A    508  LYS  CA  
          A    509  VAL  CA  
          A    510  TRP  CA  
          A    511  ASP  CA  
          A    512  ILE  CA  
          A    513  SER  CA  
          A    514  HIS  CA  
          A    515  PRO  CA  
          A    516  GLY  CA  
          A    517  ASN  CA  
          A    518  LYS  CA  
          A    519  SER  CA  
          A    520  PRO  CA  
          A    521  VAL  CA  
          A    522  SER  CA  
          A    523  GLN  CA  
          A    524  LEU  CA  
          A    525  ASP  CA  
          A    526  CYS  CA  
          A    527  LEU  CA  
          A    528  ASN  CA  
          A    529  ARG  CA  
          A    530  ASP  CA  
          A    531  ASN  CA  
          A    532  TYR  CA  
          A    533  ILE  CA  
          A    534  ARG  CA  
          A    535  SER  CA  
          A    536  CYS  CA  
          A    537  LYS  CA  
          A    538  LEU  CA  
          A    539  LEU  CA  
          A    540  PRO  CA  
          A    541  ASP  CA  
          A    542  GLY  CA  
          A    543  CYS  CA  
          A    544  THR  CA  
          A    545  LEU  CA  
          A    546  ILE  CA  
          A    547  VAL  CA  
          A    548  GLY  CA  
          A    549  GLY  CA  
          A    550  GLU  CA  
          A    551  ALA  CA  
          A    552  SER  CA  
          A    553  THR  CA  
          A    554  LEU  CA  
          A    555  SER  CA  
          A    556  ILE  CA  
          A    557  TRP  CA  
          A    558  ASP  CA  
          A    559  LEU  CA  
          A    560  ALA  CA  
          A    561  ALA  CA  
          A    562  PRO  CA  
          A    563  THR  CA  
          A    564  PRO  CA  
          A    565  ARG  CA  
          A    566  ILE  CA  
          A    567  LYS  CA  
          A    568  ALA  CA  
          A    569  GLU  CA  
          A    570  LEU  CA  
          A    571  THR  CA  
          A    572  SER  CA  
          A    573  SER  CA  
          A    574  ALA  CA  
          A    575  PRO  CA  
          A    576  ALA  CA  
          A    577  CYS  CA  
          A    578  TYR  CA  
          A    579  ALA  CA  
          A    580  LEU  CA  
          A    581  ALA  CA  
          A    582  ILE  CA  
          A    583  SER  CA  
          A    584  PRO  CA  
          A    585  ASP  CA  
          A    586  SER  CA  
          A    587  LYS  CA  
          A    588  VAL  CA  
          A    589  CYS  CA  
          A    590  PHE  CA  
          A    591  SER  CA  
          A    592  CYS  CA  
          A    593  CYS  CA  
          A    594  SER  CA  
          A    595  ASP  CA  
          A    596  GLY  CA  
          A    597  ASN  CA  
          A    598  ILE  CA  
          A    599  ALA  CA  
          A    600  VAL  CA  
          A    601  TRP  CA  
          A    602  ASP  CA  
          A    603  LEU  CA  
          A    604  HIS  CA  
          A    605  ASN  CA  
          A    606  GLN  CA  
          A    607  THR  CA  
          A    608  LEU  CA  
          A    609  VAL  CA  
          A    610  ARG  CA  
          A    611  GLN  CA  
          A    612  PHE  CA  
          A    613  GLN  CA  
          A    614  GLY  CA  
          A    615  HIS  CA  
          A    616  THR  CA  
          A    617  ASP  CA  
          A    618  GLY  CA  
          A    619  ALA  CA  
          A    620  SER  CA  
          A    621  CYS  CA  
          A    622  ILE  CA  
          A    623  ASP  CA  
          A    624  ILE  CA  
          A    625  SER  CA  
          A    626  ASN  CA  
          A    627  ASP  CA  
          A    628  GLY  CA  
          A    629  THR  CA  
          A    630  LYS  CA  
          A    631  LEU  CA  
          A    632  TRP  CA  
          A    633  THR  CA  
          A    634  GLY  CA  
          A    635  GLY  CA  
          A    636  LEU  CA  
          A    637  ASP  CA  
          A    638  ASN  CA  
          A    639  THR  CA  
          A    640  VAL  CA  
          A    641  ARG  CA  
          A    642  SER  CA  
          A    643  TRP  CA  
          A    644  ASP  CA  
          A    645  LEU  CA  
          A    646  ARG  CA  
          A    647  GLU  CA  
          A    648  GLY  CA  
          A    649  ARG  CA  
          A    650  GLN  CA  
          A    651  LEU  CA  
          A    652  GLN  CA  
          A    653  GLN  CA  
          A    654  HIS  CA  
          A    655  ASP  CA  
          A    656  PHE  CA  
          A    657  THR  CA  
          A    658  SER  CA  
          A    659  GLN  CA  
          A    660  ILE  CA  
          A    661  PHE  CA  
          A    662  SER  CA  
          A    663  LEU  CA  
          A    664  GLY  CA  
          A    665  TYR  CA  
          A    666  CYS  CA  
          A    667  PRO  CA  
          A    668  THR  CA  
          A    669  GLY  CA  
          A    670  GLU  CA  
          A    671  TRP  CA  
          A    672  LEU  CA  
          A    673  ALA  CA  
          A    674  VAL  CA  
          A    675  GLY  CA  
          A    676  MET  CA  
          A    677  GLU  CA  
          A    678  SER  CA  
          A    679  SER  CA  
          A    680  ASN  CA  
          A    681  VAL  CA  
          A    682  GLU  CA  
          A    683  VAL  CA  
          A    684  LEU  CA  
          A    685  HIS  CA  
          A    686  VAL  CA  
          A    687  ASN  CA  
          A    688  LYS  CA  
          A    689  PRO  CA  
          A    690  ASP  CA  
          A    691  LYS  CA  
          A    692  TYR  CA  
          A    693  GLN  CA  
          A    694  LEU  CA  
          A    695  HIS  CA  
          A    696  LEU  CA  
          A    697  HIS  CA  
          A    698  GLU  CA  
          A    699  SER  CA  
          A    700  CYS  CA  
          A    701  VAL  CA  
          A    702  LEU  CA  
          A    703  SER  CA  
          A    704  LEU  CA  
          A    705  LYS  CA  
          A    706  PHE  CA  
          A    707  ALA  CA  
          A    708  TYR  CA  
          A    709  CYS  CA  
          A    710  GLY  CA  
          A    711  LYS  CA  
          A    712  TRP  CA  
          A    713  PHE  CA  
          A    714  VAL  CA  
          A    715  SER  CA  
          A    716  THR  CA  
          A    717  GLY  CA  
          A    718  LYS  CA  
          A    719  ASP  CA  
          A    720  ASN  CA  
          A    721  LEU  CA  
          A    722  LEU  CA  
          A    723  ASN  CA  
          A    724  ALA  CA  
          A    725  TRP  CA  
          A    726  ARG  CA  
          A    727  THR  CA  
          A    728  PRO  CA  
          A    729  TYR  CA  
          A    730  GLY  CA  
          A    731  ALA  CA  
          A    732  SER  CA  
          A    733  ILE  CA  
          A    734  PHE  CA  
          A    735  GLN  CA  
          A    736  SER  CA  
          A    737  LYS  CA  
          A    738  GLU  CA  
          A    739  SER  CA  
          A    740  SER  CA  
          A    741  SER  CA  
          A    742  VAL  CA  
          A    743  LEU  CA  
          A    744  SER  CA  
          A    745  CYS  CA  
          A    746  ASP  CA  
          A    747  ILE  CA  
          A    748  SER  CA  
          A    749  VAL  CA  
          A    750  ASP  CA  
          A    751  ASP  CA  
          A    752  LYS  CA  
          A    753  TYR  CA  
          A    754  ILE  CA  
          A    755  VAL  CA  
          A    756  THR  CA  
          A    757  GLY  CA  
          A    758  SER  CA  
          A    759  GLY  CA  
          A    760  ASP  CA  
          A    761  LYS  CA  
          A    762  LYS  CA  
          A    763  ALA  CA  
          A    764  THR  CA  
          A    765  VAL  CA  
          A    766  TYR  CA  
          A    767  GLU  CA  
          A    768  VAL  CA  
          A    769  ILE  CA  
          A    770  TYR  CA  
 set-j-atoms
          B    1    MET  CA  
          B    2    PHE  CA  
          B    3    TYR  CA  
          B    4    ILE  CA  
          B    5    GLU  CA  
          B    6    ASP  CA  
          B    7    ILE  CA  
          B    8    LEU  CA  
          B    9    ALA  CA  
 R<average>=   3.896 NOE= 7.00 (- 7.00/+ 1.00) Delta=   3.104  E(NOE)=   0.059

 NOEPRI: RMS diff. =   1.336,  #(violat.> 0.3)=     2 of     26 NOEs
 NOEPRI: RMS diff. class DIST =   0.000,  #(viol.> 0.3)=     0 of     24 NOEs
 NOEPRI: RMS diff. class CONT =   6.065,  #(viol.> 0.3)=     1 of      1 NOEs
 NOEPRI: RMS diff. class SURF =   3.104,  #(viol.> 0.3)=     1 of      1 NOEs
 $$$$$$$$$$$$$$$$$$$$ test set (TEST=    2)  $$$$$$$$$$$$$$$$$$$$$$

 NOEPRI: RMS diff. =     NaN,  #(violat.> 0.3)=     0 of      0 NOEs
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found      0 exclusions and      0 interactions(1-4)
 NBONDS: found     5618 intra-atom interactions
 --------------- cycle=     3 --------------------------------------------------
 | Etotal =-21.791    grad(E)=0.933      E(BOND)=0.000      E(ANGL)=0.000      |
 | E(DIHE)=0.000      E(IMPR)=0.000      E(VDW )=-18.554    E(ELEC)=-3.296     |
 | E(NOE )=0.059                                                               |
 -------------------------------------------------------------------------------
 Total number of dihedral angle restraints=     0
  overall scale =    1.0000
 Number of dihedral angle restraints=    0
 Number of violations greater than    5.000:     0
 RMS deviation=   0.000
 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 Number of violations greater    0.050:     0
 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 Number of violations greater    5.000:     0
 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 Number of violations greater    5.000:     0
 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 Number of violations greater   30.000:     0
 SURFAC: half the sigma value being used for atomic radii.
 SURFAC: ACCEssible surface area
 SURFAC: ACCUracy= 0.07 RH2O=  1.40
         Z-grid=  0.32 number-of-Z-sections=  187
         measures-of-arc= 30405 and 36569
 SURFAC: half the sigma value being used for atomic radii.
 SURFAC: ACCEssible surface area
 SURFAC: ACCUracy= 0.07 RH2O=  1.40
         Z-grid=  0.32 number-of-Z-sections=   73
         measures-of-arc=   423 and   767
 SURFAC: half the sigma value being used for atomic radii.
 SURFAC: ACCEssible surface area
 SURFAC: ACCUracy= 0.07 RH2O=  1.40
         Z-grid=  0.32 number-of-Z-sections=  187
         measures-of-arc= 31466 and 37511
 MOMENTS
 426055.23367027 -74858.78121329  17012.32828387
                 237734.17980531  68318.91563594
                                 542466.85089582

 HEAP: maximum use      =  2918682656 current use      =     1536000 bytes
 HEAP: maximum overhead =        4448 current overhead =        1232 bytes
 PRIEND:    1 levels not terminated
             LEVEL=   1 KEY=CNSsolve>        ACTION=GO  
          ============================================================
           Maximum dynamic memory allocation:  2918682656 bytes
           Maximum dynamic memory overhead:          4448 bytes
           Program started at: 09:31:27 on 08-Nov-2022
           Program stopped at: 09:31:28 on 08-Nov-2022
           CPU time used:       0.8747 seconds
          ============================================================
